/*##############################################################################

    HPCC SYSTEMS software Copyright (C) 2012 HPCC SystemsÂ®.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
############################################################################## */

#include "xslprocessor.hpp"
//  ===========================================================================

EspInclude(common);

//The ESPenum ECLWUActions has to be matched by the ECLWUActionNames[] in ws_workunitsService.cpp.
ESPenum ECLWUActions : string
{
    Abort("Abort"),
    Delete("Delete"),
    EventDeschedule("Deschedule"),
    EventReschedule("Reschedule"),
    Pause("Pause"),
    PauseNow("PauseNow"),
    Protect("Protect"),
    Unprotect("Unprotect"),
    Restore("Restore"),
    Resume("Resume"),
    SetToFailed("SetToFailed"),
};

ESPenum EclDefinitionActions : string
{
    SyntaxCheck("SyntaxCheck"),
    Deploy("Deploy"),
    Publish("Publish"),
};

ESPenum ErrorMessageFormat : string
{
    XML("xml"),
    JSON("json"),
    Text("text")
};

ESPStruct [nil_remove] ECLException
{
    string Source;
    string Severity;
    int Code;
    string Message;
    string FileName;
    int LineNo;
    int Column;
    [min_ver("1.63")] int Activity;
    [min_ver("1.69")] string Scope;
    [min_ver("1.69")] int Priority;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLSchemaItem
{
    string ColumnName;
    string ColumnType;
    int    ColumnTypeCode;
    bool   isConditional(false);
};
//  ===========================================================================
ESPStruct [nil_remove] ECLResult
{
    string Name;
    int    Sequence;
    string Value;
    string Link;
    string FileName;
    bool   IsSupplied;
    bool   ShowFileContent(true);
    int64  Total;

    ESParray<ESPstruct ECLSchemaItem>    ECLSchemas;
    [min_ver("1.39")] string XmlSchema;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLTimingData
{
    string Name;
    int GraphNum;
    int SubGraphNum;
    int GID;
    int Min;
    int MS;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLGraph
{
    string Name;
    string Label;
    string Type;
    bool Running;
    [min_ver("1.09")] bool Complete;
    [min_ver("1.14")] bool Failed;
    int64 RunningId;
    [min_ver("1.53")]string WhenStarted;
    [min_ver("1.53")]string WhenFinished;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLGraphEx
{
    string Name;
    string Label;
    string Type;
    string Graph;
    bool Running;
    int64 RunningId;
    [min_ver("1.21")] bool Complete;
    [min_ver("1.21")] bool Failed;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLSourceFile
{
    [min_ver("1.01")] string FileCluster;
    string Name;
    [min_ver("1.12")] bool IsSuperFile;
    [min_ver("1.27")] int Subs;
    int Count;

   [min_ver("1.27")] ESParray<ESPstruct ECLSourceFile>    ECLSourceFiles;
};
//  ===========================================================================
ESPStruct [nil_remove] ECLTimer
{
    string Name;
    string Value;
    int count;
    [min_ver("1.20")] string GraphName;
    [min_ver("1.20")] int SubGraphId;
    [min_ver("1.72")] int64 Timestamp;
    [min_ver("1.72")] string When;
};

//  ===========================================================================
ESPStruct [nil_remove] ECLHelpFile
{
    string Name;
    string Type;
    [min_ver("1.32")] string IPAddress;
    [min_ver("1.32")] string Description;
    [min_ver("1.43")] int64 FileSize;
    [min_ver("1.44")] unsigned PID(0);
    [min_ver("1.58")] unsigned minActivityId(0);
    [min_ver("1.58")] unsigned maxActivityId(0);
};

//  ===========================================================================
ESPStruct [nil_remove] ECLQuery
{
    string Text;
    string Cpp;
    string ResTxt;
    string Dll;
    string ThorLog;
    [min_ver("1.35")] string QueryMainDefinition;
};

//  ===========================================================================

ESPStruct [nil_remove] QueryStatsRecord
{
    string StartTime;
    int64 ElapsedTimeMs;
    int64 MemoryUsed;
    int64 BytesOut;
    int SlavesReplyLen;
    bool Failed;
};

//  ===========================================================================

ESPStruct [nil_remove] QuerySummaryStats
{
    string Endpoint;
    string Status;
    string StartTime;
    string EndTime;
    int CountTotal;
    int CountFailed;
    int AverageSlavesReplyLen;
    int64 AverageBytesOut;
    int64 SizeAvgPeakMemory;
    int64 TimeAvgTotalExecuteMinutes;
    int64 TimeMinTotalExecuteMinutes;
    int64 TimeMaxTotalExecuteMinutes;
    int64 Percentile97;
    bool Percentile97Estimate;
};

//  ===========================================================================

ESPStruct [nil_remove] QueryStats
{
    string ID; //QueryID or Global
    ESParray<ESPstruct QuerySummaryStats> AggregateQueryStatsList;
    ESParray<ESPstruct QueryStatsRecord> QueryStatsRecordList;
};

//  ===========================================================================

ESPStruct [nil_remove] EndpointQueryStats
{
    string Endpoint;
    string Status;
    ESParray<ESPstruct QueryStats> QueryStatsList;
};

//  ===========================================================================

ESPStruct [nil_remove] DebugValue
{
    string Name;
    string Value;
};

ESPStruct [nil_remove] WUActionResult
{
    string Wuid;
    string Action;
    string Result;
};

ESPStruct [nil_remove] ApplicationValue
{
    string Application;
    string Name;
    string Value;
};

ESPStruct [nil_remove] ECLWorkflow
{
    string WFID;
    string EventName("");
    string EventText("");
    int Count(-1);
    int CountRemaining(-1);
};

ESPStruct [nil_remove] ThorLogInfo
{
    string ProcessName;
    string ClusterGroup;
    string LogDate;
    int    NumberSlaves;
};

ESPStruct [nil_remove] ECLWorkunitLW
{
    string Wuid;
    string Owner; //IConstWorkUnitInfo queryUser()
    string JobName;
    string WuScope;
    string ClusterName;
    int State;
    string StateDesc;
    int Action;
    string ActionDesc;
    int Priority;
    string PriorityDesc;
    int PriorityLevel;
    bool IsProtected;
    xsdDateTime DateTimeScheduled;

    unsigned TotalClusterTime;
    ESParray<ESPstruct ApplicationValue> ApplicationValues;
};

ESPStruct [nil_remove] ECLWorkunit
{
    string Wuid;
    string Owner;
    string Cluster;
    [min_ver("1.07")] string RoxieCluster;
    string Jobname;
    string Queue;
    int StateID;    //Equiv to workunit::state
    string State;   //Equiv to workunit::stateDesc
    string StateEx;
    string Description;
    bool Protected;
    bool Active;
    int Action;
    [min_ver("1.33")] string ActionEx;
    xsdDateTime DateTimeScheduled;
    int PriorityClass;
    int PriorityLevel;
    string Scope;
    string Snapshot;
    int    ResultLimit;
    [min_ver("1.01")] bool Archived;
    [min_ver("1.30")] bool IsPausing(false);
    [min_ver("1.30")] bool ThorLCR(false);
    [min_ver("1.01")] int EventSchedule;
    [min_ver("1.02"), depr_ver("1.71")] bool HaveSubGraphTimings;
    [min_ver("1.28"), depr_ver("1.53")] string TotalThorTime;
    [min_ver("1.53")] string TotalClusterTime;
    [min_ver("1.59")] string AbortBy;
    [min_ver("1.59")] string AbortTime;

    ESPstruct ECLQuery Query;
    [min_ver("1.03")] ESParray<ESPstruct ECLHelpFile> Helpers;
    ESParray<ESPstruct ECLException>    Exceptions;
    ESParray<ESPstruct ECLGraph>        Graphs;
    ESParray<ESPstruct ECLSourceFile>   SourceFiles;
    ESParray<ESPstruct ECLResult>       Results;
    ESParray<ESPstruct ECLResult>       Variables;
    ESParray<ESPstruct ECLTimer>        Timers;
    ESParray<ESPstruct DebugValue>      DebugValues;
    ESParray<ESPstruct ApplicationValue> ApplicationValues;
    [min_ver("1.01")] ESParray<ESPstruct ECLWorkflow> Workflows;
    [min_ver("1.02")] ESParray<ESPstruct ECLTimingData> TimingData;
    [min_ver("1.05")] ESParray<string, AllowedCluster> AllowedClusters;
    [min_ver("1.17")] int ErrorCount;
    [min_ver("1.17")] int WarningCount;
    [min_ver("1.17")] int InfoCount;
    [min_ver("1.52")] int AlertCount;
    [min_ver("1.17")] int GraphCount;
    [min_ver("1.17")] int SourceFileCount;
    [min_ver("1.17")] int ResultCount;
    [min_ver("1.17")] int VariableCount;
    [min_ver("1.17")] int TimerCount;
    [min_ver("1.17")] bool HasDebugValue;
    [min_ver("1.17")] int ApplicationValueCount;
    [min_ver("1.22")] string XmlParams;
    [min_ver("1.23")] int AccessFlag;
    [min_ver("1.24")] int ClusterFlag;
    [min_ver("1.29")] string HelpersDesc;
    [min_ver("1.29")] string GraphsDesc;
    [min_ver("1.29")] string SourceFilesDesc;
    [min_ver("1.29")] string ResultsDesc;
    [min_ver("1.29")] string VariablesDesc;
    [min_ver("1.29")] string TimersDesc;
    [min_ver("1.29")] string DebugValuesDesc;
    [min_ver("1.29")] string ApplicationValuesDesc;
    [min_ver("1.29")] string WorkflowsDesc;
    [min_ver("1.31")] bool HasArchiveQuery;
    [min_ver("1.38")] ESParray<ESPstruct ThorLogInfo> ThorLogList;
    [min_ver("1.47")] ESParray<string, URL> ResourceURLs;
    [min_ver("1.50")] int ResultViewCount;
    [min_ver("1.50")] int ResourceURLCount;
    [min_ver("1.50")] int DebugValueCount;
    [min_ver("1.50")] int WorkflowCount;
    [min_ver("1.67")] int HelpersCount;
};

ESPStruct [nil_remove] WUECLAttribute
{
    string ModuleName;
    string AttributeName;
    bool IsLocked;
    bool IsCheckedOut;
    bool IsSandbox;
    bool IsOrphaned;
};

//  ===========================================================================
ESPStruct NetworkNode
{
    int Category;
    string id;
};

ESPStruct [nil_remove] ClusterEndpoint
{
    string URL;
    string Status;
    int NumQueryFileToCopy;
};

ESPStruct LogicalFileUpload
{
    int     Type;
    string  Source;
    string  Destination;
    string  EventTag;
};

//  ===========================================================================

ESPStruct [nil_remove] ECLJob
{
    string Wuid;
    string Graph;
    string State;
    string StartedDate;
    string FinishedDate;
    string Cluster;
    [min_ver("1.06")] string GraphNum;
    [min_ver("1.06")] string SubGraphNum;
    [min_ver("1.06")] string NumOfRuns;
    [min_ver("1.06")] int Duration;
};

ESPStruct [nil_remove] ThorQueue
{
    string DT;
    string RunningWUs;
    string QueuedWUs;
    string WaitingThors;
    string ConnectedThors;
    string IdledThors;
    string RunningWU1;
    string RunningWU2;
};

ESPStruct [nil_remove] ResubmittedWU
{
    string WUID;
    string ParentWUID;
};

ESPenum WUFileType : string
{
    XML("XML"),
    CPP("cpp"),
    DLL("dll"),
    Res("res"),
    LOG("log"),
    WUECL("WUECL"),
    ThorLog("ThorLog"),
    ThorSlaveLog("ThorSlaveLog"),
    EclAgentLog("EclAgentLog"),
    ArchiveQuery("ArchiveQuery"),
};

ESPStruct WUFileOption
{
    ESPenum WUFileType FileType;
    string Name; //CPP, ThorLog, and EclAgentLog: required; XML: optional
    string IPAddress; //CPP/XML: required; ThorSlaveLog: required for legacy WU
    string Description; //CPP/XML: required
    string Process; //EclAgentLog and ThorSlaveLog: optional
    string LogDate; //ThorSlaveLog: required
    string ClusterGroup; //ThorSlaveLog: not required for legacy WU
    string PlainText; //XML: optional
    int SlaveNumber(1); //ThorSlaveLog: optional
    int64 SizeLimit(0);
};

ESPenum WUFileDownloadOption : int
{
    OriginalText(0, "OriginalText"),
    Attachment(1,   "Attachment"),
    ZIP(2,          "ZIP"),
    GZIP(3,         "GZIP")
};

ESPrequest [nil_remove] WUCreateRequest
{
};

ESPresponse [exceptions_inline] WUCreateResponse
{
    ESPstruct ECLWorkunit Workunit;
};

ESPrequest [nil_remove] WUDeployWorkunitRequest
{
    string Cluster;
    string Name;
    int Wait(-1);
    string ObjType;
    string FileName;
    binary Object;
    int ResultLimit;
    string QueryMainDefinition;
    string Snapshot;
    ESParray<ESPstruct NamedValue> DebugValues;
};

ESPresponse [exceptions_inline] WUDeployWorkunitResponse
{
    ESPstruct ECLWorkunit Workunit;
};

ESPrequest [nil_remove] WUQueryRequest
{
    string Wuid;
    [min_ver("1.01")] string Type;  //archived or non-archived
    string Cluster;
    [min_ver("1.08")] string RoxieCluster;
    string Owner;
    string State;
    string StartDate;
    string EndDate;
    string ECL;
    string Jobname;
    string LogicalFile;
    string LogicalFileSearchType("");

    [depr_ver("1.57")] string ApplicationName;
    [depr_ver("1.57")] string ApplicationKey;
    [depr_ver("1.57")] string ApplicationData;
    [min_ver("1.57")] ESParray<ESPstruct ApplicationValue> ApplicationValues;
    [min_ver("1.72")] string BeforeWU;
    [min_ver("1.72")] string AfterWU;
    [min_ver("1.77")] unsigned TotalClusterTimeThresholdMilliSec(0);

    [depr_ver("1.02")] string After; //Not used since 1.02
    [depr_ver("1.02")] string Before; //Not used since 1.02
    int Count;
    [min_ver("1.03")] int64 PageSize(0);
    [min_ver("1.03")] int64 PageStartFrom(0);
    [min_ver("1.03")] int64 PageEndAt;
    [min_ver("1.26"), depr_ver("1.72")] int LastNDays;

    string Sortby;
    bool Descending(false);
    int64 CacheHint;
};


ESPresponse [nil_remove, exceptions_inline] WUQueryResponse
{
    [min_ver("1.01")] string Type("");  //archived or non-archived
    string Cluster;
    [min_ver("1.08")] string RoxieCluster;
    string Owner;
    string State;
    string StartDate;
    string EndDate;
    string ECL;
    string Jobname;
    [min_ver("1.01")] string LogicalFile;
    [min_ver("1.01")] string LogicalFileSearchType("");

    string Current;
    string Next;
    int Count(0);

    [min_ver("1.03")] int64 PageSize(0);
    [min_ver("1.03")] int64 PrevPage;
    [min_ver("1.03")] int64 NextPage;
    [min_ver("1.03")] int64 LastPage(-1);

    int NumWUs;
    bool First(true);
    [min_ver("1.03")] int64 PageStartFrom(-1);
    [min_ver("1.03")] int64 PageEndAt;
    [min_ver("1.26"), depr_ver("1.72")] int LastNDays;

    string Sortby;
    bool Descending(false);
    string BasicQuery;
    string Filters;
    [min_ver("1.41")] int64 CacheHint;

    ESParray<ESPstruct ECLWorkunit> Workunits;
};

ESPrequest [nil_remove] WULightWeightQueryRequest
{
    string Wuid;
    string Type;  //archived or non-archived
    string Cluster;
    string Owner;
    string JobName;
    string StartDate;
    string EndDate;
    [min_ver("1.72")] string BeforeWU;
    [min_ver("1.72")] string AfterWU;
    string State;

    ESParray<ESPstruct ApplicationValue> ApplicationValues;

    int64 PageStartFrom;
    unsigned PageSize;
    string SortBy;
    bool Descending(false);

    int64 CacheHint;
};


ESPresponse [nil_remove, exceptions_inline] WULightWeightQueryResponse
{
    int NumWUs;
    int64 CacheHint;
    ESParray<ESPstruct ECLWorkunitLW> Workunits;
};

ESPrequest [nil_remove] WUUpdateRequest
{
    string Wuid;
    int    State;
    int    StateOrig;
    string Jobname;
    string JobnameOrig;
    string QueryText;
    int    Action;
    string Description;
    string DescriptionOrig;
    bool   AddDrilldownFields;
    int    ResultLimit; //unsigned?
    [http_nillable(0)] bool   Protected;
    [http_nillable(0)] bool   ProtectedOrig;
    int    PriorityClass;
    int    PriorityLevel;
    string Scope;
    string ScopeOrig;
    [min_ver("1.05")] string ClusterSelection;
    [min_ver("1.05")] string ClusterOrig;
    [min_ver("1.22")] string XmlParams;
    [min_ver("1.25")] string ThorSlaveIP;
    [min_ver("1.35")] string QueryMainDefinition;

    ESParray<ESPstruct DebugValue>       DebugValues;
    ESParray<ESPstruct ApplicationValue> ApplicationValues;
};

ESPresponse [exceptions_inline] WUUpdateResponse
{
    ESPstruct ECLWorkunit Workunit;
};

ESPrequest WUDeleteRequest
{
    ESParray<string> Wuids;
    [min_ver("1.02")] int BlockTillFinishTimer(0);
};

ESPresponse [exceptions_inline] WUDeleteResponse
{
    ESParray<ESPstruct WUActionResult> ActionResults;
};

/* html */
ESPrequest [nil_remove] WUActionRequest
{
    ESParray<string> Wuids;
    [depr_ver("1.57")] string ActionType;
    [min_ver("1.57")] ESPenum ECLWUActions WUActionType;

    string Cluster;
    string Owner;
    string State;
    string StartDate;
    string EndDate;
    string ECL;
    string Jobname;
    string Test;
    string CurrentPage("");
    [min_ver("1.03")] string PageSize("");
    string Sortby;
    bool Descending(false);
    //[min_ver("1.01")] string SashaNetAddress;
    [min_ver("1.01")] string EventServer("");
    [min_ver("1.01")] string EventName("");
    //[min_ver("1.01")] string EventText("");
    [min_ver("1.01")] string PageFrom("");
    [min_ver("1.02")] int BlockTillFinishTimer(0);
};

ESPresponse [exceptions_inline] WUActionResponse
{
    ESParray<ESPstruct WUActionResult> ActionResults;
};

ESPrequest WUAbortRequest
{
    ESParray<string> Wuids;
    [min_ver("1.02")] int BlockTillFinishTimer(0);
};

ESPresponse [exceptions_inline] WUAbortResponse
{
    ESParray<ESPstruct WUActionResult> ActionResults;
};

ESPrequest WUProtectRequest
{
    ESParray<string> Wuids;
    bool Protect(true);
};

ESPresponse [exceptions_inline] WUProtectResponse
{
    ESParray<ESPstruct WUActionResult> ActionResults;
};

ESPrequest WUResubmitRequest
{
    ESParray<string> Wuids;
    [max_ver("1.30")] bool Recompile;
    [min_ver("1.02")] int BlockTillFinishTimer(0);
    bool ResetWorkflow;
    bool CloneWorkunit;
};

ESPresponse [exceptions_inline] WUResubmitResponse
{
    [min_ver("1.40")] ESParray<ESPstruct ResubmittedWU, WU> WUs;
};

ESPenum WUQueryActivationMode : int
{
    NoActivate(0, "Do not activate query"),
    Activate(1, "Activate query"),
    ActivateSuspendPrevious(2, "Activate query, suspend previous"),
    ActivateDeletePrevious(3, "Activate query, delete previous")
};

ESPrequest [nil_remove] WURecreateQueryRequest
{
    string Target;
    string QueryId;
    ESParray<ESPstruct NamedValue> DebugValues;
    string DestTarget;
    bool Republish(0);
    ESPEnum WUQueryActivationMode Activate;
    bool NoReload(0);

    string MemoryLimit;
    nonNegativeInteger TimeLimit(0);
    nonNegativeInteger WarnTimeLimit(0);
    string Priority;
    string Comment;

    string RemoteDali;
    bool DontCopyFiles(false);
    string SourceProcess;
    bool AllowForeignFiles(false);
    bool UpdateDfs(false);
    bool UpdateSuperFiles(false); //update content of superfiles if changed
    bool UpdateCloneFrom(false); //explicity wan't to change where roxie will grab from
    bool AppendCluster(true); //file exists on other local cluster, add new one, make optional in case of locking issues, but should be made to work
    bool IncludeFileErrors(false);

    int Wait(-1);
};

ESPresponse [exceptions_inline, nil_remove] WURecreateQueryResponse
{
    string Wuid;
    string QuerySet;
    string QueryName;
    string QueryId;

    string MemoryLimit;
    nonNegativeInteger TimeLimit;
    nonNegativeInteger WarnTimeLimit;
    string Priority;
    string Comment;

    bool ReloadFailed;
    bool Suspended;
    string ErrorMessage;
    ESParray<ESPStruct LogicalFileError, File> FileErrors;
};

ESPenum WUExceptionSeverity : string
{
    INFO("info"),
    WARNING("warning"),
    ERROR("error"),
    ALERT("alert")
};

ESPrequest WURunRequest
{
    string QuerySet;
    string Query;
    string Wuid;
    bool CloneWorkunit;
    string Cluster;
    int Wait(-1);
    [rows(15)] string Input;
    bool NoRootTag(0);
    ESParray<ESPstruct NamedValue> DebugValues;
    ESParray<ESPstruct NamedValue> Variables;
    [min_ver("1.56")] ESParray<ESPstruct ApplicationValue> ApplicationValues;
    ESPenum WUExceptionSeverity ExceptionSeverity("info");
};

ESPresponse [exceptions_inline] WURunResponse
{
    string Wuid;
    string State;
    string Results;
};

ESPrequest WUSubmitRequest
{
    string Wuid;
    string Cluster;
    string Queue;
    string Snapshot;
    int    MaxRunTime;
    [min_ver("1.02")] int BlockTillFinishTimer(0);
    [min_ver("1.19")] bool SyntaxCheck(false);
    bool NotifyCluster(false);
};

ESPresponse [exceptions_inline] WUSubmitResponse
{
};

ESPrequest WUScheduleRequest
{
    string Wuid;
    string Cluster;
    string Queue;
    string Snapshot;
    xsdDateTime When;
    int    MaxRunTime;
};

ESPresponse [exceptions_inline] WUScheduleResponse
{
};

ESPrequest [nil_remove] WUPushEventRequest
{
    string EventName("");
    string EventText("");
};

ESPresponse [exceptions_inline] WUPushEventResponse
{
};

SCMenum WUINFOType
{
    WUGRAPHS,
    WUTIMINGS,
    WUACTIONS,
    WURESULTS
};

ESPrequest WUInfoRequest
{
    string Wuid;
    bool TruncateEclTo64k(true);
    [min_ver("1.01")] string Type;  //archieved or non-archieved
    [min_ver("1.16")] bool IncludeExceptions(true);
    [min_ver("1.16")] bool IncludeGraphs(true);
    [min_ver("1.16")] bool IncludeSourceFiles(true);
    [min_ver("1.16")] bool IncludeResults(true);
    [min_ver("1.34")] bool IncludeResultsViewNames(false);
    [min_ver("1.16")] bool IncludeVariables(true);
    [min_ver("1.16")] bool IncludeTimers(true);
    [min_ver("1.16")] bool IncludeDebugValues(true);
    [min_ver("1.16")] bool IncludeApplicationValues(true);
    [min_ver("1.16")] bool IncludeWorkflows(true);
    [min_ver("1.39")] bool IncludeXmlSchemas(false);
    [min_ver("1.47")] bool IncludeResourceURLs(false);
    [min_ver("1.66")] bool IncludeECL(true);
    [min_ver("1.66")] bool IncludeHelpers(true);
    [min_ver("1.66")] bool IncludeAllowedClusters(true);
    [min_ver("1.73")] bool IncludeTotalClusterTime(true);
    [min_ver("1.16")] bool SuppressResultSchemas(false);
    [min_ver("1.25")] string ThorSlaveIP;
};

ESPresponse [exceptions_inline] WUInfoResponse
{
    ESPstruct ECLWorkunit Workunit;
    int  AutoRefresh(0);
   bool CanCompile;
   [min_ver("1.25")] string ThorSlaveIP;
   [min_ver("1.34")] ESParray<string, View> ResultViews;
   [min_ver("1.54")] string SecMethod;
};

ESPrequest WUResultSummaryRequest
{
    string Wuid;
    int    Sequence;
};

ESPresponse [exceptions_inline] WUResultSummaryResponse
{
    string  Wuid;
    int     Sequence;
    int     Format;
    ESPStruct ECLResult Result;
};

/* html */
ESPrequest WULogFileRequest
{
    string Name;
    string Wuid;
    string Type;
    int Option;
    [min_ver("1.10")] string SlaveIP;
    [min_ver("1.32")] string IPAddress;
    [min_ver("1.32")] string Description;
    [min_ver("1.36")] string QuerySet;
    [min_ver("1.36")] string Query;
    [min_ver("1.38")] string Process;
    [min_ver("1.38")] string ClusterGroup;
    [min_ver("1.38")] string LogDate;
    [min_ver("1.38")] int SlaveNumber(1);
    [min_ver("1.55")] int64 SizeLimit(0);
    [min_ver("1.77")] ESPenum ErrorMessageFormat ErrorMessageFormat;
    string PlainText;
};

ESPresponse [exceptions_inline] WULogFileResponse
{
    [min_ver("1.36")] string Wuid;
    [min_ver("1.36")] string QuerySet;
    [min_ver("1.36")] string QueryName;
    [min_ver("1.36")] string QueryId;
    [min_ver("1.36")] string FileName;
    [min_ver("1.38")] string DaliServer;
    [http_content("application/octet-stream")] binary thefile;
};

ESPrequest WUDownloadFilesRequest
{
    string Wuid;
    string QuerySet;
    string Query;
    ESPenum WUFileDownloadOption DownloadOption;
    ESParray<ESPstruct WUFileOption> WUFileOptions;
};

ESPresponse [exceptions_inline] WUDownloadFilesResponse
{
    [http_content("application/octet-stream")] binary thefile;
};

ESPrequest WUResultBinRequest
{
    string LogicalName;
    string Wuid;
    string ResultName;
    int    Sequence;
    string Format("raw");
    [min_ver("1.73")] string Cluster;
    [min_ver("1.50")] ESParray<ESPstruct NamedValue> FilterBy;

    int64 Start(0);
    int Count;
};

ESPresponse [exceptions_inline] WUResultBinResponse
{
    string Wuid;
    int Sequence;
    string Name;

    int64 Start;
    int Count;
    int Requested;
    int64 Total;
    [http_content("application/octet-stream")] binary Result;

    string Format;

};

ESPrequest WUResultRequest
{
    string Wuid;
    int    Sequence;
    string ResultName;
    string LogicalName;
    string Cluster;
    bool SuppressXmlSchema(0);
    [min_ver("1.60")] bool BypassCachedResult(false);
    [min_ver("1.50")] ESParray<ESPstruct NamedValue> FilterBy;

    int64 Start(0);
    int Count;
};

ESPresponse [exceptions_inline,http_encode(0)] WUResultResponse
{
    string Wuid;
    int    Sequence;
    string LogicalName;
    string Cluster;
    string Name;

    int64 Start;
    int Requested;
    int Count;
    int64 Total;

    [json_inline(1)] string Result;
};

ESPrequest WUFullResultRequest
{
    string Wuid;
    bool NoRootTag(0);
    ESPenum WUExceptionSeverity ExceptionSeverity("info");
};

ESPresponse [exceptions_inline,http_encode(0)] WUFullResultResponse
{
    string Wuid;
    [json_inline(1)] string Results;
};

ESPrequest WUResultViewRequest
{
    string Wuid;
    string ViewName;
    int    Sequence;
    string ResultName;
};

ESPresponse [exceptions_inline] WUResultViewResponse
{
    string Wuid;
    string ViewName;
    [http_content("text/html")] string Result;
};

ESPrequest WUClusterJobQueueXLSRequest
{
    string Cluster;
   string StartDate;
   string EndDate;
    string ShowType;
};

ESPresponse [exceptions_inline] WUClusterJobQueueXLSResponse
{
    [http_content("application/octet-stream")] binary Result;
};

ESPrequest [nil_remove] WUClusterJobQueueLOGRequest
{
    string Cluster;
   string StartDate;
   string EndDate;
};

ESPresponse [exceptions_inline] WUClusterJobQueueLOGResponse
{
    [http_content("text/xml")] binary thefile;
};

ESPrequest WUClusterJobXLSRequest
{
    string Cluster;
    string StartDate;
    string EndDate;
    bool ShowAll;
    string BusinessStartTime;
    string BusinessEndTime;
};

ESPresponse [exceptions_inline] WUClusterJobXLSResponse
{
    [http_content("application/octet-stream")] binary Result;
};


ESPrequest WUClusterJobSummaryXLSRequest
{
    string Cluster;
    string StartDate;
    string EndDate;
    bool ShowAll;
    string BusinessStartTime;
    string BusinessEndTime;
};

ESPresponse [exceptions_inline] WUClusterJobSummaryXLSResponse
{
    [http_content("application/octet-stream")] binary Result;
};

ESPrequest [nil_remove] WUGetThorJobQueueRequest
{
    string Cluster;
    string StartDate;
    string EndDate;
    unsigned MaxJobQueueItemsToReturn(0);
};

ESPresponse [exceptions_inline] WUGetThorJobQueueResponse
{
    int LongestQueue;
    int MaxThorConnected;
    ESParray<ESPstruct ThorQueue> QueueList;
    string Warning;
};

ESPrequest [nil_remove] WUGetThorJobListRequest
{
    string Cluster;
    string StartDate;
    string EndDate;
    unsigned MaxJobsToReturn(0);
};

ESPresponse [exceptions_inline] WUGetThorJobListResponse
{
    ESParray<ESPstruct ECLJob> JobList;
    ESParray<ESPstruct ECLJob> InProgressJobList;
    string Warning;
};

ESPrequest GVCAjaxGraphRequest
{
    string Name;
    string GraphName;
   [min_ver("1.20")] int SubGraphId;
   [min_ver("1.21")] bool SubGraphOnly;
};

ESPresponse GVCAjaxGraphResponse
{
    string Name;
    string GraphName;
    string GraphType;
   [min_ver("1.20")] int SubGraphId;
   [min_ver("1.21")] bool SubGraphOnly;
};

ESPrequest [nil_remove] WUGraphInfoRequest
{
    string Wuid;
    string Name;
    [min_ver("1.02")] string GID;
   [min_ver("1.15")] int BatchWU;
};
ESPresponse [exceptions_inline] WUGraphInfoResponse
{
    string Wuid;
    string Name;
    [min_ver("1.02")] string GID;
   [min_ver("1.15")] int BatchWU;
    bool Running;
};

ESPrequest [nil_remove] WUGVCGraphInfoRequest
{
    string Wuid;
    string Name;
    string GID;
   [min_ver("1.15")] int BatchWU;
   [min_ver("1.18")] int SubgraphId;
};
ESPresponse [exceptions_inline, http_encode(0)] WUGVCGraphInfoResponse
{
    string Wuid;
    string Name;
    string GID;
    bool Running;
    string TheGraph;
   [min_ver("1.15")] int BatchWU;
};


ESPrequest WUGraphTimingRequest
{
    string Wuid;
};

ESPresponse [exceptions_inline] WUGraphTimingResponse
{
    ESPstruct ECLWorkunit Workunit;
};

ESPrequest WUGetGraphNameAndTypesRequest
{
    string Wuid;
    string Type;
};

ESPresponse [encode(0), exceptions_inline] WUGetGraphNameAndTypesResponse
{
    ESParray<ESPstruct NameAndType, GraphNameAndType> GraphNameAndTypes;
};

ESPrequest WUProcessGraphRequest
{
    string Wuid;
    string Name;
};

ESPresponse [encode(0), exceptions_inline] WUProcessGraphResponse
{
    string theGraph;
};

ESPrequest WUGetGraphRequest
{
    string Wuid;
    [min_ver("1.19")] string GraphName;
    [min_version("1.21")] string SubGraphId;
};

ESPresponse [exceptions_inline] WUGetGraphResponse
{
    ESParray<ESPstruct ECLGraphEx> Graphs;
};

ESPrequest WUQueryGetGraphRequest
{
    string Target;
    string QueryId;
    [min_ver("1.19")] string GraphName;
    [min_version("1.21")] string SubGraphId;
};

ESPresponse [exceptions_inline] WUQueryGetGraphResponse
{
    ESParray<ESPstruct ECLGraphEx> Graphs;
};

ESPrequest WUQueryGetSummaryStatsRequest
{
    string Target;
    string QueryId;
    string FromTime; //YYYY-MM-DDTHH:MM:SS
    string ToTime;
    [min_ver("1.75")] bool IncludeRawStats(false);
};

ESPresponse [exceptions_inline] WUQueryGetSummaryStatsResponse
{
    ESParray<ESPstruct QuerySummaryStats> StatsList;
    [min_ver("1.75")] ESParray<ESPstruct EndpointQueryStats> QueryStatsList;
};

ESPrequest WUExportRequest
{
    string Cluster;
    string Owner;
    string State;
    string StartDate;
    string EndDate;
    [max_ver("1.57")] string ECL;
    string Jobname;
};
ESPresponse [exceptions_inline] WUExportResponse
{
    [http_content("text/xml")] binary ExportData;
};


ESPrequest WUWaitRequest
{
    string Wuid;
    int Wait(-1);
    bool ReturnOnWait(false);
};

ESPresponse [exceptions_inline] WUWaitResponse
{
    int StateID;
};


ESPrequest WUSyntaxCheckRequest
{
    string ECL;
    string ModuleName;
    string AttributeName;
    string Queue;
    string Cluster;
    string Snapshot;
    int    TimeToWait(60000);

    [min_ver("1.04")] ESParray<ESPstruct DebugValue>       DebugValues;
};

ESPresponse [exceptions_inline] WUSyntaxCheckResponse
{
    ESParray<ESPstruct ECLException> Errors;
    [min_ver("1.57")] string Message;
};


ESPrequest WUCompileECLRequest
{
    string ECL;
    string ModuleName;
    string AttributeName;
    string Queue;
    string Cluster;
    string Snapshot;

    bool IncludeDependencies(false);
    bool IncludeComplexity;
    int  TimeToWait(60000);
};

ESPresponse [exceptions_inline] WUCompileECLResponse
{
    string Complexity;
    ESParray<ESPstruct ECLException> Errors;
    ESParray<ESPstruct WUECLAttribute, ECLAttribute> Dependencies;
};


ESPrequest WUJobListRequest
{
    string Cluster;
    [min_ver("1.50")] string Process;
    string StartDate;
    string EndDate;
    bool ShowAll;
    int BusinessStartHour;
    int BusinessEndHour;
};

ESPresponse [exceptions_inline] WUJobListResponse
{
    string StartDate;
    string EndDate;
    ESParray<ESPstruct ECLJob> Jobs;
};

ESPrequest [nil_remove] WUShowScheduledRequest
{
    string Cluster("");
    string EventName("");
    string PushEventName("");
    string PushEventText("");
    [min_ver("1.51")] string State("");
    [min_ver("1.71")] string JobName("");
    [min_ver("1.77")] string Owner("");
    [min_ver("1.77")] string EventText("");
};

ESPStruct [nil_remove] ScheduledWU
{
    string Wuid;
    string Cluster("");
    string EventName("");
    string EventText("");
    string JobName("");
    [min_ver("1.51")] int StateID;
    [min_ver("1.51")] string State("");
    [min_ver("1.51")] string Owner("");
};

ESPStruct [nil_remove] ServerInfo
{
    string Name("");
    string NetAddress("");
};

ESPresponse [nil_remove, exceptions_inline] WUShowScheduledResponse
{
    int ClusterSelected(0);
    string EventName("");
    string PushEventName("");
    string PushEventText("");
    string Query("");
    ESParray<ESPstruct ServerInfo> Clusters;
    ESParray<ESPstruct ScheduledWU> Workunits;
};

ESPrequest WUGetDependancyTreesRequest
{
    string Cluster;
    string Queue;
    string Snapshot;
    string Items;
    [min_ver("1.12")] string TimeoutMilliSec;
};

ESPresponse [nil_remove, exceptions_inline] WUGetDependancyTreesResponse
{
    ESParray<ESPstruct ECLException> Errors;
    [http_content("text/xml")] binary DependancyTrees;
};

ESPrequest WUListLocalFileRequiredRequest
{
    string Wuid;
};

ESPresponse [nil_remove, exceptions_inline] WUListLocalFileRequiredResponse
{
    ESParray<ESPstruct LogicalFileUpload> LocalFileUploads;
};

ESPrequest WUAddLocalFileToWorkunitRequest
{
    string Wuid;
    string Name;

    string Val;
    string DefVal;
    int Type;
    int Length;
};

ESPresponse [nil_remove, exceptions_inline] WUAddLocalFileToWorkunitResponse
{
    string Wuid;
    string Name;
    string Result;
};

ESPrequest WUDebugRequest
{
    string Wuid;
    string Command;
};

ESPresponse [exceptions_inline] WUDebugResponse
{
    string Result;
};

ESPrequest WUCopyLogicalFilesRequest
{
    string Wuid;
    string Cluster;
    bool CopyLocal;
};

ESPStruct WULogicalFileCopyInfo
{
    bool IsIndex;
    string LogicalName;
    string DfuCopyWuid;
    string DfuCopyError;
    ESParray<string> Clusters;
};

ESPStruct WUCopyLogicalClusterFileSections
{
    string ClusterName;
    ESParray<ESPstruct WULogicalFileCopyInfo> OnCluster;
    ESParray<ESPstruct WULogicalFileCopyInfo> NotOnCluster;
    ESParray<ESPstruct WULogicalFileCopyInfo> Foreign;
    ESParray<ESPstruct WULogicalFileCopyInfo> NotFound;
};

ESPresponse [exceptions_inline] WUCopyLogicalFilesResponse
{
    string Wuid;
    ESParray<ESPStruct WUCopyLogicalClusterFileSections, Cluster> ClusterFiles;
};


ESPrequest [nil_remove] WUPublishWorkunitRequest
{
    string Wuid;
    string Cluster;
    string JobName;
    int Activate;
    bool NotifyCluster(false);
    int Wait(10000);
    bool NoReload(0);
    bool UpdateWorkUnitName(0);
    string memoryLimit;
    nonNegativeInteger TimeLimit(0);
    nonNegativeInteger WarnTimeLimit(0);
    string Priority;
    string RemoteDali;
    string Comment;
    bool DontCopyFiles(false);
    string SourceProcess;
    bool AllowForeignFiles(false);
    bool UpdateDfs(false);
    bool UpdateSuperFiles(false); //update content of superfiles if changed
    bool UpdateCloneFrom(false); //explicity wan't to change where roxie will grab from
    bool AppendCluster(true); //file exists on other local cluster, add new one, make optional in case of locking issues, but should be made to work
    bool IncludeFileErrors(false);
};

ESPresponse [exceptions_inline] WUPublishWorkunitResponse
{
    string Wuid;
    string Result;
    string QuerySet;
    string QueryName;
    string QueryId;
    bool ReloadFailed;
    [min_ver("1.39")] bool Suspended;
    [min_ver("1.39")] string ErrorMessage;
    ESParray<ESPStruct WUCopyLogicalClusterFileSections, Cluster> ClusterFiles;
    [min_ver("1.68")] ESParray<ESPStruct LogicalFileError, File> FileErrors;
};

ESPrequest [nil_remove] WUQueryConfigRequest
{
    string Target;
    string QueryId;
    int Wait(10000);
    bool NoReload(0);
    string memoryLimit;
    nonNegativeInteger TimeLimit(0);
    nonNegativeInteger WarnTimeLimit(0);
    string Priority;
    string Comment;
};

ESPStruct WUQueryConfigResult
{
    string  QueryId;
};

ESPresponse [exceptions_inline] WUQueryConfigResponse
{
    bool ReloadFailed;
    ESParray<ESPStruct WUQueryConfigResult, Result> Results;
};


ESPStruct QuerySet
{
    string  QuerySetName;
};

ESPrequest WUQuerysetsRequest
{
    bool test;
};

ESPresponse [exceptions_inline] WUQuerysetsResponse
{
    ESParray<ESPstruct QuerySet> Querysets;
};

ESPStruct ClusterQueryState
{
    string Cluster;
    string State;
    [min_ver("1.46")] string Errors;
    [min_ver("1.47")] bool MixedNodeStates;
};

ESPStruct [nil_remove] QuerySetQuery
{
    string Id;
    string Name;
    string Wuid;
    string Dll;
    bool Suspended;
    ESParray<ESPstruct ClusterQueryState> Clusters;
    string memoryLimit;
    nonNegativeInteger timeLimit;
    nonNegativeInteger warnTimeLimit;
    string priority;
    string Comment;
    [min_ver("1.45")] string QuerySetId;
    [min_ver("1.46")] bool IsLibrary;
    [min_ver("1.46")] bool Activated;
    [min_ver("1.46")] string PublishedBy;
    [min_ver("1.48")] string snapshot;
};

ESPStruct QuerySetAlias
{
    string Id;
    string Name;
};

ESPenum WUQuerySetFilterType : string
{
    ALL("All"),
    ID("Id"),
    NAME("Name"),
    ALIAS("Alias"),
    STATUS("Status")
};

ESPrequest WUQuerySetDetailsRequest
{
    string  QuerySetName;
    string  Filter;
    string  ClusterName;
    ESPenum WUQuerySetFilterType FilterType("All");
    [min_ver("1.57")] bool CheckAllNodes(true);
};

ESPresponse [exceptions_inline] WUQuerySetDetailsResponse
{
    string  QuerySetName;
    ESParray<ESPstruct QuerySetQuery> QuerysetQueries;
    ESParray<ESPstruct QuerySetAlias> QuerysetAliases;
    [min_ver("1.37")] string  ClusterName;
    [min_ver("1.37")] string  Filter;
    [min_ver("1.37")] ESPenum WUQuerySetFilterType FilterType;
    [min_ver("1.37")] ESParray<string> ClusterNames;
};

ESPrequest [nil_remove] WUListQueriesRequest
{
    string  QuerySetName;
    string  ClusterName;
    string  LibraryName;
    int64 MemoryLimitLow;
    int64 MemoryLimitHigh;
    nonNegativeInteger TimeLimitLow;
    nonNegativeInteger TimeLimitHigh;
    nonNegativeInteger WarnTimeLimitLow;
    nonNegativeInteger WarnTimeLimitHigh;
    nonNegativeInteger PriorityLow;
    nonNegativeInteger PriorityHigh;
    [min_ver("1.48")] bool Activated;
    [min_ver("1.48")] bool SuspendedByUser;
    [min_ver("1.50")] string WUID;
    [min_ver("1.51")] string QueryID;
    [min_ver("1.51")] string QueryName;
    [min_ver("1.56")] string PublishedBy;

    nonNegativeInteger PageSize(0);
    nonNegativeInteger PageStartFrom(0);
    string Sortby;
    bool Descending(false);
    int64 CacheHint;
    string FileName;
    [min_ver("1.57")] bool CheckAllNodes(true);
};

ESPresponse [exceptions_inline] WUListQueriesResponse
{
    int   NumberOfQueries;
    int64 CacheHint;
    ESParray<ESPstruct QuerySetQuery> QuerysetQueries;
};

ESPrequest [nil_remove] WUListQueriesUsingFileRequest
{
    string Target;
    string Process;
    string FileName;
};

ESPStruct [nil_remove] QueryUsingFile
{
    string Id;
    string Package;
};

ESPStruct [nil_remove] TargetQueriesUsingFile
{
    string Target;
    string PackageMap;
    ESParray<ESPstruct QueryUsingFile> Queries;
};


ESPresponse [exceptions_inline] WUListQueriesUsingFileResponse
{
    string Process;
    string FileName;
    ESParray<ESPstruct TargetQueriesUsingFile> Targets;
};

ESPrequest [nil_remove] WUQueryFilesRequest
{
    string Target;
    string QueryId;
};

ESPStruct [nil_remove] FileUsedByQuery
{
    string FileName;
    int64 FileSize;
    unsigned NumberOfParts;
};

ESPresponse [exceptions_inline] WUQueryFilesResponse
{
    ESParray<ESPstruct FileUsedByQuery, File> Files;
};

ESPrequest WUQueryDetailsRequest
{
    string QueryId;
    string QuerySet;
    bool IncludeStateOnClusters(false);
    bool IncludeSuperFiles(false);
    bool IncludeWsEclAddresses(false);
    [min_ver("1.57")] bool CheckAllNodes(true);
};

ESPStruct QuerySuperFile
{
    string Name;
    ESParray<string, File> SubFiles;
    [min_ver("1.57")] ESParray<ESPstruct QuerySuperFile, SuperFile> SuperFiles;
};

ESPresponse [exceptions_inline] WUQueryDetailsResponse
{
    string QueryId;
    string QuerySet;
    string QueryName;
    string Wuid;
    string Dll;
    bool Suspended;
    [min_ver("1.42")] bool Activated;
    string SuspendedBy;
    [min_ver("1.43")] ESParray<ESPstruct ClusterQueryState> Clusters;
    string PublishedBy;
    string Comment;

    ESParray<string> LogicalFiles;
    [min_ver("1.44")] ESParray<ESPstruct QuerySuperFile, SuperFile> SuperFiles;
    [min_ver("1.46")] bool IsLibrary;
    [min_ver("1.46")] string Priority;
    [min_ver("1.46")] string WUSnapShot; //Label
    [min_ver("1.46")] string CompileTime;
    [min_ver("1.46")] ESParray<string> LibrariesUsed;
    [min_ver("1.46")] int CountGraphs;
    [min_ver("1.46"), depr_ver("1.64")] ESParray<string> GraphIds;
    [min_ver("1.50")] int ResourceURLCount;
    [min_ver("1.51")] ESParray<string, Address> WsEclAddresses;
    [min_ver("1.64")] ESParray<ESPstruct ECLGraph> WUGraphs;
    [min_ver("1.64")] ESParray<ESPstruct ECLTimer> WUTimers;
};

ESPrequest WUMultiQuerySetDetailsRequest
{
    string  ClusterName;
    string  QuerySetName;
    string  Filter;
    ESPenum WUQuerySetFilterType FilterType("All");
    [min_ver("1.57")] bool CheckAllNodes(true);
};

ESPstruct WUQuerySetDetail
{
    string  QuerySetName;
    ESParray<ESPstruct QuerySetQuery> Queries;
    ESParray<ESPstruct QuerySetAlias> Aliases;
};


ESPresponse [exceptions_inline] WUMultiQuerySetDetailsResponse
{
    string ClusterName;
    ESParray<ESPstruct WUQuerySetDetail> Querysets;
};

ESPrequest WUQuerysetExportRequest
{
    string  Target;
    bool Compress(true);
    bool ActiveOnly(false);
    bool Protect(false);
};

ESPresponse [exceptions_inline] WUQuerysetExportResponse
{
    string Target;
    bool Compressed;
    binary Data;
};

ESPenum QuerysetImportActivation : string
{
    None("None"),
    ImportedActive("ActivateImportedActive")
};


ESPrequest WUQuerysetImportRequest
{
    string Target;
    string QueryMask;
    bool Replace(false);
    bool ActiveOnly(false);
    ESPenum QuerysetImportActivation Activation;
    bool Compressed(true);
    binary Data;

    bool AllowForeignFiles(true);

    string DfsServer;
    bool CopyFiles(true);
    bool OverwriteDfs(false);
    string SourceProcess;
    bool UpdateSuperFiles(false); //usually wouldn't be needed, packagemap referencing superfiles?
    bool UpdateCloneFrom(false); //explicity wan't to change where roxie will grab from
    bool AppendCluster(true); //file exists on other local cluster, add new one, make optional in case of locking issues, but should be made to work
    bool IncludeFileErrors(false);
};

ESPresponse [exceptions_inline] WUQuerysetImportResponse
{
    string  Target;
    bool ClearedExisting(true);
    bool Success(false);

    ESParray<string, QueryId> ImportedQueries;
    ESParray<string, QueryId> ExistingQueries;
    ESParray<string, QueryId> MissingWuids;
    ESParray<ESPStruct LogicalFileError, File> FileErrors;
};

ESPrequest [nil_remove] WUUpdateQueryEntryRequest
{
    string QuerySet;
    string QueryId;
    string Comment;
};

ESPresponse [exceptions_inline] WUUpdateQueryEntryResponse
{
};

ESPenum QuerySetQueryActionTypes : string
{
    Suspend("Suspend"),
    Unsuspend("Unsuspend"),
    ToggleSuspend("ToggleSuspend"),
    Activate("Activate"),
    Delete("Delete"),
    RemoveAllAliases("RemoveAllAliases"),
    ResetQueryStats("ResetQueryStats")
};

ESPStruct QuerySetQueryClientState
{
    string Suspended;
};

ESPStruct QuerySetQueryActionItem
{
    string QueryId;
    ESPstruct QuerySetQueryClientState ClientState;
};

ESPrequest WUQuerySetQueryActionRequest
{
    ESPenum QuerySetQueryActionTypes Action;
    string QuerySetName;
    ESParray<ESPstruct QuerySetQueryActionItem, Query> Queries;
};

ESPStruct QuerySetQueryActionResult
{
    string QueryId;
    bool Suspended;
    bool Success;
    int Code;
    string Message;
};

ESPresponse [exceptions_inline] WUQuerySetQueryActionResponse
{
    ESPenum QuerySetQueryActionTypes Action;
    string QuerySetName;
    ESParray<ESPstruct QuerySetQueryActionResult, Result> Results;
};

ESPenum QuerySetAliasActionTypes : string
{
    Deactivate("Deactivate")
};

ESPStruct QuerySetAliasActionItem
{
    string Name;
};

ESPrequest WUQuerySetAliasActionRequest
{
    ESPenum QuerySetAliasActionTypes Action;
    string QuerySetName;
    ESParray<ESPstruct QuerySetAliasActionItem, Alias> Aliases;
};

ESPStruct QuerySetAliasActionResult
{
    string Name;
    bool Success;
    int Code;
    string Message;
};

ESPresponse [exceptions_inline] WUQuerySetAliasActionResponse
{
    ESPenum QuerySetAliasActionTypes Action;
    string QuerySetName;
    ESParray<ESPstruct QuerySetAliasActionResult, Result> Results;
};

ESPrequest [nil_remove] WUQuerySetCopyQueryRequest
{
    string Source;
    string Target;
    string Cluster;
    string DaliServer;
    int Activate;
    bool Overwrite(false);
    bool DontCopyFiles(false);
    int Wait(10000);
    bool NoReload(0);
    string memoryLimit;
    nonNegativeInteger TimeLimit(0);
    nonNegativeInteger WarnTimeLimit(0);
    string priority;
    string Comment;
    string SourceProcess;
    string DestName;
    bool AllowForeignFiles(true);
    bool UpdateSuperFiles(false); //usually wouldn't be needed, packagemap referencing superfiles?
    bool UpdateCloneFrom(false); //explicity wan't to change where roxie will grab from
    bool AppendCluster(true); //file exists on other local cluster, add new one, make optional in case of locking issues, but should be made to work
    bool IncludeFileErrors(false);
};

ESPresponse [exceptions_inline] WUQuerySetCopyQueryResponse
{
    string QueryId;
    [min_ver("1.68")] ESParray<ESPStruct LogicalFileError, File> FileErrors;
};

ESPrequest [nil_remove] WUCopyQuerySetRequest
{
    string Source;
    string Target;
    bool ActiveOnly(true);
    bool CloneActiveState(true);
    bool AllowForeignFiles(true);

    string DfsServer;
    bool CopyFiles(true);
    bool OverwriteDfs(false);
    string SourceProcess;
    bool UpdateSuperFiles(false); //usually wouldn't be needed, packagemap referencing superfiles?
    bool UpdateCloneFrom(false); //explicity wan't to change where roxie will grab from
    bool AppendCluster(true); //file exists on other local cluster, add new one, make optional in case of locking issues, but should be made to work
    bool IncludeFileErrors(false);
};

ESPresponse [exceptions_inline] WUCopyQuerySetResponse
{
    ESParray<string, QueryId> CopiedQueries;
    ESParray<string, QueryId> ExistingQueries;
    [min_ver("1.68")] ESParray<ESPStruct LogicalFileError, File> FileErrors;
};

ESPrequest [nil_remove] WUGetZAPInfoRequest
{
    string WUID;
};

ESPresponse [exceptions_inline] WUGetZAPInfoResponse
{
    string WUID;
    string ESPIPAddress;
    string ThorIPAddress;
    string BuildVersion;
    string Archive;
    [min_ver("1.73")] string EmailTo;
    [min_ver("1.73")] string EmailFrom;
};

ESPrequest [nil_remove] WUCreateZAPInfoRequest
{
    string Wuid;
    string ESPIPAddress;
    string ThorIPAddress;
    string BuildVersion;
    string ProblemDescription;
    string WhatChanged;
    string WhereSlow;
    [min_ver("1.53"), depr_ver("1.70")] string Password;
    [min_ver("1.65")] string ZAPFileName;
    [min_ver("1.57")] string IncludeThorSlaveLog("on");
    [min_ver("1.70")] string ZAPPassword;
    [min_ver("1.73")] bool SendEmail(false);
    [min_ver("1.73")] bool AttachZAPReportToEmail(false);
    [min_ver("1.73")] string EmailFrom;
    [min_ver("1.73")] string EmailSubject;
    [min_ver("1.73")] string EmailBody;
};

ESPresponse [exceptions_inline] WUCreateZAPInfoResponse
{
    [http_content("application/octet-stream")] binary thefile;
    [min_ver("1.70")] string ZAPFileName;
};

ESPrequest [nil_remove] WUCheckFeaturesRequest
{
};

ESPStruct DeploymentFeatures
{
    bool UseCompression;
};

ESPresponse [exceptions_inline] WUCheckFeaturesResponse
{
    int BuildVersionMajor;
    int BuildVersionMinor;
    int BuildVersionPoint;
    unsigned maxRequestEntityLength;
    ESPStruct DeploymentFeatures Deployment;
};

ESPStruct [nil_remove] WUStatisticItem
{
    string Creator;
    string CreatorType;
    string Scope;
    string ScopeType;
    string Description;
    string TimeStamp;
    string Measure;
    string Kind;
    string Value;
    int64 RawValue;
    int64 Count;
    int64 Max;
    [min_ver("1.62")] string Wuid;
};

ESPrequest [nil_remove] WUGetStatsRequest
{
    string WUID;
    string CreatorType;
    string Creator;
    string ScopeType;
    string Scope;
    string Kind;
    string Measure;
    unsigned MinScopeDepth;
    unsigned MaxScopeDepth;
    boolean IncludeGraphs;
    boolean CreateDescriptions;
    [min_ver("1.62")] int64 MinValue; // Should be uint64 but esdl does not support it.
    [min_ver("1.62")] int64 MaxValue;
    [min_ver("1.62")] string Filter; // arbitrary text filter
    //MORE: Some indication of which fields need to be returned - to reduce the amount of data returned.  Is there a general esp mechanism?
};

ESPresponse [exceptions_inline] WUGetStatsResponse
{
    string WUID;
    ESParray<ESPstruct WUStatisticItem> Statistics;
};

ESPStruct [nil_remove] WUArchiveFile
{
    string Name;
    string Key;
    string SourcePath;
    string Path;        //nested (parent) module names for this <Attribute>
};

ESPStruct [nil_remove] WUArchiveModule
{
    string Name;
    string FullName;
    unsigned Flags;
    string Key;
    string Plugin;
    string SourcePath;
    string Version;
    string Path;        //nested (parent) module names for this <Module>
    ESParray<ESPstruct WUArchiveModule, ArchiveModule> ArchiveModules;
    ESParray<ESPstruct WUArchiveFile, File> Files;
};

ESPrequest [nil_remove] WUListArchiveFilesRequest
{
    string WUID;
};

ESPresponse [exceptions_inline, nil_remove] WUListArchiveFilesResponse
{
    ESParray<ESPstruct WUArchiveModule, ArchiveModule> ArchiveModules;
    ESParray<ESPstruct WUArchiveFile, File> Files;
    string Message;
};

ESPrequest [nil_remove] WUGetArchiveFileRequest
{
    string WUID;
    string ModuleName; //<Module @name> or
    string FileName;   //<Attribute @name>
    string Path;       //(nested) parent module name(s) for the <Module @name> or <Attribute @name>
};

ESPresponse [exceptions_inline, nil_remove] WUGetArchiveFileResponse
{
    string File;    //ECL text
    string Message;
};

ESPrequest [nil_remove] WUGetNumFileToCopyRequest
{
    string ClusterName;
    [min_ver("1.69")] int64 PageSize(0);
    [min_ver("1.69")] int64 PageStartFrom(0);
    [min_ver("1.69")] string Sortby;
    [min_ver("1.69")] bool Descending(false);
    [min_ver("1.69")] int64 CacheHint;

};

ESPresponse [exceptions_inline, nil_remove] WUGetNumFileToCopyResponse
{
    ESParray<ESPstruct ClusterEndpoint, Endpoint> Endpoints;
    [min_ver("1.69")] int64 CacheHint;
    [min_ver("1.69")] int64 Total;
};

// ----------------------------------------------------------------------------------
// WUDetails service
//
// Request related structures
ESPstruct WUPropertyFilter
{
    string Name;                                // Attribute Name to match
                                                // Match attribute's RawValue
    [optional] string ExactValue;
    [optional] string MinValue;
    [optional] string MaxValue;
};

// Filters that indicates which nodes are explicitly matched
// Scopes can be used at the same time as Ids.
// ScopeTypes cannot be used at the same time as Scopes or Ids.
// PropertyFilters (attributes or statistics) is applied to all matches
ESPStruct WUScopeFilter
{
    [optional] integer MaxDepth(9999);          // Maximum depth to return matches from (omitted means no limit)
    [optional] ESParray<string, Scope> Scopes;  // Fully qualified scope (See definition of "Scope" in workunit.hpp)
    [optional] ESParray<string, id> Ids;        // Return scope with given node id
    [optional] ESParray<string, ScopeType> ScopeTypes;   // Return scope of a given type
    [optional] ESParray<ESPstruct WUPropertyFilter, PropertyFilter> PropertyFilters;
};

// This provides the filter which indicates which nodes are implicitly matched
// Once a match is found, all nested scopes to a depth of depth are implicitly matched, provided they match the nested filter
ESPStruct WUNestedFilter
{
    [optional] unsigned Depth(9999);            // How many nodes deep relative to matched scope id(s)
                                                // 0 - implies return only the given scope id
                                                // 1 - return only the immediate child of the given scope
                                                // n - return children to 'n' level deep
    [optional] ESParray<string, ScopeType> ScopeTypes;   // Return scope of a given type
};

// Additional properties that are returned for a scopeType
ESPStruct WUExtraProperties
{
    string scopeType;                   // A type of scope e.g., activity/edge
    [optional] ESParray<string, Property> Properties; // a list of properties to return, omitted means none
};

// If measure and attributes are omitted then all matches are returned
// Measure and Attributes/ScopeAttributes are mutually exclusive.
// Measure set to blank or Attributes set to empty will prevent any attributes being returned.
ESPStruct WUPropertiesToReturn
{
    bool AllStatistics(false);
    bool AllAttributes(false);
    bool AllHints(false);
    bool AllScopes(false);
    bool AllProperties(false);
    [min_ver("1.76")] bool AllNotes(false);
    [optional] uint64 MinVersion;       // Only return properties where the version is later than this version.
    [optional] string Measure;          // E.g. Time, Num, Size
    [optional] ESParray<string, Property> Properties; // a list of properties to return
    [optional] ESParray<ESPstruct WUExtraProperties, Extra> ExtraProperties;
};

ESPStruct WUScopeOptions
{
    bool IncludeMatchedScopesInResults(true);
    bool IncludeScope(true);
    bool IncludeId(false);
    bool IncludeScopeType(false);
};

// Controls which information is returned for the statistics
ESPStruct WUPropertyOptions
{
    bool IncludeName(true);
    bool IncludeRawValue(false);
    bool IncludeFormatted(true);
    bool IncludeMeasure(true);
    bool IncludeCreator(false);
    bool IncludeCreatorType(false);
};

ESPRequest WUDetailsRequest
{
    string WUID;
    [optional] ESPstruct WUScopeFilter ScopeFilter;               // which scopes are matched
    [optional] ESPstruct WUNestedFilter NestedFilter;             // what nested scopes are returned
    [optional] ESPstruct WUPropertiesToReturn PropertiesToReturn; // List of properties to return
    [optional] string    Filter;                                  // Filter as a string text
    [optional] ESPstruct WUScopeOptions ScopeOptions;             // Which scope details are returned
    [optional] ESPstruct WUPropertyOptions PropertyOptions;       // Which attribute details are returned
};

// ----------------------------------------------------------------------------------
// Response related structures
ESPstruct [nil_remove] WUResponseProperty
{
    [optional] string Name;         // Name of attribute
    [optional] string RawValue;     // Value of attribute
    [optional] string Formatted;    // Formatted value of attribute
    [optional] string Measure;      // What type is this attribute
    [optional] string Creator;      // Which engine created it
    [optional] string CreatorType;  // What type of engine created it.
};

ESPstruct [nil_remove] WUResponseNote
{
    [optional] string Source;       // Thor, Eclcc, Analyser etc
    [optional] string Message;
    [optional] nonNegativeInteger ErrorCode;
    [optional] string Severity;
    [optional] nonNegativeInteger Cost;
};

ESPstruct [nil_remove] WUResponseScope
{
    [optional] string ScopeName;        // Fully qualified scope (See definition of "Scope" in workunit.hpp)
    [optional] string Id;               // Node/Graph id
    [optional] string ScopeType;        // e.g. Activity, Edge
    [optional] ESParray<ESPstruct WUResponseProperty, Property> Properties;
    [optional, min_ver("1.76")] ESParray<ESPstruct WUResponseNote, Note> Notes;
};


ESPResponse [exceptions_inline] WUDetailsResponse
{
    uint64 MaxVersion;                              // largest version for any matches
    string WUID;                                    // all    [optional] ESParray<string, Attribute> Attributes; // a list of attributes to returnows wildcarded requests to be interpreted.
    ESParray<ESPstruct WUResponseScope, Scope> Scopes;
};

// ----------------------------------------------------------------------------------
ESPenum WUDetailsAttrValueType : string
{
    Single("Single"),
    List("List"),
    Multi("Multi"),
};

ESPStruct WUDetailsMetaProperty
{
    string Name;
    ESPenum WUDetailsAttrValueType ValueType;
};

ESPStruct WUDetailsActivityInfo
{
    unsigned Kind;
    string Name;
    boolean IsSink;
    boolean IsSource;
};

ESPRequest WUDetailsMetaRequest
{
};

ESPResponse [exceptions_inline] WUDetailsMetaResponse
{
    ESParray<ESPStruct WUDetailsMetaProperty, Property> Properties;
    ESParray<string, ScopeType> ScopeTypes;
    ESParray<string, Measure> Measures;
    ESParray<ESPStruct WUDetailsActivityInfo, Activity> Activities;
};

ESPStruct [nil_remove] WUEclDefinitionActionResult
{
    string EclDefinition;
    string Action;
    string WUID;
    string QueryID;
    string Result;
};

ESPrequest [nil_remove] WUEclDefinitionActionRequest
{
    ESParray<string> EclDefinitions;
    ESPenum EclDefinitionActions ActionType;
    string Target;

    string RemoteDali; //Publish
    string SourceProcess; //Publish
    string Priority; //Publish
    string Comment; //Publish
    string MemoryLimit; //Publish - 123M
    bool DeletePrevious(false); //Publish
    bool SuspendPrevious(false); //Publish
    bool NoActivate(false); //Publish
    bool NoReload(false); //Publish
    bool DontCopyFiles(false); //Publish
    bool AllowForeign(false); //Publish
    bool UpdateDfs(false); //Publish
    bool UpdateSuperfiles(false); //Publish
    bool UpdateCloneFrom(false); //Publish
    bool DontAppendCluster(false); //Publish
    int MsToWait(-1);
    int TimeLimit(-1); //Publish
    int WarnTimeLimit(-1); //Publish
};

ESPresponse [exceptions_inline] WUEclDefinitionActionResponse
{
    ESParray<ESPstruct WUEclDefinitionActionResult> ActionResults;
};

// ----------------------------------------------------------------------------------
ESPservice [
    auth_feature("DEFERRED"), //This declares that the method logic handles feature level authorization
    version("1.77"), default_client_version("1.77"), cache_group("ESPWsWUs"),
    noforms,exceptions_inline("./smc_xslt/exceptions.xslt"),use_method_name] WsWorkunits
{
    ESPmethod [cache_seconds(60), resp_xsl_default("/esp/xslt/workunits.xslt")]     WUQuery(WUQueryRequest, WUQueryResponse);
    ESPmethod [cache_seconds(60), min_ver("1.57")] WULightWeightQuery(WULightWeightQueryRequest, WULightWeightQueryResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/wuid.xslt")]     WUInfo(WUInfoRequest, WUInfoResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/wuiddetails.xslt")]     WUInfoDetails(WUInfoRequest, WUInfoResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/wuid.xslt")]     WUGraphTiming(WUGraphTimingRequest, WUGraphTimingResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/graph.xslt")]         WUGraphInfo(WUGraphInfoRequest, WUGraphInfoResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/graph_gvc.xslt")]     WUGVCGraphInfo(WUGVCGraphInfoRequest, WUGVCGraphInfoResponse);
    ESPmethod [description("Stub for Ajax GVC Graph."), help(""), resp_xsl_default("/esp/xslt/GvcGraph.xslt")] GVCAjaxGraph(GVCAjaxGraphRequest, GVCAjaxGraphResponse);
    ESPmethod [cache_seconds(30), resp_xsl_default("/esp/xslt/result.xslt")]        WUResult(WUResultRequest, WUResultResponse);
    ESPmethod WUFullResult(WUFullResultRequest, WUFullResultResponse);
    ESPmethod [cache_seconds(30)] WUResultView(WUResultViewRequest, WUResultViewResponse);
    ESPmethod [cache_seconds(60), resp_xsl_default("/esp/xslt/wuid_jobs.xslt")]     WUJobList(WUJobListRequest, WUJobListResponse);
    ESPmethod [clear_cache_group, resp_xsl_default("/esp/xslt/wuaction_results.xslt")] WUAction(WUActionRequest, WUActionResponse);
    ESPmethod [cache_seconds(60), resp_xsl_default("/esp/xslt/scheduledwus.xslt")] WUShowScheduled(WUShowScheduledRequest, WUShowScheduledResponse);

    ESPmethod [cache_seconds(30)] WUResultSummary(WUResultSummaryRequest, WUResultSummaryResponse);

    ESPmethod [cache_seconds(30)] WUResultBin(WUResultBinRequest, WUResultBinResponse);
    ESPmethod [cache_seconds(60)] WUClusterJobQueueXLS(WUClusterJobQueueXLSRequest, WUClusterJobQueueXLSResponse);
    ESPmethod WUClusterJobQueueLOG(WUClusterJobQueueLOGRequest, WUClusterJobQueueLOGResponse);
    ESPmethod [cache_seconds(60)] WUClusterJobXLS(WUClusterJobXLSRequest, WUClusterJobXLSResponse);
    ESPmethod [cache_seconds(60)] WUClusterJobSummaryXLS(WUClusterJobSummaryXLSRequest, WUClusterJobSummaryXLSResponse);
    ESPmethod [clear_cache_group, auth_feature("OwnWorkunitsAccess:WRITE")] WUCreate(WUCreateRequest, WUCreateResponse);
    ESPmethod [clear_cache_group, auth_feature("OwnWorkunitsAccess:WRITE")] WUCreateAndUpdate(WUUpdateRequest, WUUpdateResponse);
    ESPmethod [clear_cache_group] WUUpdate(WUUpdateRequest, WUUpdateResponse);
    ESPmethod [clear_cache_group] WUDelete(WUDeleteRequest, WUDeleteResponse);
    ESPmethod [clear_cache_group] WUSubmit(WUSubmitRequest, WUSubmitResponse);
    ESPmethod [clear_cache_group] WUSchedule(WUScheduleRequest, WUScheduleResponse);
    ESPmethod [clear_cache_group] WUPushEvent(WUPushEventRequest, WUPushEventResponse);
    ESPmethod [clear_cache_group] WUDeployWorkunit(WUDeployWorkunitRequest, WUDeployWorkunitResponse);

    ESPmethod [clear_cache_group] WUAbort(WUAbortRequest, WUAbortResponse);
    ESPmethod [clear_cache_group] WUProtect(WUProtectRequest, WUProtectResponse);
    ESPmethod [min_ver("1.70")] WURecreateQuery(WURecreateQueryRequest, WURecreateQueryResponse);
    ESPmethod [clear_cache_group] WUResubmit(WUResubmitRequest, WUResubmitResponse); //????
    ESPmethod [clear_cache_group] WURun(WURunRequest, WURunResponse);

    ESPmethod WUExport(WUExportRequest, WUExportResponse);
    ESPmethod WUWaitCompiled(WUWaitRequest, WUWaitResponse);
    ESPmethod WUWaitComplete(WUWaitRequest, WUWaitResponse);
    ESPmethod WUSyntaxCheckECL(WUSyntaxCheckRequest, WUSyntaxCheckResponse);
    ESPmethod [clear_cache_group] WUCompileECL(WUCompileECLRequest, WUCompileECLResponse);

    //ESPmethod WUAction(WUActionRequest, WUActionResponse);
    ESPmethod [cache_seconds(60)]WUFile(WULogFileRequest, WULogFileResponse);
    ESPmethod [resp_xsl_default("/esp/xslt/graphStats.xslt")] WUProcessGraph(WUProcessGraphRequest, WUProcessGraphResponse);
    ESPmethod [cache_seconds(30), min_ver("1.57")] WUGetGraphNameAndTypes(WUGetGraphNameAndTypesRequest, WUGetGraphNameAndTypesResponse);
    ESPmethod [cache_seconds(30)] WUGetGraph(WUGetGraphRequest, WUGetGraphResponse);
    ESPmethod [cache_seconds(30)] WUQueryGetGraph(WUQueryGetGraphRequest, WUQueryGetGraphResponse);
    ESPmethod [cache_seconds(30), min_ver("1.72")] WUQueryGetSummaryStats(WUQueryGetSummaryStatsRequest, WUQueryGetSummaryStatsResponse);
    ESPmethod [cache_seconds(30)] WUGetDependancyTrees(WUGetDependancyTreesRequest, WUGetDependancyTreesResponse);

    ESPmethod [cache_seconds(60)] WUListLocalFileRequired(WUListLocalFileRequiredRequest, WUListLocalFileRequiredResponse);
    ESPmethod [clear_cache_group] WUAddLocalFileToWorkunit(WUAddLocalFileToWorkunitRequest, WUAddLocalFileToWorkunitResponse);
    ESPmethod WUCDebug(WUDebugRequest, WUDebugResponse);

    ESPmethod [resp_xsl_default("/esp/xslt/WUPublishWorkunit.xslt")] WUPublishWorkunit(WUPublishWorkunitRequest, WUPublishWorkunitResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60), resp_xsl_default("/esp/xslt/WUQuerysets.xslt")] WUQuerysets(WUQuerysetsRequest, WUQuerysetsResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60), resp_xsl_default("/esp/xslt/WUQuerysetQueries.xslt")] WUQuerysetDetails(WUQuerySetDetailsRequest, WUQuerySetDetailsResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60), resp_xsl_default("/esp/xslt/WUQueryDetails.xslt")] WUQueryDetails(WUQueryDetailsRequest, WUQueryDetailsResponse);
    ESPmethod [cache_seconds(60)] WUMultiQuerysetDetails(WUMultiQuerySetDetailsRequest, WUMultiQuerySetDetailsResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS"), min_ver("1.71")] WUQuerysetImport(WUQuerysetImportRequest, WUQuerysetImportResponse);
    ESPmethod [cache_group("ESPWsWUQS"), min_ver("1.71")] WUQuerysetExport(WUQuerysetExportRequest, WUQuerysetExportResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS")] WUQuerysetQueryAction(WUQuerySetQueryActionRequest, WUQuerySetQueryActionResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS")] WUQuerysetAliasAction(WUQuerySetAliasActionRequest, WUQuerySetAliasActionResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS")] WUQuerysetCopyQuery(WUQuerySetCopyQueryRequest, WUQuerySetCopyQueryResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS")] WUCopyQuerySet(WUCopyQuerySetRequest, WUCopyQuerySetResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS"), resp_xsl_default("/esp/xslt/WUCopyLogicalFiles.xslt")] WUCopyLogicalFiles(WUCopyLogicalFilesRequest, WUCopyLogicalFilesResponse);
    ESPmethod WUQueryConfig(WUQueryConfigRequest, WUQueryConfigResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60)] WUListQueries(WUListQueriesRequest, WUListQueriesResponse);
    ESPmethod [clear_cache_group("ESPWsWUQS"), min_ver("1.59")] WUUpdateQueryEntry(WUUpdateQueryEntryRequest, WUUpdateQueryEntryResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60)] WUQueryFiles(WUQueryFilesRequest, WUQueryFilesResponse);
    ESPmethod [cache_group("ESPWsWUQS"), cache_seconds(60), resp_xsl_default("/esp/xslt/QueriesUsingFile.xslt")] WUListQueriesUsingFile(WUListQueriesUsingFileRequest, WUListQueriesUsingFileResponse);
    ESPmethod WUCreateZAPInfo(WUCreateZAPInfoRequest, WUCreateZAPInfoResponse);
    ESPmethod [resp_xsl_default("/esp/xslt/WUZAPInfoForm.xslt")] WUGetZAPInfo(WUGetZAPInfoRequest, WUGetZAPInfoResponse);
    ESPmethod WUCheckFeatures(WUCheckFeaturesRequest, WUCheckFeaturesResponse);
    ESPmethod [cache_seconds(30)] WUGetStats(WUGetStatsRequest, WUGetStatsResponse);
    ESPmethod [cache_seconds(60), min_ver("1.57")] WUListArchiveFiles(WUListArchiveFilesRequest, WUListArchiveFilesResponse);
    ESPmethod [cache_seconds(60), min_ver("1.57")] WUGetArchiveFile(WUGetArchiveFileRequest, WUGetArchiveFileResponse);
    ESPmethod [cache_seconds(60), min_ver("1.61")] WUGetNumFileToCopy(WUGetNumFileToCopyRequest, WUGetNumFileToCopyResponse);
    ESPmethod [min_ver("1.71")] WUDetails(WUDetailsRequest, WUDetailsResponse);
    ESPmethod [cache_seconds(600), min_ver("1.71")] WUDetailsMeta(WUDetailsMetaRequest, WUDetailsMetaResponse);
    ESPmethod [clear_cache_group, min_ver("1.72")] WUEclDefinitionAction(WUEclDefinitionActionRequest, WUEclDefinitionActionResponse);
    ESPmethod [cache_seconds(60), min_ver("1.74")] WUGetThorJobQueue(WUGetThorJobQueueRequest, WUGetThorJobQueueResponse);
    ESPmethod [cache_seconds(60), min_ver("1.74")] WUGetThorJobList(WUGetThorJobListRequest, WUGetThorJobListResponse);
};


SCMexportdef(WSWU);

SCMapi(WSWU) IClientWsWorkunits *createWsWorkunitsClient();
