/*##############################################################################

    HPCC SYSTEMS software Copyright (C) 2021 HPCC SystemsÂ®.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
############################################################################## */

#ifndef _EspTraceLoggingComponent_HPP_
#define _EspTraceLoggingComponent_HPP_

#include "espcontext.hpp"
#include "jlog.hpp"

/// Common log message detail priority values.
namespace TraceLoggingPriority
{
    static const LogMsgDetail Critical = 1;
    static const LogMsgDetail Major = 10;
    static const LogMsgDetail Highest = 20;
    static const LogMsgDetail High = 30;
    static const LogMsgDetail Medium = 40;
    static const LogMsgDetail Normal = 50;
    static const LogMsgDetail Low = 60;
    static const LogMsgDetail Lowest = 70;
    static const LogMsgDetail Trivial = 80;
    static const LogMsgDetail DataDump = 90;
    static const LogMsgDetail CallStack = 100;

} // namespace TraceLoggingPriority

/**
 * ITraceLoggingComponent reimagines multiple platform approahes to trace log output. Specifically,
 * it is a hybrid of the jlog LOG-related functions and the ESP's ESPLOG. Like jlog, trace content
 * is associated with an audience, a classification, and a priority. Like ESPLOG, the priority is
 * assigned by the caller instead of the function. Also like ESPLOG, generated content is filtered
 * by comparing the assigned priority to a user configured limit.
 *
 * The logging methods in the interface are not virtual. The encapsulation of them within an
 * interface allows the use of virtual helper functions that enable transparent support for
 * additional functionality, including:
 *   - define its own priority limit;
 *   - adjust prepared content before output;
 *   - direct prepared content to any combination of output targets.
 *
 * Why multiple priority limits? Especially during development and testing, it is often the case
 * that a desire for verbose output is limited to the area(s) under review. Raising A single limit,
 * such as is done with ESPLOG, can increase the volume of log content to the point that finding
 * content of interest is unnecessarily difficult. This enables, without requiring, a more granular
 * configuration of limits.
 *
 * Why message content adjustments? Knowing that a class instance failed is good, but knowning which
 * instance failed is better. Obviously the content passed to each log call can be composed to
 * include identifying information, but this enables identifying information to be automatically
 * attached to each message.
 *
 * Why multiple output targets? A proposal has been made to allow transactional trace log entries
 * to be returned in some ESP responses. The proposal is primarily concerned with returning entries
 * generated by DESDL custom transforms to the users developing and testing said transforms. This
 * provides a hook where accumulation of relevant entries can occur.
 */
interface ITraceLoggingComponent : extends IInterface
{
    /// Returns the highest accepted message priority for the given message category.
    virtual LogMsgDetail tracePriorityLimit(const LogMsgCategory& category) const = 0;

    /// Directs accepted content to implemtation-defined targets.
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const = 0;

    /// Defines optional instance identification for content adjustment.
    virtual const char*  traceId() const = 0;

    /**
     * LOG_METHOD_TEMPLATE defines a non-virtual method using its first parameter. The method
     * defines a shared instance of a LogMsgCategory using the remaining parameters. If the
     * requested message priority is neither zero nor greater than the message priority limit, the
     * message will be logged.
     */
#define LOG_METHOD_TEMPLATE(function, audience, classification) \
    void function(LogMsgDetail priorityRequested, const char* format, ...) const __attribute__((format(printf, 3, 4))) \
    { \
        static const LogMsgCategory LMC##function(audience, classification, 1); \
        if (priorityRequested && priorityRequested <= tracePriorityLimit(LMC##function)) \
        { \
            va_list arguments; \
            va_start(arguments, format); \
            traceOutput(LMC##function, format, arguments); \
            va_end(arguments); \
        } \
    }

    LOG_METHOD_TEMPLATE(uerrlog, MSGAUD_user, MSGCLS_error);
    LOG_METHOD_TEMPLATE(uwarnlog, MSGAUD_user, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(uproglog, MSGAUD_user, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(uinfolog, MSGAUD_user, MSGCLS_information);
    LOG_METHOD_TEMPLATE(ierrlog, MSGAUD_programmer, MSGCLS_error);
    LOG_METHOD_TEMPLATE(iwarnlog, MSGAUD_programmer, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(iproglog, MSGAUD_programmer, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(iinfolog, MSGAUD_programmer, MSGCLS_information);
    LOG_METHOD_TEMPLATE(oerrlog, MSGAUD_operator, MSGCLS_error);
    LOG_METHOD_TEMPLATE(owarnlog, MSGAUD_operator, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(oproglog, MSGAUD_operator, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(oinfolog, MSGAUD_operator, MSGCLS_information);

#undef LOG_METHOD_TEMPLATE
};

/**
 * Standard interface implementation, inheriting behavior from base class 'C'.
 */
#define IMPLEMENT_ITRACELOGGINGCOMPONENT_WITH(C) \
    inline  LogMsgDetail tracePriorityLimit(LogMsgAudience audience, LogMsgClass classification) const { return tracePriorityLimit(LogMsgCategory(audience, classification, 1)); } \
    virtual LogMsgDetail tracePriorityLimit(const LogMsgCategory& category) const override { return C::tracePriorityLimit(category); } \
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const override  __attribute__((format(printf, 3, 0))) { return C::traceOutput(category, format, arguments); } \
    virtual const char*  traceId() const override { return C::traceId(); }

/**
 * Utility class for logging entry to and exit from a block of code.
 */
class CTraceBlock
{
private:
    const ITraceLoggingComponent& m_component;
    StringBuffer                  m_caption;
public:
    CTraceBlock(const ITraceLoggingComponent& component, const char* caption)
        : m_component(component)
        , m_caption(caption)
    {
        m_component.iproglog(TraceLoggingPriority::CallStack, "Enter '%s'", m_caption.str());
    }
    ~CTraceBlock()
    {
        m_component.iproglog(TraceLoggingPriority::CallStack, "Exit '%s'", m_caption.str());
    }
};

#define TRACE_BLOCK_WITH(component, caption) CTraceBlock traceBlock(component, caption)
#define TRACE_BLOCK(caption) TRACE_BLOCK_WITH(*this, caption)

/**
 * Basic implementation of the ITraceLoggingComponent interface for use as a mixin base, exposing
 * the logging methods with default behavior.
 */
class CEspTraceLoggingComponent : implements ITraceLoggingComponent, extends CInterface
{
public:
    IMPLEMENT_IINTERFACE;
    virtual LogMsgDetail tracePriorityLimit(const LogMsgCategory& category) const override { return (getEspLogLevel() * 10); }
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const override { VALOG(category, format, arguments); }
    virtual const char*  traceId() const override { return nullptr; }
    inline  LogMsgDetail tracePriorityLimit(LogMsgAudience audience, LogMsgClass classification) const { return tracePriorityLimit(LogMsgCategory(audience, classification, 1)); } \
};

#endif // _EspTraceLoggingComponent_HPP_
