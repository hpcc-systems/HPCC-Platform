/*##############################################################################

    HPCC SYSTEMS software Copyright (C) 2021 HPCC SystemsÂ®.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
############################################################################## */

#ifndef _EspTraceLoggingComponent_HPP_
#define _EspTraceLoggingComponent_HPP_

#include "espcontext.hpp"
#include "jlog.hpp"

/**
 * ITraceLoggingComponent reimagines multiple platform approahes to trace log output. Specifically,
 * it is a hybrid of the jlog LOG-related functions and the ESP's ESPLOG. Like jlog, trace content
 * is associated with an audience, a classification, and a priority. Like ESPLOG, the priority is
 * assigned by the caller instead of the function. Also like ESPLOG, generated content is filtered
 * by comparing the assigned priority to a user configured limit.
 *
 * The logging methods in the interface are not virtual. The encapsulation of them within an
 * interface allows the use of virtual helper functions that enable transparent support for
 * additional functionality, including:
 *   - define its own priority limit;
 *   - adjust prepared content before output;
 *   - direct prepared content to any combination of output targets.
 *
 * Why multiple priority limits? Especially during development and testing, it is often the case
 * that a desire for verbose output is limited to the area(s) under review. Raising A single limit,
 * such as is done with ESPLOG, can increase the volume of log content to the point that finding
 * content of interest is unnecessarily difficult. This enables, without requiring, a more granular
 * configuration of limits.
 *
 * Why message content adjustments? Knowing that a class instance failed is good, but knowning which
 * instance failed is better. Obviously the content passed to each log call can be composed to
 * include identifying information, but this enables identifying information to be automatically
 * attached to each message.
 *
 * Why multiple output targets? A proposal has been made to allow transactional trace log entries
 * to be returned in some ESP responses. The proposal is primarily concerned with returning entries
 * generated by DESDL custom transforms to the users developing and testing said transforms. This
 * provides a hook where accumulation of relevant entries can occur.
 */
interface ITraceLoggingComponent : extends IInterface
{
    /// Directs accepted content to implemtation-defined targets.
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const = 0;

    /// Defines optional instance identification for content adjustment.
    virtual const char*  traceId() const = 0;

    /**
     * LOG_METHOD_TEMPLATE defines a non-virtual method using its first parameter. The method
     * defines a shared instance of a LogMsgCategory using the remaining parameters.
     */
#define LOG_METHOD_TEMPLATE(function, audience, classification) \
    void function(const char* format, ...) const __attribute__((format(printf, 2, 3))) \
    { \
        static const LogMsgCategory LMC##function(audience, classification); \
        va_list arguments; \
        va_start(arguments, format); \
        traceOutput(LMC##function, format, arguments); \
        va_end(arguments); \
    }

    // MORE - can remove all these and just use underlying jlog I suspect

    LOG_METHOD_TEMPLATE(uerrlog, MSGAUD_user, MSGCLS_error);
    LOG_METHOD_TEMPLATE(uwarnlog, MSGAUD_user, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(uproglog, MSGAUD_user, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(uinfolog, MSGAUD_user, MSGCLS_information);
    LOG_METHOD_TEMPLATE(ierrlog, MSGAUD_programmer, MSGCLS_error);
    LOG_METHOD_TEMPLATE(iwarnlog, MSGAUD_programmer, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(iproglog, MSGAUD_programmer, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(iinfolog, MSGAUD_programmer, MSGCLS_information);
    LOG_METHOD_TEMPLATE(oerrlog, MSGAUD_operator, MSGCLS_error);
    LOG_METHOD_TEMPLATE(owarnlog, MSGAUD_operator, MSGCLS_warning);
    LOG_METHOD_TEMPLATE(oproglog, MSGAUD_operator, MSGCLS_progress);
    LOG_METHOD_TEMPLATE(oinfolog, MSGAUD_operator, MSGCLS_information);

#undef LOG_METHOD_TEMPLATE
};

/**
 * Standard interface implementation, inheriting behavior from base class 'C'.
 */
#define IMPLEMENT_ITRACELOGGINGCOMPONENT_WITH(C) \
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const override  __attribute__((format(printf, 3, 0))) { return C::traceOutput(category, format, arguments); } \
    virtual const char*  traceId() const override { return C::traceId(); }

/**
 * Utility class for logging entry to and exit from a block of code.
 */

// MORE - this needs feature-level log support

class CTraceBlock
{
private:
    const ITraceLoggingComponent& m_component;
    StringBuffer                  m_caption;
public:
    CTraceBlock(const ITraceLoggingComponent& component, const char* caption)
        : m_component(component)
        , m_caption(caption)
    {
        m_component.iproglog("Enter '%s'", m_caption.str());
    }
    ~CTraceBlock()
    {
        m_component.iproglog("Exit '%s'", m_caption.str());
    }
};

#define TRACE_BLOCK_WITH(component, caption) CTraceBlock traceBlock(component, caption)
#define TRACE_BLOCK(caption) TRACE_BLOCK_WITH(*this, caption)

/**
 * Basic implementation of the ITraceLoggingComponent interface for use as a mixin base, exposing
 * the logging methods with default behavior.
 */
class CEspTraceLoggingComponent : implements ITraceLoggingComponent, extends CInterface
{
public:
    IMPLEMENT_IINTERFACE;
    virtual void         traceOutput(const LogMsgCategory& category, const char* format, va_list& arguments) const override { VALOG(category, format, arguments); }
    virtual const char*  traceId() const override { return nullptr; }
};

#endif // _EspTraceLoggingComponent_HPP_
