Branch and version strategy
===========================

Versions
========

Version numbers take the form MAJOR.MINOR.POINT_SEQUENCE

The MAJOR version will change only with a significant architectural change.
The MINOR version number changes when new features are introduced.
The POINT version number changes when bugs are fixed.
The SEQUENCE number is changed when a new candidate package is created during
closedown testing.

Versions that have been closed down, tested, and passed as suitable for general
release are given even MINOR and POINT numbers. Odd numbers are reserved for
builds for testing purposes only.

In addition to the version number there is a MATURITY string that may be found
in the version string. The maturities in use are:

<none>    - a stable build
closedown - gathering bugfixes for a new POINT release
rc        - a release candidate.
trunk     - a system built from the master branch (the 'bleeding edge')
*_debug   - Any of the above suffixed by _debug if built with debug enabled

Branches
========

The master branch contains the latest accepted code. Code in the master branch
should normally be fully functional, but may not yet have gone through rigorous
testing or be considered production-ready. If you want to build a system in order
to experiment with extending the code, or to test new features that have not yet
been included in a stable build, then you should build the master branch.

The stable branch points to the current version of the system that has been
through the full closedown testing cycle and is considered production-ready. If
you want to build a local version of a stable build - perhaps to install on a
distro for which a pre-packaged binary is not available, then you should build
the stable branch. Note that stable is rebased when a new MAJOR or MINOR version
number release is published.

Branches with names starting candidate- contain code that is being prepared for
release as a stable version. Fixes for bugs discovered during closedown testing
will be merged into the current candidate- branch.

When preparing a patch or a GitHub pull request, a new git branch should be created
based on the appropriate target - if the change is to go into the next 3.6 build, then
base it on candidate-3.6.x, for example. All changes that are accepted into candidate-3.6.x
are normally merged into the master branch too.

Bug fixes for a specific release that has been named already go directly to its
candidate branch. So, if there is a version 3.6.2 that is in final testing phase and
a 3.6.4 that will be the next release, candidate-3.6.2 should be used to merge
bug-fixes to the former, while candidate-3.6.x to the latter.

Release cycle
=============

At any point in time, there are several concurrent versions being developed,
each with its own branch. Each pending version will be released in order, so
changes to the code will be assigned to the correct version depending on their
priorities, severities and impact. Below is a simple table of the release
cycle and the type of changes that will be accepted into each different
release.

Released: Version that is available for download on the website. Bugs will be
          fixed on subsequent versions of the platform.

    Gold: The current release, in late testing phase and approved internally for
          release. If serious bugs or regressions are found, we might have
          to create a new release-candidate. Otherwise, bugs will be fixed on
          subsequent versions of the platform.

  Stable: The next release, where major bugs and regressions are being fixed, and
          only minor features are being developed. Only the features that have
          been agreed should go in this release, with all new ones targeted to
          Unstable release. Minor features that are required to fix a bug can
          be included in the last minute, provided developers agree with it.

Unstable: Current development version, where new important features are being
          developed. New feature requests should be targeted to this release.
          However, some major features (or ones that break compatibility) should
          be target to Future. Some refactoring should go into this release,
          provided it makes the platform more stable and robust.

  Future: Big refactoring, long-term development, destructive/backward
          incompatible features. This normally reflects the next major (x.0)
          version.

Tags
====

Tags corresponding to the release versions will be applied to points on the
candidate- branch where binary releases have been built and published.
