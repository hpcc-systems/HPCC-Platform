import{_ as t,a as l,o as a,ag as n}from"./chunks/framework.Do1Zayaf.js";const p=JSON.parse('{"title":"Ecl-bundle source documentation","description":"","frontmatter":{},"headers":[],"relativePath":"ecl/ecl-bundle/DOCUMENTATION.md","filePath":"ecl/ecl-bundle/DOCUMENTATION.md","lastUpdated":1771585025000}'),i={name:"ecl/ecl-bundle/DOCUMENTATION.md"};function o(r,e,s,d,c,u){return a(),l("div",null,e[0]||(e[0]=[n('<h1 id="ecl-bundle-source-documentation" tabindex="-1">Ecl-bundle source documentation <a class="header-anchor" href="#ecl-bundle-source-documentation" aria-label="Permalink to &quot;Ecl-bundle source documentation&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><h3 id="purpose" tabindex="-1">Purpose <a class="header-anchor" href="#purpose" aria-label="Permalink to &quot;Purpose&quot;">​</a></h3><p>The ecl-bundle executable (normally executed from the ecl executable by specifying &#39;ecl bundle XXX&#39; is designed to manipulate ecl bundle files</p><ul><li>these are self-contained parcels of ECL code, packaged into a compressed file like a zip or .tar.gz file, that can be downloaded, installed, removed etc from an ECL installation.</li></ul><h3 id="design" tabindex="-1">Design <a class="header-anchor" href="#design" aria-label="Permalink to &quot;Design&quot;">​</a></h3><p>The metadata for ECL bundles is described using an exported module called Bundle within the bundle&#39;s source tree - typically, this means that a file called Bundle.ecl will be added to the highest level of the bundle&#39;s directory tree. In order to extract the information from the Bundle module, eclcc is run in &#39;evaluate&#39; mode (using the -Me option) which will parse the bundle module and output the required fields to stdout.</p><p>ecl-bundle also executes eclcc (using the --showpaths option) to determine where bundle files are to be located.</p><h3 id="directory-structure" tabindex="-1">Directory structure <a class="header-anchor" href="#directory-structure" aria-label="Permalink to &quot;Directory structure&quot;">​</a></h3><p>In order to make versioning easier, bundle files are not copied directly into the bundles directory. A bundle called &quot;MyBundle&quot; that announces itself as version &quot;x.y.z&quot; will be installed to the directory</p><p>$BUNDLEDIR/_versions/MyBundle/x.y.z</p><p>A &quot;redirect&quot; file called MyBundle.ecl is then created in $BUNDLEDIR, which redirects any IMPORT MyBundle statement to actually import the currently active version of the bundle in _versions/MyBundle/x.y.z</p><p>By rewriting this redirect file, it is possible to switch to using a different version of a bundle without having to uninstall and reinstall.</p><p>In a future release, we hope to make it possible to specify that bundle A requires version X of bundle B, while bundle C requires version Y of bundle B. That will require the redirect files to be &#39;local&#39; to a bundle (and will require that bundle B uses a redirect file to ensure it picks up the local copy of B when making internal calls).</p><h3 id="key-classes" tabindex="-1">Key classes <a class="header-anchor" href="#key-classes" aria-label="Permalink to &quot;Key classes&quot;">​</a></h3><p>An IBundleInfo represents a specific copy of a bundle, and is created by explicitly parsing a snippet of ECL that imports it, with the ECL include path set to include only the specified bundle.</p><p>An IBundleInfoSet represents all the installed versions of a particular named bundle.</p><p>An IBundleCollection represents all the bundles on the system.</p><p>Every individual subcommand is represented by a class derived (directly or indirectly) from EclCmdCommon. These classes are responsible for command-line parsing, usage text output, and (most importantly) execution of the desired outcomes.</p>',19)]))}const b=t(i,[["render",o]]);export{p as __pageData,b as default};
