import{_ as a,a as s,o as t,ag as n}from"./chunks/framework.Do1Zayaf.js";const u=JSON.parse('{"title":"File storage in HPCC","description":"","frontmatter":{},"headers":[],"relativePath":"helm/hpcc/docs/storage.md","filePath":"helm/hpcc/docs/storage.md","lastUpdated":1771585025000}'),o={name:"helm/hpcc/docs/storage.md"};function i(l,e,p,r,h,c){return t(),s("div",null,e[0]||(e[0]=[n(`<h1 id="file-storage-in-hpcc" tabindex="-1">File storage in HPCC <a class="header-anchor" href="#file-storage-in-hpcc" aria-label="Permalink to &quot;File storage in HPCC&quot;">​</a></h1><p>The &#39;storage&#39; section of the values.yaml file configures the locations that HPCC stores all categories of data. Most of that configuration is provided within the list of storage planes. Each plane has 3 required fields - name, category and prefix. E.g. the following simplified list:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  planes:</span></span>
<span class="line"><span>  - name: dali</span></span>
<span class="line"><span>    category: dali</span></span>
<span class="line"><span>    prefix: &quot;/var/lib/HPCCSystems/dalistorage&quot;</span></span>
<span class="line"><span>  - name: dll</span></span>
<span class="line"><span>    category: dll</span></span>
<span class="line"><span>    prefix: &quot;/var/lib/HPCCSystems/queries&quot;</span></span>
<span class="line"><span>  - name: primarydata</span></span>
<span class="line"><span>    category: data</span></span>
<span class="line"><span>    prefix: &quot;/var/lib/HPCCSystems/hpcc-data&quot;</span></span></code></pre></div><h2 id="name" tabindex="-1">name <a class="header-anchor" href="#name" aria-label="Permalink to &quot;name&quot;">​</a></h2><p>The &#39;name&#39; property is used to identify the storage plane in the helm charts. It is also visible to the user - to identify a storage location within eclwatch or ECL code. The name must be unique and must not include upper-case characters. It loosely corresponds to a cluster in the bare-metal version of the platform.</p><h2 id="category" tabindex="-1">category <a class="header-anchor" href="#category" aria-label="Permalink to &quot;category&quot;">​</a></h2><p>&#39;category&#39; is used to indicate the kind of data that is being stored in that location. Different planes are used for the different categories to isolate the different types of data from each other, but also because they often require different performance characteristics. A named plane may only store one category of data. The following categories are currently supported (with some notes about performance characteristics:</p><ul><li>data<br> Where are data files generated by HPCC stored? For Thor, storage costs are likely to be significant. Sequential access speed is important, but random access is much less so. For roxie speed of random access is likely to be important.</li><li>lz<br> A landing zone where external users can read and write files. The HPCC system can import from or export files to a landing zone. Typically performance is less of an issue, could be blob/s3 bucket storage - accessed either directly or via an NFS mount.</li><li>dali<br> The location of the dali metadata store. Needs to support fast random access.</li><li>dll<br> Where are the compiled ECL queries stored? The storage needs to allow shared objects to be directly loaded from it efficiently.</li><li>sasha<br> Location to store archived workunits, etc. Typically less speed critical and requires lower storage costs.</li><li>spill (optional)<br> Where are spill files from thor written? Local NVMe disks are potentially a good choice.</li><li>temp (optional)<br> Where are temporary files written?</li></ul><p>Currently temp and spill are not completely implemented, but will be in future point releases. It is likely that other categories will be added in the future (for example, a location to store inter-subgraph spills).</p><h2 id="prefix" tabindex="-1">prefix <a class="header-anchor" href="#prefix" aria-label="Permalink to &quot;prefix&quot;">​</a></h2><p>The most common case is where this defines the path within the container that the storage is mounted. In the example above they are all sub-directories of /var/lib/HPCCSystems.</p><p>HPCC also allows some file systems to be accessed through a url syntax. For instance the following landing zone uses azure blob storage:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  planes:</span></span>
<span class="line"><span>  - name: azureblobs</span></span>
<span class="line"><span>    prefix: &quot;azure://ghallidayblobs@data&quot;</span></span>
<span class="line"><span>    category: lz</span></span></code></pre></div><h1 id="how-is-storage-associated-with-a-storage-plane" tabindex="-1">How is storage associated with a storage plane? <a class="header-anchor" href="#how-is-storage-associated-with-a-storage-plane" aria-label="Permalink to &quot;How is storage associated with a storage plane?&quot;">​</a></h1><p>So far we have seen the properties that describe how the HPCC application views the storage, but how does Kubernetes associate those definitions with physical storage?</p><h2 id="ephemeral-storage-storageclass-storagesize" tabindex="-1">Ephemeral storage: (storageClass, storageSize) <a class="header-anchor" href="#ephemeral-storage-storageclass-storagesize" aria-label="Permalink to &quot;Ephemeral storage: (storageClass, storageSize)&quot;">​</a></h2><p>Ephemeral storage is allocated when the HPCC cluster is installed and deleted when the chart is uninstalled. It is useful for providing a clean system for testing and for a demonstration system to allow you to experiment with the system. It is not so useful for production systems - for this reason the helm chart generates a warning if it is used.</p><ul><li><p>storageClass:<br> Which storage provisioner should be used to allocate the storage? A blank storage class indicates it should use the default provisioner.</p></li><li><p>storageSize:<br> How much memory is required for this storage?</p></li></ul><p>E.g. An ephemeral data plane:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  planes:</span></span>
<span class="line"><span>  - name: data</span></span>
<span class="line"><span>    storageClass: &quot;&quot;</span></span>
<span class="line"><span>    storageSize: 1Gi</span></span>
<span class="line"><span>    prefix: &quot;/var/lib/HPCCSystems/hpcc-data&quot;</span></span>
<span class="line"><span>    category: data</span></span></code></pre></div><p>And to add an ephemeral landing zone (which you can upload files to via eclwatch) you could use:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  planes:</span></span>
<span class="line"><span>  - name: mylandingzone</span></span>
<span class="line"><span>    storageClass: &quot;&quot;</span></span>
<span class="line"><span>    storageSize: 1Gi</span></span>
<span class="line"><span>    prefix: &quot;/var/lib/HPCCSystems/mylandingzone&quot;</span></span>
<span class="line"><span>    category: lz</span></span></code></pre></div><h2 id="persistent-storage-pvc" tabindex="-1">Persistent storage (pvc) <a class="header-anchor" href="#persistent-storage-pvc" aria-label="Permalink to &quot;Persistent storage (pvc)&quot;">​</a></h2><p>For persistent storage, the hpcc cluster uses persistent volume claims that have already been created by installing another Kubernetes chart. Using a pvc allows the lifetime of the data stored on those volumes to be longer than the lifetime of the HPCC cluster that uses them. The helm/examples directory contains charts to simplify defining persistent storage for a local machine, azure, aws etc.</p><ul><li>pvc<br> The pvc property names a Persistent Volume Claim created by another chart.</li></ul><h1 id="default-storage-planes" tabindex="-1">Default storage planes <a class="header-anchor" href="#default-storage-planes" aria-label="Permalink to &quot;Default storage planes&quot;">​</a></h1><p>The values file can contain more than one storage plane definition for each category. The first storage plane in the list for each category is used as the default location to store that category of data.</p><p>That default can be overridden on each component by specifying a property with the name &quot;&lt;category&gt;Plane&quot;. For example, to override the default dali storage plane to use daliPlane:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eclagent:</span></span>
<span class="line"><span>- name: hthor</span></span>
<span class="line"><span>  prefix: hthor</span></span>
<span class="line"><span>  dataPlane: premium-data               # override the default data plane</span></span>
<span class="line"><span>dali:</span></span>
<span class="line"><span>- name: mydali</span></span>
<span class="line"><span>  daliPlane: primary-dali-plane         # override the plane to store the dali data</span></span></code></pre></div><p>It is also possible to override the target storage plane by using the PLANE options on an OUTPUT statement in the ECL language. This allows the ECL programmer to write data to different storage planes depending on how the data is going to be used. The engines can read data from any of the data planes.</p><h1 id="other-storage-planes-options" tabindex="-1">Other storage.planes options <a class="header-anchor" href="#other-storage-planes-options" aria-label="Permalink to &quot;Other storage.planes options&quot;">​</a></h1><ul><li><p>forcePermissions: &lt;boolean&gt;<br> In some situations the default permissions for the mounted volumes do not allow the hpcc user to write to the storage. Setting this option ensures the ownership of the volume is changed before the main process is started.</p></li><li><p>subPath: &lt;string&gt;<br> This property provides an optional sub-directory within &lt;prefix&gt; to use as the root directory. Most of the time the different categories of data will be stored in different locations and this option is not needed. However, if there is a requirement to store two categories of data in the same location, then it is legal to have two storage planes use the same prefix/path and different categories as long as the rest of the plane definitions are identical (except for the name and the subPath). The subPath property allows the data to reside in separate directories so they cannot clash.</p></li><li><p>secret: &lt;string&gt;<br> This provides the name of any secret that is required to access the plane&#39;s storage. It it currently unused, but may be required once inter-cluster remote file access is finished.</p></li><li><p>defaultSprayParts: &lt;number&gt;<br> Earlier we commented that storage planes are similar to clusters in bare-metal. One key difference is that bare-metal clusters are associated with a fixed size thor, whereas a storage plane is not. This property allows you to define the number of parts that a file is split into when it is imported/sprayed. The default is the size of the largest thor cluster.</p></li><li><p>cost:<br> This property allows you to specify the costs associated with the storage so that the platform can calculate an estimate of the costs associated with each file. Currently only the cost at rest is supported, transactional costs will be added later. E.g.</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>      cost:</span></span>
<span class="line"><span>        storageAtRest: 0.113                # Storage at rest cost: cost per GiB/month</span></span></code></pre></div><h1 id="bare-metal-storage" tabindex="-1">Bare metal storage <a class="header-anchor" href="#bare-metal-storage" aria-label="Permalink to &quot;Bare metal storage&quot;">​</a></h1><p>There are two aspects to using bare-metal storage in the Kubernetes system. The first is the &#39;hostGroups&#39; entry in the storage section which provides named lists of hosts. The hostGroups entries can take one of two forms:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  hostGroups:</span></span>
<span class="line"><span>  - name: &quot;The name of the host group process&quot;</span></span>
<span class="line"><span>    hosts: [ &quot;a list of host names&quot; ]</span></span></code></pre></div><p>This is the most common form, and directly associates a list of host names with a name. The second form:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  hostGroups:</span></span>
<span class="line"><span>  - name: &quot;The name of the host group process&quot;</span></span>
<span class="line"><span>    hostGroup: &quot;Name of the hostgroup to create a subset of&quot;</span></span>
<span class="line"><span>    count: &quot;Number of hosts in the subset&quot;</span></span>
<span class="line"><span>    offset: &quot;the first host to include in the subset&quot;</span></span>
<span class="line"><span>    delta:  &quot;Cycle offset to apply to the hosts&quot;</span></span></code></pre></div><p>allows one host group to be derived from another. Some typical examples with bare-metal clusters are smaller subsets of the host, or the same hosts, but storing different parts on different nodes. E.g.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  hostGroups:</span></span>
<span class="line"><span>  - name: groupABCDE              # Explicit list of hosts</span></span>
<span class="line"><span>    hosts: [A, B, C, D, E]</span></span>
<span class="line"><span>  - name groupCDE                 # Subset of the group last 3 hosts</span></span>
<span class="line"><span>    hostGroup: groupABCDE</span></span>
<span class="line"><span>    count: 3</span></span>
<span class="line"><span>    offset: 2</span></span>
<span class="line"><span>  - name groupDEC                 # Same set of hosts, but different part-&gt;host mapping</span></span>
<span class="line"><span>    hostGroup: groupCDE</span></span>
<span class="line"><span>    delta: 1</span></span></code></pre></div><p>The second aspect is to add a property to the storage plane definition to indicate which hosts are associated with it.</p><p>There are two options:</p><ul><li>hostGroup: &lt;name&gt;<br> The name of the host group for bare metal. For historical reasons the name of the hostgroup must match the name of the storage plane.</li><li>hosts: &lt;list-of-namesname&gt;<br> An inline list of hosts. Primarily useful for defining one-off external landing zones.</li></ul><p>For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>storage:</span></span>
<span class="line"><span>  planes:</span></span>
<span class="line"><span>  - name: demoOne</span></span>
<span class="line"><span>    category: data</span></span>
<span class="line"><span>    prefix: &quot;/home/gavin/temp&quot;</span></span>
<span class="line"><span>    hostGroup: groupABCD             # The name of the hostGroup</span></span>
<span class="line"><span>  - name: myDropZone</span></span>
<span class="line"><span>    category: lz</span></span>
<span class="line"><span>    prefix: &quot;/home/gavin/mydropzone&quot;</span></span>
<span class="line"><span>    hosts: [ &#39;mylandingzone.com&#39; ]  # Inline reference to an external host.</span></span></code></pre></div>`,45)]))}const g=a(o,[["render",i]]);export{u as __pageData,g as default};
