import{_ as t,a,o as i,ag as o}from"./chunks/framework.Do1Zayaf.js";const u=JSON.parse('{"title":"Eclcc/Code generator","description":"","frontmatter":{"title":"Eclcc/Code generator"},"headers":[],"relativePath":"devdoc/CodeGenerator.md","filePath":"devdoc/CodeGenerator.md","lastUpdated":1771585025000}'),r={name:"devdoc/CodeGenerator.md"};function s(n,e,l,h,d,c){return i(),a("div",null,e[0]||(e[0]=[o(`<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><h2 id="purpose" tabindex="-1">Purpose <a class="header-anchor" href="#purpose" aria-label="Permalink to &quot;Purpose&quot;">​</a></h2><p>The primary purpose of the code generator is to take an ECL query and convert it into a work unit that is suitable for running by one of the engines.</p><h2 id="aims" tabindex="-1">Aims <a class="header-anchor" href="#aims" aria-label="Permalink to &quot;Aims&quot;">​</a></h2><p>The code generator has to do its job accurately. If the code generator does not correctly map the ECL to the workunit it can lead to corrupt data and invalid results. Problems like that can often be very hard and frustrating for the ECL users to track down.</p><p>There is also a strong emphasis on generating output that is as good as possible. Eclcc contains many different optimization stages, and is extensible to allow others to be easily added.</p><p>Eclcc needs to be able to cope with reasonably large jobs. Queries that contain several megabytes of ECL, and generate tens of thousands of activities, and 10s of Mb of C++ are routine. These queries need to be processed relatively quickly.</p><h2 id="key-ideas" tabindex="-1">Key ideas <a class="header-anchor" href="#key-ideas" aria-label="Permalink to &quot;Key ideas&quot;">​</a></h2><p>Nearly all the processing of ECL is done using an expression graph. The representation of the expression graph has some particular characteristics:</p><ul><li>Once the nodes in the expression graph have been created they are NEVER modified.</li><li>Nodes in the expression graph are ALWAYS commoned up if they are identical.</li><li>Each node in the expression graph is link counted (see below) to track its lifetime.</li><li>If a modified graph is required a new graph is created (sharing nodes from the old one)</li></ul><p>The ECL language is a declarative language, and in general is assumed to be pure - i.e. there are no side-effects, expressions can be evaluated lazily and re-evaluating an expression causes no problems. This allows eclcc to transform the graph in lots of interesting ways. (Life is never that simple so there are mechanisms for handling the exceptions.)</p><h2 id="from-declarative-to-imperative" tabindex="-1">From declarative to imperative <a class="header-anchor" href="#from-declarative-to-imperative" aria-label="Permalink to &quot;From declarative to imperative&quot;">​</a></h2><p>One of the main challenges with eclcc is converting the declarative ECL code into imperative C++ code. One key problem is it needs to try to ensure that code is only evaluated when it is required, but that it is also only evaluated once. It isn&#39;t always possible to satisfy both constraints - for example a global dataset expression used within a child query. Should it be evaluated once before the activity containing the child query is called, or each time the child query is called? If it is called on demand then it may not be evaluated as efficiently...</p><p>This issue complicates many of the optimizations and transformations that are done to the queries. Long term the plan is to allow the engines to support more delayed lazy-evaluation, so that whether something is evaluated is more dynamic rather than static.</p><h2 id="flow-of-processing" tabindex="-1">Flow of processing <a class="header-anchor" href="#flow-of-processing" aria-label="Permalink to &quot;Flow of processing&quot;">​</a></h2><p>The idealised view of the processing within eclcc follows the following stages:</p><ul><li>Parse the ECL into an expression graph.</li><li>Expand out function calls.</li><li>Normalize the expression graph so it is in a consistent format.</li><li>Normalize the references to fields within datasets to tie them up with their scopes.</li><li>Apply various global optimizations.</li><li>Translate logical operations into the activities that will implement them.</li><li>Resource and generate the global graph</li><li>For each activity, resource, optimize and generate its child graphs.</li></ul><p>In practice the progression is not so clear cut. There tends to be some overlap between the different stages, and some of them may occur in slightly different orders. However the order broadly holds.</p><h1 id="working-on-the-code-generator" tabindex="-1">Working on the code generator <a class="header-anchor" href="#working-on-the-code-generator" aria-label="Permalink to &quot;Working on the code generator&quot;">​</a></h1><h2 id="the-regression-suite" tabindex="-1">The regression suite <a class="header-anchor" href="#the-regression-suite" aria-label="Permalink to &quot;The regression suite&quot;">​</a></h2><p>Before any change is accepted for the code generator it is always run against several regression suites to ensure that it doesn&#39;t introduce any problems, and that the change has the desired effect. There are several different regression suites:</p><ul><li>testing/regress/ecl - The run time regression suite.</li><li>ecl/regress - a compiler regression suite. This contains tests that cannot run and error tests.</li><li>LN private suite - This contains a large selection (&gt;10Gb) of archived queries. The contain proprietary code so unfortunately cannot be released as open source.</li></ul><p>The ecl/regress directory contains a script &#39;regress.sh&#39; that is used for running the regression tests. It should be executed in the directory containing the ecl files. The script generates the c++ code (and workunits) for each of the source files to a target directory, and then executes a comparison program to compare the new results with a previous &quot;golden&quot; reference set.</p><p>Before making any changes to the compiler, a reference set should be created by running the regression script and copying the generated files to the reference directory.</p><p>Here is a sample command line</p><p><code>~/dev/hpcc/ecl/regress/regress.sh -t /regress/hpcc -e /home/&lt;user&gt;/buildr/Release/bin/eclcc -I /home/&lt;user&gt;/dev/hpcc/ecl/regress/modules -I /home/&lt;user&gt;/dev/hpcc/plugins/javaembed -I /home/&lt;user&gt;/dev/hpcc/plugins/v8embed -c /regress/hpcc.master -d bcompare</code></p><p>(A version of this command resides in a shell script in each of my regression suite directories, with the -t and -c options adapted for each suite.)</p><p>For a full list of options execute the script with no parameters, or take a look at the script itself. A couple of useful options are:</p><ul><li>The script can be run on a single file by using the -q option.</li><li>The (-e) option selects the path of the eclcc. This is particularly useful when running from the build directory (see below), or using multiple build directories to compare behaviour between different versions.</li></ul><p>We strongly recommend using a comparison program which allows rules to be defined to ignore certain differences (e.g., beyond compare).</p><h2 id="running-directly-from-the-build-directory" tabindex="-1">Running directly from the build directory <a class="header-anchor" href="#running-directly-from-the-build-directory" aria-label="Permalink to &quot;Running directly from the build directory&quot;">​</a></h2><p>It is much quicker to run eclcc directly from the build directory, rather than deploying a system and running eclcc from there. To do this you need to configure some options that eclcc requires, e.g. where the include files are found. The options can be set by either setting environment variables or by specifiying options in an eclcc.ini file. The following are the names of the different options:</p><hr><p>Environment flag Ini file option</p><hr><p>CL_PATH compilerPath</p><p>ECLCC_LIBRARY_PATH libraryPath</p><p>ECLCC_INCLUDE_PATH includePath</p><p>ECLCC_PLUGIN_PATH plugins</p><p>HPCC_FILEHOOKS_PATH filehooks</p><p>ECLCC_TPL_PATH templatePath</p><p>ECLCC_ECLLIBRARY_PATH eclLibrariesPath</p><h2 id="eclcc-eclbundle-path-eclbundlespath" tabindex="-1">ECLCC_ECLBUNDLE_PATH eclBundlesPath <a class="header-anchor" href="#eclcc-eclbundle-path-eclbundlespath" aria-label="Permalink to &quot;ECLCC\\_ECLBUNDLE\\_PATH    eclBundlesPath&quot;">​</a></h2><p>The eclcc.ini can either be a file in the local directory, or specified on the eclcc command line with -specs. Including the settings in a local eclcc.ini file also it easy to debug eclcc directly from the build directory within the eclipse environment.</p><h2 id="hints-and-tips" tabindex="-1">Hints and tips <a class="header-anchor" href="#hints-and-tips" aria-label="Permalink to &quot;Hints and tips&quot;">​</a></h2><ul><li><p>Logging</p><p>There is an option for eclcc to output a logging file, and another to specify the level of detail in that logging file. If the detail level is above 500 then the expresssion tree for the query is output to the logging file after each of the code transformations. The tracing is very useful for tracking down at which stage inconsistencies are introduced in the expression graph, and also for learning how each transformation affects the query.</p><p>The output format defaults to ECL - which is regenerated from the expression tree. (This ECL cannot generally be compiled without editing - partly because it contains extra annoations.) Use either of the following:</p><p><code>eclcc myfile.ecl --logfile myfile.log --logdetail 999</code></p><p><code>regress.sh -q myfile.ecl -l myfile.log</code></p></li><li><p>-ftraceIR</p><p>There is a debug option (-ftraceIR) that generates an intermediate representation of the expression graph rather than regenerating ECL. The output tends to be less compact and harder to read quickly, but has the advantage of being better structured, and contains more details of the internal representation. ecl/hql/hqlir.cpp contains more details of the format.</p></li><li><p>Adding extra logging into the source code</p><p>If you want to add tracing of expressions at any point in the code generation then adding either of the following calls will include the expression details in the log file:</p><p><code>dbglogExpr(expr); // regenerate the ecl for an expression. See other functions in ecl/hql/hqlthql.hpp</code></p><p><code>EclIR::dbglogIR(expr); // regenerate the IR for an expression. See other functions in ecl/hql/hqlir.hpp</code></p></li><li><p>Logging while debugging</p><p>If you are debugging inside gdb it is often useful to be able to dump out details of an expression. Calling EclIR:dump_ir(expr); will generate the IR to stdout.</p><p><code>p EclIR::dump_ir(expr)</code></p><p>The function can also be used with multiple parameters. Each expression will be dumped out, but common child nodes will only be generated once. This can be very useful when trying to determine the difference between two expressions. The quickest way is to call <code>EclIR::dump_ir(expr1, expr2)</code>. The first difference between the expressions will be the expression that follows the first &quot;return&quot;.</p></li><li><p>Expression sequence ids.</p><p>Sometimes it can be hard to determine where a particular IHqlExpression node was created. If that is the case, then defining <code>DEBUG_TRACK_INSTANCEID</code> (in ecl/hql/hqlexpr.ipp) will add a unique sequence number to each IHqlExpression that is created. There is also a function checkSeqId() at the start of ecl/hql/hqlexpr.cpp which is called whenever an expression is created, linked, released etc.. Setting a breakpoint in that function can allow you to trace back exactly when and why a particular node was created.</p></li></ul><h1 id="expressions" tabindex="-1">Expressions <a class="header-anchor" href="#expressions" aria-label="Permalink to &quot;Expressions&quot;">​</a></h1><h2 id="expression-graph-representation" tabindex="-1">Expression Graph representation <a class="header-anchor" href="#expression-graph-representation" aria-label="Permalink to &quot;Expression Graph representation&quot;">​</a></h2><p>The key data structure within eclcc is the graph representation. The design has some key elements.</p><ul><li><p>Once a node is created it is never modified.</p><p>Some derived information (e.g., sort order, number of records, unique hash, ...) might be calculated and stored in the class after it has been created, but that doesn&#39;t change what the node represents in any way. Some nodes are created in stages - e.g., records, modules. These nodes are marked as fully completed when closeExpr() is called, after which they cannot be modified.</p></li><li><p>Nodes are always commoned up.</p><p>If the same operator has the same arguments and type then there will be a unique IHqlExpression to represent it. This helps ensure that graphs stay as graphs and don&#39;t get converted to trees. It also helps with optimizations, and allows code duplicated in two different contexts to be brought together.</p></li><li><p>The nodes are link counted.</p><p>Link counts are used to control the lifetime of the expression objects. Whenever a reference to an expression node is held, its link count is increased, and decreased when no longer required. The node is freed when there are no more references. (This generally works well, but does give us problems with forward references.)</p></li><li><p>The access to the graph is through interfaces.</p><p>The main interfaces are IHqlExpression, IHqlDataset and IHqlScope. They are all defined in hqlexpr.hpp. The aim of the interfaces is to hide the implementation of the expression nodes so they can be restructured and changed without affecting any other code.</p></li><li><p>The expression classes use interfaces and a type field rather than polymorphism. This could be argued to be bad object design...but.</p><p>There are more than 500 different possible operators. If a class was created for each of them the system would quickly become unwieldy. Instead there are several different classes which model the different types of expression (dataset/expression/scope).</p><p>The interfaces contain everything needed to create and interrogate an expression tree, but they do not contain functionality for directly processing the graph.</p><p>To avoid some of the shortcomings of type fields there are various mechanisms for accessing derived attributes which avoid interrogating the type field.</p></li><li><p>Memory consumption is critical.</p></li></ul><p>It is not unusual to have 10M or even 100M nodes in memory as a query is being processed. At that scale the memory consumption of each node matters - so great care should be taken when considering increasing the size of the objects. The node classes contain a class hierarchy which is there purely to reduce the memory consumption - not to reflect the functionality. With no memory constraints they wouldn&#39;t be there, but removing a single pointer per node can save 1Gb of memory usage for very complex queries.</p><h3 id="ihqlexpression" tabindex="-1">IHqlExpression <a class="header-anchor" href="#ihqlexpression" aria-label="Permalink to &quot;IHqlExpression&quot;">​</a></h3><p>This is the interface that is used to walk and interrogate the expression graph once it has been created. Some of the main functions are: getOperator() What does this node represent? It returns a member of the node_operator enumerated type. numChildren() How many arguments does node have? queryChild(unsigned n) What is the nth child? If the argument is out of range it returns NULL. queryType() The type of this node. queryBody() Used to skip annotations (see below) queryProperty() Does this node have a child which is an attribute that matches a given name. (see below for more about attributes). queryValue() For a no_constant return the value of the constant. It returns NULL otherwise.</p><p>The nodes in the expression graph are created through factory functions. Some of the expression types have specialised functions - e.g., createDataset, createRow, createDictionary, but scalar expressions and actions are normally created with createValue().</p><p>Note: Generally ownership of the arguments to the createX() functions are assumed to be taken over by the newly created node.</p><p>The values of the enumeration constants in node_operator are used to calculate &quot;crcs&quot; which are used to check if the ECL for a query matches, and if disk and index record formats match. It contains quite a few legacy entries no_unusedXXX which can be used for new operators (otherwise new operators must be added to the end).</p><h3 id="ihqlsimplescope" tabindex="-1">IHqlSimpleScope <a class="header-anchor" href="#ihqlsimplescope" aria-label="Permalink to &quot;IHqlSimpleScope&quot;">​</a></h3><p>This interface is implemented by records, and is used to map names to the fields within the records. If a record contains IFBLOCKs then each of the fields in the ifblock is defined in the IHqlSimpleScope for the containing record.</p><h3 id="ihqlscope" tabindex="-1">IHqlScope <a class="header-anchor" href="#ihqlscope" aria-label="Permalink to &quot;IHqlScope&quot;">​</a></h3><p>Normally obtained by calling IHqlExpression::queryScope(). It is primarily used in the parser to resolve fields from within modules.</p><p>The ECL is parsed on demand so as the symbol is looked up it may cause a cascade of ECL to be compiled. The lookup context (HqlLookupContext ) is passed to IHqlScope::lookupSymbol() for several reasons:</p><ul><li>It contains information about the active repository - the source of the ECL which will be dynamically parsed.</li><li>It contains caches of expanded functions - to avoid repeating expansion transforms.</li><li>Some members are used for tracking definitions that are read to build dependency graphs, or archives of submitted queries.</li></ul><p>The interface IHqlScope currently has some members that are used for creation; this should be refactored and placed in a different interface.</p><h3 id="ihqldataset" tabindex="-1">IHqlDataset <a class="header-anchor" href="#ihqldataset" aria-label="Permalink to &quot;IHqlDataset&quot;">​</a></h3><p>This is normally obtained by calling IHqlExpression::queryDataset(). It has shrunk in size over time, and could quite possibly be folded into IHqlExpression with little pain.</p><p>There is a distinction in the code generator between &quot;tables&quot; and &quot;datasets&quot;. A table (IHqlDataset::queryTable()) is a dataset operation that defines a new output record. Any operation that has a transform or record that defines an output record (e.g., PROJECT,TABLE) is a table, whilst those that don&#39;t (e.g., a filter, dedup) are not. There are a few apparent exceptions -e.g., IF (This is controlled by definesColumnList() which returns true the operator is a table.)</p><h3 id="properties-and-attributes" tabindex="-1">Properties and attributes <a class="header-anchor" href="#properties-and-attributes" aria-label="Permalink to &quot;Properties and attributes&quot;">​</a></h3><p>There are two related by slightly different concepts. An attribute refers to the explicit flags that are added to operators (e.g., , LOCAL, KEEP(n) etc. specified in the ECL or some internal attributes added by the code generator). There are a couple of different functions for creating attributes. createExtraAttribute() should be used by default. createAttribute() is reserved for an attribute that never has any arguments, or in unusual situations where it is important that the arguments are never transformed. They are tested using queryAttribute()/hasAttribute() and represented by nodes of kind no_attr/no_expr_attr.</p><p>The term &quot;property&quot; refers to computed information (e.g., record counts) that can be derived from the operator, its arguments and attributes. They are covered in more detail below.</p><h2 id="field-references" tabindex="-1">Field references <a class="header-anchor" href="#field-references" aria-label="Permalink to &quot;Field references&quot;">​</a></h2><p>Fields can be selected from active rows of a dataset in three main ways:</p><ul><li><p>Some operators define LEFT/RIGHT to represent an input or processed dataset. Fields from these active rows are referenced with LEFT.&lt;field-name&gt;. Here LEFT or RIGHT is the &quot;selector&quot;.</p></li><li><p>Other operators use the input dataset as the selector. E.g., myFile(myFile.id != 0). Here the input dataset is the &quot;selector&quot;.</p></li><li><p>Often when the input dataset is used as the selector it can be omitted. E.g., myFile(id != 0). This is implicitly expanded by the PARSER to the second form. A reference to a field is always represented in the expression graph as a node of kind no_select (with createSelectExpr). The first child is the selector, and the second is the field. Needless to say there are some complications...</p></li><li><p>LEFT/RIGHT.</p><p>The problem is that the different uses of LEFT/RIGHT need to be disambiguated since there may be several different uses of LEFT in a query. This is especially true when operations are executed in child queries. LEFT is represented by a node no_left(record, selSeq). Often the record is sufficient to disambiguate the uses, but there are situations where it isn&#39;t enough. So in addition no_left has a child which is a selSeq (selector sequence) which is added as a child attribute of the PROJECT or other operator. At parse time it is a function of the input dataset that is later normalized to a unique id to reduce the transformation work.</p></li><li><p>Active datasets. It is slightly more complicated - because the dataset used as the selector can be any upstream dataset up to the nearest table. So the following ECL code is legal:</p><pre><code>x := DATASET(...)
y := x(x.id != 0);
z := y(x.id != 100);
</code></pre></li></ul><p>Here the reference to x.id in the definition of z is referring to a field in the input dataset.</p><p>Because of these semantics the selector in a normalized tree is actually inputDataset-&gt;queryNormalizedSelector() rather than inputDatset. This function currently returns the table expression node (but it may change in the future see below).</p><h3 id="attribute-new" tabindex="-1">Attribute &quot;new&quot; <a class="header-anchor" href="#attribute-new" aria-label="Permalink to &quot;Attribute \\&quot;new\\&quot;&quot;">​</a></h3><p>In some situations ECL allows child datasets to be treated as a dataset without an explicit NORMALIZE. E.g., EXISTS(myDataset.ChildDataset);</p><p>This is primarily to enable efficient aggregates on disk files to be generated, but it adds some complications with an expression of the form dataset.childdataset.grandchild. E.g.,:</p><pre><code>EXISTS(dataset(EXISTS(dataset.childdataset.grandchild))
</code></pre><p>Or:</p><pre><code>EXISTS(dataset.childdataset(EXISTS(dataset.childdataset.grandchild))
</code></pre><p>In the first example dataset.childdataset within the dataset.childdataset.grandchild is a reference to a dataset that doesn&#39;t have an active cursor and needs to be iterated), whilst in the second it refers to an active cursor.</p><p>To differentiate between the two, all references to fields within datasets/rows that don&#39;t have active selectors have an additional attribute(&quot;new&quot;) as a child of the select. So a no_select with a &quot;new&quot; attribute requires the dataset to be created, one without is a member of an active dataset cursor.</p><p>If you have a nested row, the new attribute is added to the selection from the dataset, rather than the selection from the nested row. The functions queryDatasetCursor() and querySelectorDataset()) are used to help interpret the meaning.</p><p>(An alternative would be to use a different node from no_select - possibly this should be considered - it would be more space efficient.)</p><p>The expression graph generated by the ECL parser doesn&#39;t contain any new attributes. These are added as one of the first stages of normalizing the expression graph. Any code that works on normalized expressions needs to take care to interpret no_selects correctly.</p><h3 id="transforming-selects" tabindex="-1">Transforming selects <a class="header-anchor" href="#transforming-selects" aria-label="Permalink to &quot;Transforming selects&quot;">​</a></h3><p>When an expression graph is transformed and none of the records are changed, the representation of LEFT/RIGHT remains the same. This means any no_select nodes in the expression tree will also stay the same.</p><p>However, if the transform modifies a table (highly likely) it means that the selector for the second form of field selector will also change. Unfortunately this means that transforms often cannot be short-circuited.</p><p>It could significantly reduce the extent of the graph that needs traversing, and the number of nodes replaced in a transformed graph if this could be avoided. One possibility is to use a different value for dataset-&gt;queryNormalizedSelector() using a unique id associated with the table. I think it would be a good long term change, but it would require unique ids (similar to the selSeq) to be added to all table expressions, and correctly preserved by any optimization.</p><h2 id="annotations" tabindex="-1">Annotations <a class="header-anchor" href="#annotations" aria-label="Permalink to &quot;Annotations&quot;">​</a></h2><p>Sometimes it is useful to add information into the expression graph (e.g., symbol names, position information) that doesn&#39;t change the meaning, but should be preserved. Annotations allow information to be added in this way.</p><p>An annotation&#39;s implementation of IHqlExpression generally delegates the majority of the methods through to the annotated expression. This means that most code that interrogates the expression graph can ignore their presence, which simplifies the caller significantly. However transforms need to be careful (see below).</p><p>Information about the annotation can be obtained by calling IHqlExpression:: getAnnotationKind() and IHqlExpression:: queryAnnotation().</p><h2 id="associated-side-effects" tabindex="-1">Associated side-effects <a class="header-anchor" href="#associated-side-effects" aria-label="Permalink to &quot;Associated side-effects&quot;">​</a></h2><p>In legacy ECL you will see code like the following::</p><pre><code>EXPORT a(x) := FUNCTION
   Y := F(x);
   OUTPUT(Y);
   RETURN G(Y);
END;
</code></pre><p>The assumption is that whenever a(x) is evaluated the value of Y will be output. However that doesn&#39;t particularly fit in with a declarative expression graph. The code generator creates a special node (no_compound) with child(0) as the output action, and child(1) as the value to be evaluated (g(Y)).</p><p>If the expression ends up being included in the final query then the action will also be included (via the no_compound). At a later stage the action is migrated to a position in the graph where actions are normally evaluated.</p><h2 id="derived-properties" tabindex="-1">Derived properties <a class="header-anchor" href="#derived-properties" aria-label="Permalink to &quot;Derived properties&quot;">​</a></h2><p>There are many pieces of information that it is useful to know about a node in the expression graph - many of which would be expensive to recomputed each time there were required. Eclcc has several mechanisms for caching derived information so it is available efficiently.</p><ul><li><p>Boolean flags - getInfoFlags()/getInfoFlags2().</p><p>There are many Boolean attributes of an expression that are useful to know - e.g., is it constant, does it have side-effects, does it reference any fields from a dataset etc. etc. The bulk of these are calculated and stored in a couple of members of the expression class. They are normally retrieved via accessor functions e.g., containsAssertKeyed(IHqlExpression*).</p></li><li><p>Active datasets - gatherTablesUsed().</p><p>It is very common to want to know which datasets an expression references. This information is calculated and cached on demand and accessed via the IHqlExpression::gatherTablesUsed() functions. There are a couple of other functions IHqlExpression::isIndependentOfScope() and IHqlExpression::usesSelector() which provide efficient functions for common uses.</p></li><li><p>Information stored in the type.</p><p>Currently datasets contain information about sort order, distribution and grouping as part of the expression type. This information should be accessed through the accessor functions applied to the expression (e.g., isGrouped(expr)). At some point in the future it is planned to move this information as a general derived property (see next).</p></li><li><p>Other derived property.</p><p>There is a mechanism (in hqlattr) for calculating and caching an arbitrary derived property of an expression. It is currently used for number of rows, location-independent representation, maximum record size etc. . There are typically accessor functions to access the cached information (rather than calling the underlying IHqlExpression::queryAttribute() function).</p></li><li><p>Helper functions.</p><p>Some information doesn&#39;t need to be cached because it isn&#39;t expensive to calculate, but rather than duplicating the code, a helper function is provided. E.g., queryOriginalRecord() and hasUnknownTransform(). They are not part of the interface because the number would make the interface unwieldy and they can be completely calculated from the public functions.</p><p>However, it can be very hard to find the function you are looking for, and they would greatly benefit from being grouped e.g., into namespaces.</p></li></ul><h2 id="transformations" tabindex="-1">Transformations <a class="header-anchor" href="#transformations" aria-label="Permalink to &quot;Transformations&quot;">​</a></h2><p>One of the key processes in eclcc is walking and transforming the expression graphs. Both of these are covered by the term transformations. One of the key things to bear in mind is that you need to walk the expression graph as a graph, not as a tree. If you have already examined a node once you shouldn&#39;t repeat the work - otherwise the execution time may be exponential with node depth.</p><p>Other things to bear in mind</p><ul><li>If a node isn&#39;t modified don&#39;t create a new one - return a link to the old one.</li><li>You generally need to walk the graph and gather some information before creating a modified graph. Sometimes creating a new graph can be short-circuited if no changes will be required.</li><li>Sometimes you can be tempted to try and short-circuit transforming part of a graph (e.g., the arguments to a dataset activity), but because of the way references to fields within dataset work that often doesn&#39;t work.</li><li>If an expression is moved to another place in the graph, you need to be very careful to check if the original context was conditional and that the new context is not.</li><li>The meaning of expressions can be context dependent. E.g., References to active datasets can be ambiguous.</li><li>Never walk the expressions as a tree, always as a graph!</li><li>Be careful with annotations.</li></ul><p>It is essential that an expression that is used in different contexts with different annotations (e.g., two different named symbols) is consistently transformed. Otherwise it is possible for a graph to be converted into a tree. E.g.,:</p><pre><code>A := x; B := x; C = A + B;
</code></pre><p>must not be converted to:</p><pre><code>A&#39; := x&#39;; B&#39; := X&#39;&#39;;  C&#39; := A&#39; + B&#39;;
</code></pre><p>For this reason most transformers will check if expr-&gt;queryBody() matches expr, and if not will transform the body (the unannotated expression), and then clone any annotations.</p><p>Some examples of the work done by transformations are:</p><ul><li>Constant folding.</li><li>Expanding function calls.</li><li>Walking the graph and reporting warnings.</li><li>Optimizing the order and removing redundant activities.</li><li>Reducing the fields flowing through the generated graph.</li><li>Spotting common sub expressions.</li><li>Calculating the best location to evaluate an expression (e.g., globally instead of in a child query).</li><li>Many, many others.</li></ul><p>Some more details on the individual transforms are given below..</p><h1 id="key-stages" tabindex="-1">Key Stages <a class="header-anchor" href="#key-stages" aria-label="Permalink to &quot;Key Stages&quot;">​</a></h1><h2 id="parsing" tabindex="-1">Parsing <a class="header-anchor" href="#parsing" aria-label="Permalink to &quot;Parsing&quot;">​</a></h2><p>The first job of eclcc is to parse the ECL into an expression graph. The source for the ECL can come from various different sources (archive, source files, remote repository). The details are hidden behind the IEclSource/IEclSourceCollection interfaces. The createRepository() function is then used to resolve and parse the various source files on demand.</p><p>Several things occur while the ECL is being parsed:</p><ul><li><p>Function definitions are expanded inline.</p><p>A slightly unusual behaviour. It means that the expression tree is a fully expanded expression -which is better suited to processing and optimizing.</p></li><li><p>Some limited constant folding occurs.</p><p>When a function is expanded, often it means that some of the test conditions are always true/false. To reduce the transformations the condition may be folded early on.</p></li><li><p>When a symbol is referenced from another module this will recursively cause the ECL for that module (or definition within that module) to be parsed.</p></li><li><p>Currently the semantic checking is done as the ECL is parsed.</p><p>If we are going to fully support template functions and delayed expansion of functions this will probably have to change so that a syntax tree is built first, and then the semantic checking is done later.</p></li></ul><h2 id="normalizing" tabindex="-1">Normalizing <a class="header-anchor" href="#normalizing" aria-label="Permalink to &quot;Normalizing&quot;">​</a></h2><p>There are various problems with the expression graph that comes out of the parser:</p><ul><li><p>Records can have values as children (e.g., { myField := infield.value} ), but it causes chaos if record definitions can change while other transformations are going on. So the normalization removes values from fields.</p></li><li><p>Some activities use records to define the values that output records should contain (e.g., TABLE). These are now converted to another form (e.g., no_newusertable).</p></li><li><p>Sometimes expressions have multiple definition names. Symbols and annotations are rationalized and commoned up to aid commoning up other expressions.</p></li><li><p>Some PATTERN definitions are recursive by name. They are resolved to a form that works if all symbols are removed.</p></li><li><p>The CASE/MAP representation for a dataset/action is awkward for the transforms to process. They are converted to nested Ifs.</p><p>(At some point a different representation might be a good idea.)</p></li><li><p>EVALUATE is a weird syntax. Instances are replaced with equivalent code which is much easier to subsequently process.</p></li><li><p>The datasets used in index definitions are primarily there to provide details of the fields. The dataset itself may be very complex and may not actually be used. The dataset input to an index is replaced with a dummy &quot;null&quot; dataset to avoid unnecessary graph transforming, and avoid introducing any additional incorrect dependencies.</p></li></ul><h2 id="scope-checking" tabindex="-1">Scope checking <a class="header-anchor" href="#scope-checking" aria-label="Permalink to &quot;Scope checking&quot;">​</a></h2><p>Generally if you use LEFT/RIGHT then the input rows are going to be available wherever they are used. However if they are passed into a function, and that function uses them inside a definition marked as global then that is invalid (since by definition global expressions don&#39;t have any context).</p><p>Similarly if you use syntax &lt;dataset&gt;.&lt;field&gt;, its validity and meaning depends on whether &lt;dataset&gt; is active. The scope transformer ensures that all references to fields are legal, and adds a &quot;new&quot; attribute to any no_selects where it is necessary.</p><h2 id="constant-folding-foldhqlexpression" tabindex="-1">Constant folding: foldHqlExpression <a class="header-anchor" href="#constant-folding-foldhqlexpression" aria-label="Permalink to &quot;Constant folding: foldHqlExpression&quot;">​</a></h2><p>This transform simplifies the expression tree. Its aim is to simplify scalar expressions, and dataset expressions that are valid whether or not the nodes are shared. Some examples are:</p><ul><li>1 + 2 =&gt; 3 and any other operation on scalar constants.</li><li>IF(true, x, y) =&gt; x</li><li>COUNT(&lt;empty-dataset&gt;) =&gt; 0</li><li>IF (a = b, &#39;c&#39;, &#39;d&#39;) = &#39;d&#39; =&gt; IF(a=b, false, true) =&gt; a != b</li><li>Simplifying sorts, projects filters on empty datasets</li></ul><p>Most of the optimizations are fairly standard, but a few have been added to cover more esoteric examples which have occurred in queries over the years.</p><p>This transform also supports the option to percolate constants through the graph. E.g., if a project assigns the value 3 to a field, it can substitute the value 3 wherever that field is used in subsequent activities. This can often lead to further opportunities for constant folding (and removing fields in the implicit project).</p><h2 id="expression-optimizer-optimizehqlexpression" tabindex="-1">Expression optimizer: optimizeHqlExpression <a class="header-anchor" href="#expression-optimizer-optimizehqlexpression" aria-label="Permalink to &quot;Expression optimizer: optimizeHqlExpression&quot;">​</a></h2><p>This transformer is used to simplify, combine and reorder dataset expressions. The transformer takes care to count the number of times each expression is used to ensure that none of the transformations cause duplication. E.g., swapping a filter with a sort is a good idea, but if there are two filters of the same sort and they are both swapped you will now be duplicating the sort.</p><p>Some examples of the optimizations include:</p><ul><li>COUNT(SORT(x)) =&gt; COUNT(x)</li><li>Moving filters over projects, joins, sorts.</li><li>Combining adjacent projects, projects and joins.</li><li>Removing redundant sorts or distributes</li><li>Moving filters from JOINs to their inputs.</li><li>Combining activities e.g., CHOOSEN(SORT(x)) =&gt; TOPN(x)</li><li>Sometimes moving filters into IFs</li><li>Expanding out a field selected from a single row dataset.</li><li>Combine filters and projects into compound disk read operations.</li></ul><h2 id="implicit-project-insertimplicitprojects" tabindex="-1">Implicit project: insertImplicitProjects <a class="header-anchor" href="#implicit-project-insertimplicitprojects" aria-label="Permalink to &quot;Implicit project: insertImplicitProjects&quot;">​</a></h2><p>ECL tends to be written as general purpose definitions which can then be combined. This can lead to potential inefficiencies - e.g., one definition may summarise some data in 20 different ways, this is then used by another definition which only uses a subset of those results. The implicit project transformer tracks the data flow at each point through the expression graph, and removes any fields that are not required.</p><p>This often works in combination with the other optimizations. For instance the constant percolation can remove the need for fields, and removing fields can sometimes allow a left outer join to be converted to a project.</p><h1 id="workunits" tabindex="-1">Workunits <a class="header-anchor" href="#workunits" aria-label="Permalink to &quot;Workunits&quot;">​</a></h1><h2 id="is-this-the-correct-term-should-it-be-a-query-this-should-really-be-independent-of-this-document" tabindex="-1">is this the correct term? Should it be a query? This should really be independent of this document...) <a class="header-anchor" href="#is-this-the-correct-term-should-it-be-a-query-this-should-really-be-independent-of-this-document" aria-label="Permalink to &quot;is this the correct term? Should it be a query? This should really be independent of this document\\...)&quot;">​</a></h2><p>The code generator ultimately creates workunits. A workunit completely describes a generated query. It consists of two parts. There is an xml component - this contains the workflow information, the various execution graphs, and information about options. It also describes which inputs can be supplied to the query and what results are generated. The other part is the generated shared object compiled from the generated C++. This contains functions and classes that are used by the engines to execute the queries. Often the xml is compressed and stored as a resource within the shared object -so the shared object contains a complete workunit.</p><h2 id="workflow" tabindex="-1">Workflow <a class="header-anchor" href="#workflow" aria-label="Permalink to &quot;Workflow&quot;">​</a></h2><p>The actions in a workunit are divided up into individual workflow items. Details of when each workflow item is executed, what its dependencies are stored in the &lt;Workflow&gt; section of the xml. The generated code also contains a class definition, with a method perform() which is used to execute the actions associated with a particular workflow item. (The class instances are created by calling the exported createProcess() factory function).</p><p>The generated code for an individual workflow item will typically call back into the engine at some point to execute a graph.</p><h2 id="graph" tabindex="-1">Graph <a class="header-anchor" href="#graph" aria-label="Permalink to &quot;Graph&quot;">​</a></h2><p>The activity graphs are stored in the xml. The graph contains details of which activities are required, how those activities link together, what dependencies there are between the activities. For each activity it might contain the following information:</p><ul><li>A unique id.</li><li>The &quot;kind&quot; of the activity (from enum ThorActivityKind in eclhelper.hpp)</li><li>The ECL that created the activity.</li><li>Name of the original definition</li><li>Location (e.g., file, line number) of the original ECL.</li><li>Information about the record size, number of rows, sort order etc.</li><li>Hints which control options for a particular activity (e.g,, the number of threads to use while sorting).</li><li>Record counts and stats once the job has executed.</li></ul><p>Each activity in a graph also has a corresponding helper class instance in the generated code. (The name of the class is cAc followed by the activity number, and the exported factory method is fAc followed by the activity number.) These classes implement the interfaces defined in eclhelper.hpp.</p><p>The engine uses the information from the xml to produce a graph of activities that need to be executed. It has a general purpose implementation of each activity kind, and it uses the class instance to tailor that general activity to the specific use e.g., what is the filter condition, what fields are set up, what is the sort order?</p><h2 id="inputs-and-results" tabindex="-1">Inputs and Results <a class="header-anchor" href="#inputs-and-results" aria-label="Permalink to &quot;Inputs and Results&quot;">​</a></h2><p>The workunit xml contains details of what inputs can be supplied when that workunit is run. These correspond to STORED definitions in the ECL. The result xml also contains the schema for the results that the workunit will generate.</p><p>Once an instance of the workunit has been run, the values of the results may be written back into dali&#39;s copy of the workunit so they can be retrieved and displayed.</p><h2 id="generated-code" tabindex="-1">Generated code <a class="header-anchor" href="#generated-code" aria-label="Permalink to &quot;Generated code&quot;">​</a></h2><p>Aims for the generated C++ code:</p><ul><li><p>Minimal include dependencies.</p><p>Compile time is an issue - especially for small on-demand queries. To help reduce compile times (and dependencies with the rest of the system) the number of header files included by the generated code is kept to a minimum. In particular references to jlib, boost and icu are kept within the implementation of the runtime functions, and are not included in the public dependencies.</p></li><li><p>Thread-safe.</p><p>It should be possible to use the members of an activity helper from multiple threads without issue. The helpers may contain some context dependent state, so different instances of the helpers are needed for concurrent use from different contexts (e.g., expansions of a graph.)</p></li><li><p>Concise.</p><p>The code should be broadly readable, but the variable names etc. are chosen to generate compact code.</p></li><li><p>Functional.</p><p>Generally the generated code assigns to a variable once, and doesn&#39;t modify it afterwards. Some assignments may be conditional, but once the variable is evaluated it isn&#39;t updated. (There are of course a few exceptions - e.g., dataset iterators)</p></li></ul><h1 id="implementation-details" tabindex="-1">Implementation details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation details&quot;">​</a></h1><p>First a few pointers to help understand the code within eclcc:</p><ul><li><p>It makes extensive use of link counting. You need understand that concept to get very far.</p></li><li><p>If something is done more than once then that is generally split into a helper function.</p><p>The helper functions aren&#39;t generally added to the corresponding interface (e.g., IHqlExpression) because the interface would become bloated. Instead they are added as global functions. The big disadvantage of this approach is they can be hard to find. Even better would be for them to be rationalised and organised into namespaces.</p></li><li><p>The code is generally thread-safe unless there would be a significant performance implication. In generally all the code used by the parser for creating expressions is thread safe. Expression graph transforms are thread-safe, and can execute in parallel if a constant (NUM_PARALLEL_TRANSFORMS) is increased. The data structures used to represent the generated code are NOT thread-safe.</p></li><li><p>Much of the code generation is structured fairly procedurally, with classes used to process the stages within it.</p></li><li><p>There is a giant &quot;God&quot; class HqlCppTranslator - which could really do with refactoring.</p></li></ul><h2 id="parser" tabindex="-1">Parser <a class="header-anchor" href="#parser" aria-label="Permalink to &quot;Parser&quot;">​</a></h2><p>The eclcc parser uses the standard tools bison and flex to process the ECL and convert it to a</p><p>: expression graph. There are a couple of idiosyncrasies with the way it is implemented.</p><ul><li><p>Macros with fully qualified scope.</p><p>Slightly unusually macros are defined in the same way that other definitions are - in particular to can have references to macros in other modules. This means that there are references to macros within the grammar file (instead of being purely handled by a pre-processor). It also means the lexer keeps an active stack of macros being processed.</p></li><li><p>Attributes on operators.</p><p>Many of the operators have optional attributes (e.g., KEEP, INNER, LOCAL, ...). If these were all reserved words it would remove a significant number of keywords from use as symbols, and could also mean that when a new attribute was added it broke existing code. To avoid this the lexer looks ahead in the parser tables (by following the potential reductions) to see if the token really could come next. If it can&#39;t then it isn&#39;t reserved as a symbol.</p></li></ul><h1 id="generated-code-1" tabindex="-1">Generated code <a class="header-anchor" href="#generated-code-1" aria-label="Permalink to &quot;Generated code&quot;">​</a></h1><p>As the workunit is created the code generator builds up the generated code and the xml for the workunit. Most of the xml generation is encapsulated within the IWorkUnit interface. The xml for the graphs is created in an IPropertyTree, and added to the workunit as a block.</p><h2 id="c-output-structures" tabindex="-1">C++ Output structures <a class="header-anchor" href="#c-output-structures" aria-label="Permalink to &quot;C++ Output structures&quot;">​</a></h2><p>The C++ generation is ultimately controlled by some template files (thortpl.cpp). The templates are plain text and contain references to allow named sections of code to be expanded at particular points.</p><p>The code generator builds up some structures in memory for each of those named sections. Once the generation is complete some peephole optimization is applied to the code. This structure is walked to expand each named section of code as required.</p><p>The BuildCtx class provides a cursor into that generated C++. It will either be created for a given named section, or more typically from another BuildCtx. It has methods for adding the different types of statements. Some are simple (e.g., addExpr()), whilst some create a compound statement (e.g., addFilter). The compound statements change the active selector so any new statements are added within that compound statement.</p><p>As well as building up a tree of expressions, this data structure also maintains a tree of associations. For instance when a value is evaluated and assigned to a temporary variable, the logical value is associated with that temporary. If the same expression is required later, the association is matched, and the temporary value is used instead of recalculating it. The associations are also used to track the active datasets, classes generated for row-meta information, activity classes etc. etc.</p><h2 id="activity-helper" tabindex="-1">Activity Helper <a class="header-anchor" href="#activity-helper" aria-label="Permalink to &quot;Activity Helper&quot;">​</a></h2><p>Each activity in an expression graph will have an associated class generated in the C++. Each different activity kind expects a helper that implements a particular IHThorArg interface. E.g., a sort activity of kind TAKsort requires a helper that implements IHThorSortArg. The associated factory function is used to create instances of the helper class.</p><p>The generated class might take one of two forms:</p><ul><li>A parameterised version of a library class. These are generated for simple helpers that don&#39;t have many variations (e.g., CLibrarySplitArg for TAKsplit), or for special cases that occur very frequently (CLibraryWorkUnitReadArg for internal results).</li><li>A class derived from a skeleton implementation of that helper (typically CThorXYZ implementing interface IHThorXYZ). The base class has default implementations of some of the functions, and any exceptions are implemented in the derived class.</li></ul><h2 id="meta-helper" tabindex="-1">Meta helper <a class="header-anchor" href="#meta-helper" aria-label="Permalink to &quot;Meta helper&quot;">​</a></h2><p>This is a class that is used by the engines to encapsulate all the information about a single row -e.g., the format that each activity generates. It is an implementation of the IOutputMeta interface. It includes functions to</p><ul><li>Return the size of the row.</li><li>Serialize and deserialize from disk.</li><li>Destroy and clean up row instances.</li><li>Convert to xml.</li><li>Provide information about the contained fields.</li></ul><h2 id="building-expressions" tabindex="-1">Building expressions <a class="header-anchor" href="#building-expressions" aria-label="Permalink to &quot;Building expressions&quot;">​</a></h2><p>The same expression nodes are used for representing expressions in the generated C++ as the original ECL expression graph. It is important to keep track of whether an expression represents untranslated ECL, or the &quot;translated&quot; C++. For instance ECL has 1 based indexes, while C++ is zero based. If you processed the expression x[1] it might get translated to x[0] in C++. Translating it again would incorrectly refer to x[-1].</p><p>There are two key classes used while building the C++ for an ECL expression:</p><p>CHqlBoundExpr.</p><blockquote><p>This represents a value that has been converted to C++. Depending on the type, one or more of the fields will be filled in.</p></blockquote><p>CHqlBoundTarget.</p><blockquote><p>This represents the target of an assignment -C++ variable(s) that are going to be assigned the result of evaluating an expression. It is almost always passed as a const parameter to a function because the target is well-defined and the function needs to update that target.</p><p>A C++ expression is sometimes converted back to an ECL pseudo-expression by calling getTranslatedExpr(). This creates an expression node of kind no_translated to indicate the child expression has already been converted.</p></blockquote><h3 id="scalar-expressions" tabindex="-1">Scalar expressions <a class="header-anchor" href="#scalar-expressions" aria-label="Permalink to &quot;Scalar expressions&quot;">​</a></h3><p>The generation code for expressions has a hierarchy of calls. Each function is there to allow optimal code to be generated - e.g., not creating a temporary variable if none are required. A typical flow might be:</p><ul><li><p>buildExpr(ctx, expr, bound).</p><p>Evaluate the ecl expression &quot;expr&quot; and save the C++ representation in the class bound. This might then call through to...</p></li><li><p>buildTempExpr(ctx, expr, bound);</p><p>Create a temporary variable, and evaluate expr and assign it to that temporary variable.... Which then calls.</p></li><li><p>buildExprAssign(ctx, target, expr);</p><p>evaluate the expression, and ensure it is assigned to the C++ target &quot;target&quot;.</p><p>The default implementation might be to call buildExpr....</p></li></ul><p>An operator must either be implemented in buildExpr() (calling a function called doBuildExprXXX) or in buildExprAssign() (calling a function called doBuildAssignXXX). Some operators are implemented in both places if there are different implementations that would be more efficient in each context.</p><p>Similarly there are several different assignment functions:</p><ul><li>buildAssign(ctx, &lt;ecl-target&gt;, &lt;ecl-value&gt;);</li><li>buildExprAssign(ctx, &lt;c++-target&gt;, &lt;ecl-value&gt;);</li><li>assign(ctx, &lt;C++target&gt;, &lt;c++source&gt;)</li></ul><p>The different varieties are there depending on whether the source value or targets have already been translated. (The names could be rationalised!)</p><h3 id="datasets" tabindex="-1">Datasets <a class="header-anchor" href="#datasets" aria-label="Permalink to &quot;Datasets&quot;">​</a></h3><p>Most dataset operations are only implemented as activities (e.g., PARSE, DEDUP). If these are used within a transform/filter then eclcc will generate a call to a child query. An activity helper for the appropriate operation will then be generated.</p><p>However a subset of the dataset operations can also be evaluated inline without calling a child query. Some examples are filters, projects, and simple aggregation. It removes the overhead of the child query call in the simple cases, and often generates more concise code.</p><p>When datasets are evaluated inline there is a similar hierarchy of function calls:</p><ul><li><p>buildDatasetAssign(ctx, target, expr);</p><p>Evaluate the dataset expression, and assign it to the target (a builder interface). This may then call....</p></li><li><p>buildIterate(ctx, expr)</p><p>Iterate through each of the rows in the dataset expression in turn. Which may then call...</p></li><li><p>buildDataset(ctx, expr, target, format)</p><p>Build the entire dataset, and return it as a single value.</p></li></ul><p>Some of the operations (e.g., aggregating a filtered dataset) can be done more efficiently by summing and filtering an iterator, than forcing the filtered dataset to be evaluated first.</p><h3 id="dataset-cursors" tabindex="-1">Dataset cursors <a class="header-anchor" href="#dataset-cursors" aria-label="Permalink to &quot;Dataset cursors&quot;">​</a></h3><p>The interface IHqlCppDatasetCursor allows the code generator to iterate through a dataset, or select a particular element from a dataset. It is used to hide the different representation of datasets, e.g.,</p><ul><li>Blocked - the rows are in a contiguous block of memory appended one after another.</li><li>Array - the dataset is represented by an array of pointers to the individual rows.</li><li>Link counted - similar to array, but each element is also link counted.</li><li>Nested. Sometimes the cursor may iterate through multiple levels of child datasets.</li></ul><p>Generally rows that are serialized (e.g., on disk) are in blocked format, and they are stored as link counted rows in memory.</p><h3 id="field-access-classes" tabindex="-1">Field access classes <a class="header-anchor" href="#field-access-classes" aria-label="Permalink to &quot;Field access classes&quot;">​</a></h3><p>The IReferenceSelector interface and the classes in hqltcppc[2] provide an interface for getting and setting values within a row of a dataset. They hide the details of the layout - e.g., csv/xml/raw data, and the details of exactly how each type is represented in the row.</p><h3 id="key-filepos-weirdness" tabindex="-1">Key filepos weirdness <a class="header-anchor" href="#key-filepos-weirdness" aria-label="Permalink to &quot;Key filepos weirdness&quot;">​</a></h3><p>The current implementation of keys in HPCC uses a format which uses a separate 8 byte integer field which was historically used to store the file position in the original file. Other complications are that the integer fields are stored big-endian, and signed integer values are biased.</p><p>This introduces some complication in the way indexes are handled. You will often find that the logical index definition is replaced with a physical index definition, followed by a project to convert it to the logical view. A similar process occurs for disk files to support VIRTUAL(FILEPOSITION) etc.</p><h1 id="source-code" tabindex="-1">Source code <a class="header-anchor" href="#source-code" aria-label="Permalink to &quot;Source code&quot;">​</a></h1><p>The following are the main directories used by the ecl compiler.</p><hr><p>Directory Contents</p><hr><p>rtl/eclrtpl Template text files used to generate the C++ code</p><p>rtl/include Headers that declare interfaces implemented by the generated code</p><p>common/deftype Interfaces and classes for scalar types and values.</p><p>common/workunit Code for managing the representation of a work unit.</p><p>ecl/hql Classes and interfaces for parsing and representing an ecl expression graph</p><p>ecl/hqlcpp Classes for converting an expression graph to a work unit (and C++)</p><h2 id="ecl-eclcc-the-executable-which-ties-everything-together" tabindex="-1">ecl/eclcc The executable which ties everything together. <a class="header-anchor" href="#ecl-eclcc-the-executable-which-ties-everything-together" aria-label="Permalink to &quot;ecl/eclcc         The executable which ties everything together.&quot;">​</a></h2><h1 id="challenges" tabindex="-1">Challenges <a class="header-anchor" href="#challenges" aria-label="Permalink to &quot;Challenges&quot;">​</a></h1><h2 id="from-declarative-to-imperative-1" tabindex="-1">From declarative to imperative <a class="header-anchor" href="#from-declarative-to-imperative-1" aria-label="Permalink to &quot;From declarative to imperative&quot;">​</a></h2><p>As mentioned at the start of this document, one of the main challenges with eclcc is converting the declarative ECL code into imperative C++ code. The direction we are heading in is to allow the engines to support more lazy-evaluation so possibly in this instance to evaluate it the first time it is used (although that may potentially be much less efficient). This will allow the code generator to relax some of its current assumptions.</p><p>There are several example queries which are already producing pathological behaviour from eclcc, causing it to generate C++ functions which are many thousands of lines long.</p><h2 id="the-parser" tabindex="-1">The parser <a class="header-anchor" href="#the-parser" aria-label="Permalink to &quot;The parser&quot;">​</a></h2><p>Currently the grammar for the parser is too specialised. In particular the separate productions for expression, datasets, actions cause problems - e.g., it is impossible to properly allow sets of datasets to be treated in the same way as other sets.</p><p>The semantic checking (and probably semantic interpretation) is done too early. Really the parser should build up a syntax tree, and then disambiguate it and perform the semantic checks on the syntax tree.</p><p>The function calls should probably be expanded later than they are. I have tried in the past and hit problems, but I can&#39;t remember all the details. Some are related to the semantic checking.</p>`,223)]))}const f=t(r,[["render",s]]);export{u as __pageData,f as default};
