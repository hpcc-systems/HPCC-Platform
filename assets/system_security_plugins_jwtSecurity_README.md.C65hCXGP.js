import{_ as t,a as o,o as i,ag as s}from"./chunks/framework.Do1Zayaf.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"system/security/plugins/jwtSecurity/README.md","filePath":"system/security/plugins/jwtSecurity/README.md","lastUpdated":1771585025000}'),a={name:"system/security/plugins/jwtSecurity/README.md"};function n(r,e,l,d,c,h){return i(),o("div",null,e[0]||(e[0]=[s(`<h2 id="jwt-authorization-security-manager-plugin" tabindex="-1">JWT Authorization Security Manager Plugin <a class="header-anchor" href="#jwt-authorization-security-manager-plugin" aria-label="Permalink to &quot;JWT Authorization Security Manager Plugin&quot;">​</a></h2><p>The purpose of this plugin is to provide authentication and authorization capabilities for HPCC Systems users, with the credentials passed via valid JWT tokens.</p><p>The intention is to adhere as closely as possibly to the OpenID Connect (OIC) specification, which is a simple identity layer on top of the OAuth 2.0 protocol, while maintaining compatibility with the way HPCC Systems performs authentication and authorization today. More information about the OpenID Connect specification can be found at <a href="https://openid.net/specs/openid-connect-core-1_0.html" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html</a>.</p><p>One of the big advantages of OAuth 2.0 and OIC is that the service (in this case, HPCC Systems) never interacts with the user directly. Instead, authentication is performed by a trusted third party and the (successful) results are passed to the service in the form of a verifiable encoded token.</p><p>Unfortunately, HPCC Systems does not support the concept of third-party verification. It assumes that users -- really, any client application that operates as a user, including things like IDEs -- will submit username/password credentials for authentication. Until that is changed, HPCC Systems won&#39;t be able to fully adhere to the OIC specification.</p><p>We can, however, implement <em>most</em> of the specification. That is what this plugin does.</p><p>NOTE: This plugin is not available in a Windows build.</p><h3 id="code-documentation" tabindex="-1">Code Documentation <a class="header-anchor" href="#code-documentation" aria-label="Permalink to &quot;Code Documentation&quot;">​</a></h3><p>Doxygen (<a href="https://www.doxygen.nl/index.html" target="_blank" rel="noreferrer">https://www.doxygen.nl/index.html</a>) can be used to create nice HTML documentation for the code. Call/caller graphs are also generated for functions if you have dot (<a href="https://www.graphviz.org/download/" target="_blank" rel="noreferrer">https://www.graphviz.org/download/</a>) installed and available on your path.</p><p>Assuming <code>doxygen</code> is on your path, you can build the documentation via:</p><pre><code>cd system/security/plugins/jwtSecurity
doxygen Doxyfile
</code></pre><p>The documentation can then be accessed via <code>docs/html/index.html</code>.</p><h3 id="theory-of-operations" tabindex="-1">Theory of Operations <a class="header-anchor" href="#theory-of-operations" aria-label="Permalink to &quot;Theory of Operations&quot;">​</a></h3><p>The plugin is called by the HPCC Systems <code>esp</code> process when a user needs to be authenticated. That call will contain the user&#39;s username and either a reference to a session token or a password. The session token is present only for already-authenticated users.</p><p>If the session token is not present, the plugin will call a <code>JWT login service</code> (also known as a JWT login endpoint) with the username and password, plus a nonce value for additional security.</p><p>That service authenticates the username/password credentials. If everything is good, the service constructs an OIC-compatible token that includes authorization information for that user and returns it to the plugin. The token is validated according to the OIC specification, including signature verification.</p><p>Note that token signature verification requires an additional piece of information. Tokens can be signed with a hash-based algorithm or with a public key-based algorithm (the actual algorithm used is determined by the JWT service). To verify either kind of algorithm, the plugin will need either the secret hash key or the public key that matches what the JWT service used. That key is read by the plugin from a file, and the file is determined by a configuration setting (see below). It is possible to change the contents of that file without restarting the esp process. Note, though, that the plugin may not notice that the file&#39;s contents have changed for several seconds (changes do not <strong>immediately</strong> take effect).</p><p>HPCC Systems uses a well-defined authorization scheme, originally designed around an LDAP implementation. That scheme is represented within the token as JWT claims. This plugin will unpack those claims and map to the authorization checks already in place within the HPCC Systems platform.</p><p>OIC includes the concept of refresh tokens. Refresh tokens enable a service to re-authorize an existing token without user intervention. Re-authorization typically happens due to a token expiring. Tokens should have a relatively short lifetime -- e.g. 15-30 minutes -- to promote good security and also give administrators the ability to modify a user&#39;s authorization while the user is logged in. This plugin fully supports refresh tokens by validating token lifetime at every authorization check and calling a <code>JWT refresh service</code> (also known as a JWT refresh endpoint) when needed. This largely follows the OIC specification.</p><h3 id="deviations-from-oic-specification" tabindex="-1">Deviations From OIC Specification <a class="header-anchor" href="#deviations-from-oic-specification" aria-label="Permalink to &quot;Deviations From OIC Specification&quot;">​</a></h3><ul><li>Initial authentication: As stated above, the <code>esp</code> process will gather the username/password credentials instead of a third party, then send those credentials off to another service. In a true OIC configuration, the client process (the <code>esp</code> process) never sees user credentials and relies on an external service to gather them from the user.</li><li>The request made to the <code>JWT login service</code> is a POST HTTP or HTTPS call (depending on your configuration) containing four items in JSON format; example:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>	{</span></span>
<span class="line"><span>		&quot;username&quot;: &quot;my_username&quot;,</span></span>
<span class="line"><span>		&quot;password&quot;: &quot;my_password&quot;,</span></span>
<span class="line"><span>		&quot;client_id&quot;: &quot;https://myhpcccluster.com&quot;,</span></span>
<span class="line"><span>		&quot;nonce&quot;: &quot;hf674DTRMd4Z1s&quot;</span></span>
<span class="line"><span>	}</span></span></code></pre></div><ul><li>The <code>JWT login service</code> should reply with an OIC-compatible JSON-formatted reply. See <a href="https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse</a> for an example of a successful authentication and <a href="https://openid.net/specs/openid-connect-core-1_0.html#TokenErrorResponse" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html#TokenErrorResponse</a> for an example of an error response. The token itself is comprised of several attributes, followed by HPCC Systems-specific claims; see <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a> (all required fields are indeed required, plus the nonce field). <ul><li>Note that for success replies, the <code>access_token</code> and <code>expires_in</code> values are ignored by this plugin.</li></ul></li><li>If the token expires, the plugin will call the <code>JWT refresh service</code> to request a new token. This follows <a href="https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens" target="_blank" rel="noreferrer">https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens</a> except that the <code>client_secret</code> and <code>scope</code> fields in the request are omitted.</li></ul><h3 id="implications-of-deviations" tabindex="-1">Implications of Deviations <a class="header-anchor" href="#implications-of-deviations" aria-label="Permalink to &quot;Implications of Deviations&quot;">​</a></h3><p>The most obvious outcome of this implementation is that a custom service/endpoint needs to be available. Or rather two services: One to handle the initial user login and one to handle token refreshes. Neither service <em>precisely</em> handles requests and replies in an OIC-compatible way, but the tokens themselves <em>are</em> OIC-compatible, which is good. That allows you to use third-party JWT libraries to construct and validate those tokens.</p><h3 id="hpcc-systems-configuration-notes" tabindex="-1">HPCC Systems Configuration Notes <a class="header-anchor" href="#hpcc-systems-configuration-notes" aria-label="Permalink to &quot;HPCC Systems Configuration Notes&quot;">​</a></h3><p>Several items must be defined in the platform&#39;s configuration. Within configmgr, the <code>jwtsecmgr</code> Security Manager plugin must be added as a component and then modified according to your environment:</p><ul><li>The URL or unique name of this HPCC Systems cluster, used as the <code>client_id</code> in token requests</li><li>Full URL to the <code>JWT Login Endpoint</code> (should be HTTPS, but not required)</li><li>Full URL to the <code>JWT Refresh Endpoint</code> (should be HTTPS, but not required)</li><li>Boolean indicating whether to accept self-signed certificates for those endpoints; defaults to false</li><li>Secrets vault key/name or subdirectory under /opt/HPCCSystems/secrets/esp in which the JWT key used for the chosen signature algorithm is stored; defaults to &quot;jwt-security&quot;</li><li>Default permission access level (either &quot;Full&quot; or &quot;None&quot;); defaults to &quot;Full&quot;</li><li>Default workunit scope access level (either &quot;Full&quot; or &quot;None&quot;); defaults to &quot;Full&quot;</li><li>Default file scope access level (either &quot;Full&quot; or &quot;None&quot;); defaults to &quot;Full&quot;</li></ul><p>Only the first three items have no default values and must be supplied.</p><p>Once the <code>jwtseccmgr</code> component is added, you have to tell other parts of the system to use the plugin. For user authentication and permissions affecting features and workunit scopes, you need to add the plugin to the <code>esp</code> component. Instructions for doing so can be found in the HPCC Systems Administrator&#39;s Guide manual (though the manual uses the htpasswd plugin as an example, the process is the same).</p><p>If you intend to implement file scope permissions then you will also need provide Dali information about the JWT plugin. In configmgr, within the <code>Dali Server</code> component, select the LDAP tab. Change the <code>authMethod</code> entry to <code>secmgrPlugin</code> and enter &quot;jwtsecmgr&quot; as the <code>authPluginType</code>. Make sure <code>checkScopeScans</code> is set to true.</p><h3 id="hpcc-systems-authorization-and-jwt-claims" tabindex="-1">HPCC Systems Authorization and JWT Claims <a class="header-anchor" href="#hpcc-systems-authorization-and-jwt-claims" aria-label="Permalink to &quot;HPCC Systems Authorization and JWT Claims&quot;">​</a></h3><p>This plugin supports all authorizations documented in the HPCC Systems® Administrator&#39;s Guide with the exception of &quot;View Permissions&quot;. Loosely speaking, the permissions are divided into three groups: Feature, Workunit Scope, and File Scope.</p><p>Feature permissions are supported exactly as documented. A specific permission would exist as a JWT claim, by name, with the associated value being the name of the permission. For example, to grant read-only access to ECL Watch, use this claim:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>	{ &quot;SmcAccess&quot;: &quot;Read&quot; }</span></span></code></pre></div><p>File and workunit scope permissions are handled the same way, but different from feature permissions. The claim is one of the Claim constants in the tables below, and the associated value is a matching pattern. A pattern can be simple string or it can use wildcards (specifically, Linux&#39;s file globbing wildcards). Wildcards are not typically needed.</p><p>Multiple patterns can be set for each claim.</p><h4 id="workunit-scope-permissions" tabindex="-1">Workunit Scope Permissions <a class="header-anchor" href="#workunit-scope-permissions" aria-label="Permalink to &quot;Workunit Scope Permissions&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Meaning</th><th>Claim</th><th>Value</th></tr></thead><tbody><tr><td>User has view rights to workunit scope</td><td>AllowWorkunitScopeView</td><td><em>pattern</em></td></tr><tr><td>User has modify rights to workunit scope</td><td>AllowWorkunitScopeModify</td><td><em>pattern</em></td></tr><tr><td>User has delete rights to workunit scope</td><td>AllowWorkunitScopeDelete</td><td><em>pattern</em></td></tr><tr><td>User does not have view rights to workunit scope</td><td>DenyWorkunitScopeView</td><td><em>pattern</em></td></tr><tr><td>User does not have modify rights to workunit scope</td><td>DenyWorkunitScopeModify</td><td><em>pattern</em></td></tr><tr><td>User does not have delete rights to workunit scope</td><td>DenyWorkunitScopeDelete</td><td><em>pattern</em></td></tr></tbody></table><h4 id="file-scope-permissions" tabindex="-1">File Scope Permissions <a class="header-anchor" href="#file-scope-permissions" aria-label="Permalink to &quot;File Scope Permissions&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Meaning</th><th>Claim</th><th>Value</th></tr></thead><tbody><tr><td>User has view rights to file scope</td><td>AllowFileScopeView</td><td><em>pattern</em></td></tr><tr><td>User has modify rights to file scope</td><td>AllowFileScopeModify</td><td><em>pattern</em></td></tr><tr><td>User has delete rights to file scope</td><td>AllowFileScopeDelete</td><td><em>pattern</em></td></tr><tr><td>User does not have view rights to file scope</td><td>DenyFileScopeView</td><td><em>pattern</em></td></tr><tr><td>User does not have modify rights to file scope</td><td>DenyFileScopeModify</td><td><em>pattern</em></td></tr><tr><td>User does not have delete rights to file scope</td><td>DenyFileScopeDelete</td><td><em>pattern</em></td></tr></tbody></table>`,41)]))}const m=t(a,[["render",n]]);export{u as __pageData,m as default};
