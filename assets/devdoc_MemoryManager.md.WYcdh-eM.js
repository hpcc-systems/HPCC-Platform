import{_ as a,a as t,o,ag as i}from"./chunks/framework.Do1Zayaf.js";const p=JSON.parse('{"title":"The Roxie Memory Manager","description":"","frontmatter":{"title":"The Roxie Memory Manager"},"headers":[],"relativePath":"devdoc/MemoryManager.md","filePath":"devdoc/MemoryManager.md","lastUpdated":1771585025000}'),r={name:"devdoc/MemoryManager.md"};function s(n,e,l,h,c,d){return o(),t("div",null,e[0]||(e[0]=[i('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><p>This memory manager started life as the memory manager which was only used for the Roxie engine. It had several original design goals:</p><ul><li>Support link counted rows. (When the last reference is released the row is freed.)</li><li>Be as fast as possible on allocate and deallocate of small rows.</li><li>Allow rows serialized from slaves to be used directly without being cloned first.</li><li>Allow the memory used by a single query, or by all queries combined, to be limited, with graceful recovery.</li><li>Isolate roxie queries from one another, so that one query can&#39;t bring down all the rest by allocating too much memory.</li><li>Guarantee all the memory used by a query is freed when the query finishes, reducing the possibility of memory leaks.</li><li>Predictable behaviour with no pathogenic cases.</li></ul><p>(Note that efficient usage of memory does not appear on that list - the expectation when the memory manager was first designed was that Roxie queries would use minimal amounts of memory and speed was more important. Some subsequent changes e.g., Packed heaps, and configurable bucket sizes help mitigate that.)</p><h1 id="main-structure" tabindex="-1">Main Structure <a class="header-anchor" href="#main-structure" aria-label="Permalink to &quot;Main Structure&quot;">​</a></h1><p>The basic design is to reserve (but not commit) a single large block of memory in the virtual address space. This memory is subdivided into &quot;pages&quot;. (These are not the same as the os virtual memory pages. The memory manager pages are currently defined as 1Mb in size.)</p><h2 id="the-page-bitmap" tabindex="-1">The page bitmap <a class="header-anchor" href="#the-page-bitmap" aria-label="Permalink to &quot;The page bitmap&quot;">​</a></h2><p>The system uses a bitmap to indicate whether each page from the global memory has been allocated. All active IRowManager instances allocate pages from the same global memory space. To help reduce fragmentation allocations for single pages are fulfilled from one end of the address space, while allocations for multiple pages are fulfilled from the other.</p><h2 id="irowmanager" tabindex="-1">IRowManager <a class="header-anchor" href="#irowmanager" aria-label="Permalink to &quot;IRowManager&quot;">​</a></h2><p>This provides the primary interface for allocating memory. The size of a requested allocation is rounded up to the next &quot;bucket&quot; size, and the allocation is then satisfied by the heap associated with that bucket size. Different engines can specify different bucket sizes - an optional list is provided to setTotalMemoryLimit. Roxie tends to use fewer buckets to help reduce the number of active heaps. Thor uses larger numbers since it is more important to minimize the memory wasted.</p><p>Roxie uses a separate instance of IRowManager for each query. This provides the mechanism for limiting how much memory a query uses. Thor uses a single instance of an IRowManager for each slave/master.</p><h2 id="heaps" tabindex="-1">Heaps <a class="header-anchor" href="#heaps" aria-label="Permalink to &quot;Heaps&quot;">​</a></h2><p>Memory is allocated from a set of &quot;heaps - where each heap allocates blocks of memory of a single size. The heap exclusively owns a set of heaplet (each 1 page in size), which are held in a doubly linked list, and sub allocates memory from those heaplets.</p><p>Information about each heaplet is stored in the base of the page (using a class with virtual functions) and the address of an allocated row is masked to determine which heap object it belongs to, and how it should be linked/released etc. Any pointer not in the allocated virtual address (e.g., constant data) can be linked/released with no effect.</p><p>Each heaplet contains a high water mark of the address within the page that has already been allocated (freeBase), and a lockless singly-linked list of rows which have been released (r_block). Releasing a row is non-blocking and does not involve any spin locks or critical sections. However, this means that empty pages need to be returned to the global memory pool at another time. (This is done in releaseEmptyPages()).</p><p>When the last row in a page is released a flag (possibleEmptyPages) is set in its associated heap. * This is checked before trying to free pages from a particular heap, avoiding waiting on a lock and traversing a candidate list.</p><p>Any page which <em>might</em> contain some spare memory is added to a lockless spare memory linked list. * Items are popped from this list when a heap fails to allocate memory from the current heaplet. Each item is checked in turn if it has space before allocating a new heaplet. * The list is also walked when checking to see which pages can be returned to the global memory. The doubly linked heaplet list allows efficient freeing.</p><p>Each allocation has a link count and an allocator id associated with it. The allocator id represents the type of the row, and is used to determine what destructor needs to be called when the row is destroyed. (The count for a row also contains a flag in the top bit to indicate if it is fully constructed, and therefore valid for the destructor to be called.)</p><h2 id="huge-heap" tabindex="-1">Huge Heap <a class="header-anchor" href="#huge-heap" aria-label="Permalink to &quot;Huge Heap&quot;">​</a></h2><p>A specialized heap is used to manage all allocations that require more than one page of memory. These allocations are not held on a free list when they are released, but each is returned directly to the global memory pool. Allocations in the huge heap can be expanded and shrunk using the resizeRow() functions - see below.</p><h2 id="specialised-heaps" tabindex="-1">Specialised Heaps: <a class="header-anchor" href="#specialised-heaps" aria-label="Permalink to &quot;Specialised Heaps:&quot;">​</a></h2><h3 id="packed" tabindex="-1">Packed <a class="header-anchor" href="#packed" aria-label="Permalink to &quot;Packed&quot;">​</a></h3><p>By default a fixed size heaps rounds the requested allocation size up to the next bucket size. A packed heap changes this behaviour and it is rounded up to the next 4 byte boundary instead. This reduces the amount of memory wasted for each row, but potentially increases the number of distinct heaps.</p><h3 id="unique" tabindex="-1">Unique <a class="header-anchor" href="#unique" aria-label="Permalink to &quot;Unique&quot;">​</a></h3><p>By default all fixed size heaps of the same size are shared. This reduces the memory consumption, but if the heap is used by multiple threads it can cause significant contention. If a unique heap is specified then it will not be shared with any other requests. Unique heaps store information about the type of each row in the heaplet header, rather than per row - which reduces the allocation overhead for each row. (Note to self: Is there ever any advantage having a heap that is unique but not packed??)</p><h3 id="blocked" tabindex="-1">Blocked <a class="header-anchor" href="#blocked" aria-label="Permalink to &quot;Blocked&quot;">​</a></h3><p>Blocked is an option on createFixedRowHeap() to allocate multiple rows from the heaplet, and then return the additional rows on subsequent calls. It is likely to reduce the average number of atomic operations required for each row being allocated, but the heap that is returned can only be used from a single thread because it is not thread safe.</p><h3 id="scanning" tabindex="-1">Scanning <a class="header-anchor" href="#scanning" aria-label="Permalink to &quot;Scanning&quot;">​</a></h3><p>By default the heaplets use a lock free singly linked list to keep track of rows that have been freed. This requires an atomic operation for each allocation and for each free. The scanning allocator uses an alternative approach. When a row is freed the row header is marked, and a row is allocated by scanning through the heaplet for rows that have been marked as free. Scanning uses atomic store and get, rather than more expensive synchronized atomic operations, so is generally faster than the linked list - provided a free row is found fairly quickly.</p><p>The scanning heaps have better best-case performance, but worse worse-case performance (if large numbers of rows need to be scanned before a free row is found). The best-case tends to be true if only one thread/activity is accessing a particular heap, and the worse-case if multiple activities are accessing a heap, particularly if the rows are being buffered. It is the default for thor which tends to have few active allocators, but not for roxie, which tends to have large numbers of allocators.</p><h3 id="delay-release" tabindex="-1">Delay Release <a class="header-anchor" href="#delay-release" aria-label="Permalink to &quot;Delay Release&quot;">​</a></h3><p>This is another varation on the scanning allocator, which further reduces the number of atomic operations. Usually when a row is allocated the link count on the heaplet is increased, and when it is freed the link count is decremented. This option delays decrementing the link count when the row is released, by marking the row with a different free flag. If it is subsequently reallocated there is no need to increment the link count. The downside is that it is more expensive to check whether a heaplet is completely empty (since you can no longer rely on the heaplet linkcount alone).</p><h1 id="dynamic-spilling" tabindex="-1">Dynamic Spilling <a class="header-anchor" href="#dynamic-spilling" aria-label="Permalink to &quot;Dynamic Spilling&quot;">​</a></h1><p>Thor has additional requirements to roxie. In roxie, if a query exceeds its memory requirements then it is terminated. Thor needs to be able to spill rows and other memory to disk and continue. This is achieved by allowing any process that stores buffered rows to register a callback with the memory manager. When more memory is required these callbacks are called to free up memory, and allow the job to continue.</p><p>Each callback can specify a priority - lower priority callbacks are called first since they are assumed to have a lower cost associated with spilling. When more memory is required the callbacks are called in priority order until one of them succeeds. The can also be passed a flag to indicate it is critical to force them to free up as much memory as possible.</p><h2 id="complications" tabindex="-1">Complications <a class="header-anchor" href="#complications" aria-label="Permalink to &quot;Complications&quot;">​</a></h2><p>There are several different complications involved with the memory spilling:</p><ul><li>There will be many different threads allocating rows.</li><li>Callbacks could be triggered at any time.</li><li>There is a large scope for deadlock between the callbacks and allocations.</li><li>It may be better to not resize a large array if rows had to be evicted to resize it.</li><li>Filtered record streams can cause significant wasted space in the memory blocks.</li><li>Resizing a multi-page allocation is non trivial.</li></ul><h2 id="callback-rules" tabindex="-1">Callback Rules <a class="header-anchor" href="#callback-rules" aria-label="Permalink to &quot;Callback Rules&quot;">​</a></h2><p>Some rules to follow when implementing callbacks:</p><ul><li><p>A callback cannot allocate any memory from the memory manager. If it does it is likely to deadlock.</p></li><li><p>You cannot allocate memory while holding a lock if that lock is also required by a callback.</p><p>Again this will cause deadlock. If it proves impossible you can use a try-lock primitive in the callback, but it means you won&#39;t be able to spill those rows.</p></li><li><p>If the heaps are fragmented it may be more efficient to repack the heaps than spill to disk.</p></li><li><p>If you&#39;re resizing a potentially big block of memory use the resize function with the callback.</p></li></ul><h2 id="resizing-large-memory-blocks" tabindex="-1">Resizing Large memory blocks <a class="header-anchor" href="#resizing-large-memory-blocks" aria-label="Permalink to &quot;Resizing Large memory blocks&quot;">​</a></h2><p>Some of the memory allocations cover more than one &quot;page&quot; - e.g., arrays used to store blocks of rows. (These are called huge pages internally, not to be confused with operating system support for huge pages...) When one of these memory blocks needs to be expanded you need to be careful:</p><ul><li>Allocating a new page, copying, updating the pointer (within a cs) and then freeing is safe. Unfortunately it may involve copying a large chunk of memory. It may also fail if there isn&#39;t memory for the new and old block, even if the existing block could have been expanded into an adjacent block.</li><li>You can&#39;t lock, call a resize routine and update the pointer because the resize routine may need to allocate a new memory block- that may trigger a callback, which could in turn deadlock trying to gain the lock. (The callback may be from another thread...)</li><li>Therefore the memory manager contains a call which allows you to resize a block, but with a callback which is used to atomically update the pointer so it always remains thread safe.</li></ul><h2 id="compacting-heaps" tabindex="-1">Compacting heaps <a class="header-anchor" href="#compacting-heaps" aria-label="Permalink to &quot;Compacting heaps&quot;">​</a></h2><p>Occasionally you have processes which read a large number of rows and then filter them so only a few are still held in memory. Rows tend to be allocated in sequence through the heap pages, which can mean those few remaining rows are scattered over many pages. If they could all be moved to a single page it would free up a significant amount of memory.</p><p>The memory manager contains a function to pack a set of rows into a smaller number of pages: IRowManager-&gt;compactRows().</p><p>This works by iterating through each of the rows in a list. If the row belongs to a heap that could be compacted, and isn&#39;t part of a full heaplet, then the row is moved. Since subsequent rows tend to be allocated from the same heaplet this has the effect of compacting the rows.</p><h1 id="shared-memory" tabindex="-1">Shared Memory <a class="header-anchor" href="#shared-memory" aria-label="Permalink to &quot;Shared Memory&quot;">​</a></h1><p>Much of the time Thor doesn&#39;t uses full memory available to it. If you are running multiple Thor processes on the same machine you may want to configure the system so that each Thor has a private block of memory, but there is also a shared block of memory which can be used by whichever process needs it.</p><p>The ILargeMemCallback provides a mechanism to dynamically allocate more memory to a process as it requires it. This could potentially be done in stages rather than all or nothing.</p><p>(Currently unused as far as I know... the main problem is that borrowing memory needs to be coordinated.)</p><h1 id="huge-pages" tabindex="-1">Huge pages <a class="header-anchor" href="#huge-pages" aria-label="Permalink to &quot;Huge pages&quot;">​</a></h1><p>When OS processes use a large amount of memory, mapping virtual addresses to physical addresses can begin to take a significant proportion of the execution time. This is especially true once the TLB is not large enough to store all the mappings. Huge pages can significantly help with this problem by reducing the number of TLB entries needed to cover the virtual address space. The memory manager supports huge pages in two different ways:</p><p>Huge pages can be preallocated (e.g., with hugeadm) for exclusive use as huge pages. If huge pages are enabled for a particular engine, and sufficient huge pages are available to supply the memory for the memory manager, then they will be used.</p><p>Linux kernels from 2.6.38 onward have support for transparent huge pages. These do not need to be preallocated, instead the operating system tries to use them behind the scenes. HPCC version 5.2 and following takes advantage of this feature to significantly speed memory access up when large amounts of memory are used by each process.</p><p>Preallocated huge pages tend to be more efficient, but they have the disadvantage that the operating system currently does not reuse unused huge pages for other purposes e.g., disk cache.</p><p>There is also a memory manager option to not return the memory to the operating system when it is no longer required. This has the advantage of not clearing the memory whenever it is required again, but the same disadvantage as preallocated huge pages that the unused memory cannot be used for disk cache. We recommend this option is selected when preallocated huge pages are in use - until the kernel allows them to be reused.</p><h1 id="global-memory-and-channels" tabindex="-1">Global memory and channels <a class="header-anchor" href="#global-memory-and-channels" aria-label="Permalink to &quot;Global memory and channels&quot;">​</a></h1><p>Changes in 6.x allow Thor to run multiple channels within the same process. This allows data that is constant for all channels to be shared between all slave channels - a prime example is the rhs of a lookup join. For the queries to run efficiently the memory manager needs to ensure that each slave channel has the same amount of memory - especially when memory is being used that is shared between them.</p><p>createGlobalRowManager() allows a single global row manager to be created which also provides slave row managers for the different channels via the querySlaveRowManager(unsigned slave) method.</p>',61)]))}const u=a(r,[["render",s]]);export{p as __pageData,u as default};
