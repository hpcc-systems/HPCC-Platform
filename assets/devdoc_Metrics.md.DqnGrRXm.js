import{_ as s,a as i,o as t,ag as a}from"./chunks/framework.Do1Zayaf.js";const m=JSON.parse('{"title":"Metrics Framework Design","description":"","frontmatter":{},"headers":[],"relativePath":"devdoc/Metrics.md","filePath":"devdoc/Metrics.md","lastUpdated":1761843274000}'),n={name:"devdoc/Metrics.md"};function r(o,e,l,h,p,c){return t(),i("div",null,e[0]||(e[0]=[a(`<h1 id="metrics-framework-design" tabindex="-1">Metrics Framework Design <a class="header-anchor" href="#metrics-framework-design" aria-label="Permalink to &quot;Metrics Framework Design&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>This document describes the design of a metrics framework that allows HPCC Systems components to implement a metric collection strategy. Metrics provide the following functionality:</p><ul><li><p>Alerts and monitoring</p><p>An important DevOps function is to monitor the cluster and providing alerts when problems are detected. Aggregated metric values from multiple sources provide the necessary data to build a complete picture of cluster health that drives monitoring and alerts.</p></li><li><p>Scaling</p><p>As described above, aggregated metric data is also used to dynamically respond to changing cluster demands and load. Metrics provide the monitoring capability to react and take action</p></li><li><p>Fault diagnosis and resource monitoring</p><p>Metrics provide historical data useful in diagnosing problems by profiling how demand and usage patterns may change prior to a fault. Predictive analysis can also be applied.</p></li><li><p>Analysis of jobs/workunits and profiling</p><p>With proper instrumentation, a robust dynamic metric strategy can track workunit processing. Internal problems with queries should be diagnosed from deep drill down logging.</p></li></ul><p>The document consists of several sections in order to provide requirements as well as the design of framework components.</p><h3 id="definitions" tabindex="-1">Definitions <a class="header-anchor" href="#definitions" aria-label="Permalink to &quot;Definitions&quot;">​</a></h3><p>Some definitions are useful.</p><p>Metric</p><p>: A measurement defined by a component that represents an internal state that is useful in a system reliability engineering function. In the context of the framework, a metric is an object representing the above.</p><p>Metric Value</p><p>: The current value of a metric.</p><p>Metric Updating</p><p>: The component task of updating metric state.</p><p>Collection</p><p>: A framework process of selecting relevant metrics based on configuration and then retrieving their values.</p><p>Reporting</p><p>: A framework process of converting values obtained during a collection into a format suitable for ingestion by a collection system.</p><p>Trigger</p><p>: What causes the collection of metric values.</p><p>Collection System</p><p>: The store for metric values generated during the reporting framework process.</p><h2 id="use-scenarios" tabindex="-1">Use Scenarios <a class="header-anchor" href="#use-scenarios" aria-label="Permalink to &quot;Use Scenarios&quot;">​</a></h2><p>This section describes how components expect to use the framework. It is not a complete list of all requirements but rather a sample.</p><h3 id="roxie" tabindex="-1">Roxie <a class="header-anchor" href="#roxie" aria-label="Permalink to &quot;Roxie&quot;">​</a></h3><p>Roxie desires to keep a count of many different internal values. Some examples are</p><ul><li><p>Disk type operations such as seeks and reads</p></li><li><p>Execution totals</p><p>Need to track items such as total numbers of items such as success and failures as well as breaking some counts into individual reasons. For example, failures may need be categorized such as as</p><ul><li>Busy</li><li>Timeout</li><li>Bad input</li></ul><p>Or even by priority (high, low, sla, etc.)</p></li><li><p>Current operational levels such as the length of internal queues</p></li><li><p>The latency of operations such as queue results, agent responses, and gateway responses</p></li></ul><p>Roxie also has the need to track internal memory usage beyond the pod/system level capabilities. Tracking the state of its large fixed memory pool is necessary.</p><p>The Roxie buddy system also must track how often and who is completing requests. The &quot;I Beat You To It&quot; set of metrics must be collected and exposed in order to detect pending node failure. While specific action on these counts is not known up front, it appears clear that these values are useful and should be collected.</p><p>There does not appear to be a need for creating and destroying metrics dynamically. The set of metrics is most likely to be created at startup and remain active through the life of the Roxie. If, however, stats collection seeps into the metrics framework, dynamic creation and destruction of stats metrics is a likely requirement.</p><h3 id="esp" tabindex="-1">ESP <a class="header-anchor" href="#esp" aria-label="Permalink to &quot;ESP&quot;">​</a></h3><p>There are some interesting decisions with respect to ESP and collection of metrics. Different applications within ESP present different use cases for collection. Ownership of a given task drives some of these use cases. Take workunit queues. If ownership of the task, with respect to metrics, is WsWorkunits, then use cases are centric to that component. However, if agents listening on the queue are to report metrics, then a different set of use cases emerge. It is clear that additional work is needed to generate clear ownership of metrics gathered by ESP and/or the tasks it performs.</p><p>ESP needs to report the <em>activeTransactions</em> value from the TxSummary class(es). This gives an indication of how busy the ESP is in terms of client requests.</p><p>Direct measurement of response time in requests may not be useful since the type of request causes different execution paths within ESP that are expected to take widely varying amounts of time. Creation of metrics for each method is not recommended. However, two possible solutions are to a) create a metric for request types, or b) use a histogram to measure response time ranges. Another option mentioned redefines the meaning of a bucket in a histogram. Instead of a numeric distribution, each bucket represents a unique subtask within an overall &quot;metric&quot; representing a measured operation. This should be explored whether for operational or developmental purposes.</p><p>For tracking specific queries and their health, the feeling is that logging can accomplish this better than metrics since the list of queries to monitor will vary between clusters. Additionally, operational metrics solving the cases mentioned above will give a view into the overall health of ESP which will affect the execution of queries. Depending on actions taken by these metrics, scaling may solve overload conditions to keep cluster responsiveness acceptable.</p><p>For Roxie a workunit operates as a service. Measuring service performance using a histogram to capture response times as a distribution may be appropriate. Extracting the 95th percentile of response time may be useful as well.</p><p>There are currently no use cases requiring consistency between values of different metrics.</p><p>At this time the only concrete metric identified is the number of requests received. As the framework design progresses and ESP is instrumented, the list will grow.</p><h3 id="dali-use-cases" tabindex="-1">Dali Use Cases <a class="header-anchor" href="#dali-use-cases" aria-label="Permalink to &quot;Dali Use Cases&quot;">​</a></h3><p>From information gathered, Dali plans to keep counts and rates for many of the items it manages.</p><h2 id="framework-design" tabindex="-1">Framework Design <a class="header-anchor" href="#framework-design" aria-label="Permalink to &quot;Framework Design&quot;">​</a></h2><p>This section covers the design and architecture of the framework. It discusses the main areas of the design, its interactions, and an overall process model of how the framework operates.</p><p>The framework consists of three major areas: metrics, sinks, and the glue logic. These areas work together with the platform and the component to provide a reusable metrics collection framework.</p><p>Metrics represent the quantifiable component state measurements used to track and assess the status of the component. Metrics are typically scalar values that are easily aggregated by a collection system. Aggregated values provide the necessary input to take component and cluster actions such as horizontal scaling. The component is responsible for creating metrics and instrumenting the code. The framework provides the support for collecting and reporting the values. Metrics provide the following:</p><ul><li>Simple methods for the component to create and update the metric</li><li>Simple methods for the framework to retrieve metric value(s)</li><li>Handling of all synchronization between updating and retrieving metric values</li></ul><p>In addition, the framework provides the support for retrieving values so that the component does not participate in metric reporting. The component simply creates required metrics, then instruments the component to update the metric for state changes and/or events. For example, the component may create a metric to count the total number of requests received. Then, wherever the component receives a request, it increments the count.</p><p>Sinks provide a pluggable interface to the framework that hides the specifics of the collection system. This keeps both the framework and instrumented components independent of the collection system. Examples of collection systems are Prometheus, Datadog, and Elasticsearch.</p><p>Sinks have the following responsibilities:</p><ul><li>Operate independently of other sinks in the system</li><li>Convert metric native values into collection system specific measurements and reports</li><li>Drive the collection and reporting processes</li></ul><p>The third area of the framework is the glue logic, referred to as the <em>MetricsFramework</em>. It manages the metrics system for the component and sink(s). It provides the following:</p><ul><li>Handles framework initialization</li><li>Loads sinks as required</li><li>Manages the list of metrics for components</li><li>Handles collection and reporting with a set of methods used by sinks</li></ul><p>The framework provides a manager singleton object shared by all components in the same address space.</p><h2 id="framework-implementation" tabindex="-1">Framework Implementation <a class="header-anchor" href="#framework-implementation" aria-label="Permalink to &quot;Framework Implementation&quot;">​</a></h2><p>The framework is implemented within jlib. The following sections describe each area of the framework.</p><h3 id="metrics" tabindex="-1">Metrics <a class="header-anchor" href="#metrics" aria-label="Permalink to &quot;Metrics&quot;">​</a></h3><p>Components use metrics to measure their internal state. Metrics can represent everything from the number of requests received to the average length some value remains cached. Components are responsible for creating and updating metrics for each measured state. The framework provides a set of metrics designed to cover the majority of component measurement requirements.</p><p>To meet the requirement to manage metrics independent of the underlying metric state, all metrics implement a common interface. All metrics then add their specific methods to update and retrieve internal state. Generally, the component uses the update method(s) to update state and sinks use the retrieval methods to get current state when reporting. The metric insures synchronized access.</p><p>For components that already have an implementation that tracks a measurement, the framework provides a way to instantiate a custom metric. The custom metric allows the component to leverage the existing implementation and give the framework access to the metric value for collection and reporting. Note that custom metrics only support simple scalar metrics such as a counter or a gauge.</p><h3 id="sinks" tabindex="-1">Sinks <a class="header-anchor" href="#sinks" aria-label="Permalink to &quot;Sinks&quot;">​</a></h3><p>Sinks are responsible for two main functions: initiating a collection and reporting measurements to the collection system. The <em>Metrics Manager</em> provides the support to complete these functions.</p><p>The framework defines a sink interface to support the different requirements of collection systems. Examples of collection systems are Prometheus, Datadog, and Elasticsearch. Each has different requirements for how and when measurements are ingested. The following are examples of different collection system requirements:</p><ul><li>Polled vs Periodic</li><li>Single measurement vs multiple reports</li><li>Report format (JSON, text, etc.)</li><li>Push vs Pull</li></ul><p>The sink encapsulates all collection system requirements providing a pluggable architecture that isolates components from collecting and reporting. The framework can support multiple sinks concurrently, each operating independently.</p><p>Instrumented components are not aware of the sink or sinks in use. Sinks can be changed without requiring changes to a component, keeping components independent of the collection system(s) in use.</p><h3 id="metrics-manager" tabindex="-1">Metrics Manager <a class="header-anchor" href="#metrics-manager" aria-label="Permalink to &quot;Metrics Manager&quot;">​</a></h3><p>The MetricsManager class provides the common functions to bind together the component, the metrics it creates, and the sinks to which measurements are reported. It is responsible for the following:</p><ul><li>Initialization of the framework</li><li>Managing the metrics created by components</li><li>Supporting collection and reporting as directed by configured sinks</li></ul><h3 id="metrics-implementations" tabindex="-1">Metrics Implementations <a class="header-anchor" href="#metrics-implementations" aria-label="Permalink to &quot;Metrics Implementations&quot;">​</a></h3><p>The sections that follow discuss metric implementations.</p><h4 id="counter-metric" tabindex="-1">Counter Metric <a class="header-anchor" href="#counter-metric" aria-label="Permalink to &quot;Counter Metric&quot;">​</a></h4><p>A counter metric is a monotonically increasing value that &quot;counts&quot; the total occurrences of some event. Examples include the number of requests received, or the number of cache misses. Once created, the component instruments the code with updates to the count whenever appropriate.</p><h4 id="gauge-metric" tabindex="-1">Gauge Metric <a class="header-anchor" href="#gauge-metric" aria-label="Permalink to &quot;Gauge Metric&quot;">​</a></h4><p>A gauge metric is a continuously updated value representing the current state of an interesting value in the component. For example, the amount of memory used in an internal buffer, or the number of requests waiting on a queue. A gauge metric may increase or decrease in value as needed. Reading the value of a gauge is a stateless operation in that there are no dependencies on the previous reading. The value returned is always the current state.</p><p>Once created, the component updates the gauge as state changes. The metric provides methods to increase and decrease the value.</p><h4 id="custom-metric" tabindex="-1">Custom Metric <a class="header-anchor" href="#custom-metric" aria-label="Permalink to &quot;Custom Metric&quot;">​</a></h4><p>A custom metric is a class that allows a component to leverage existing metrics. The component creates an instance of a custom metric (a templated class) and passes a reference to the underlying metric value. When collection is performed, the custom metric simply reads the value of the metric using the reference provided during construction. The component maintains full responsibility for updating the metric value as the custom metric class provides no update methods. One minor drawback is that the famework provides no synchronization for the metric value.</p><h4 id="histogram-metric" tabindex="-1">Histogram Metric <a class="header-anchor" href="#histogram-metric" aria-label="Permalink to &quot;Histogram Metric&quot;">​</a></h4><p>Defines a distribution of measurements into a predefined set of intervals known as buckets. When created, the component must provide the bucket limits. When recording a measurement, the histogram metric increments the count of the relevant bucket by using the measurement against defined bucket limits. Each bucket contains a monotonically increasing count of measurements falling inside its range. Additionally, the metric maintains a count of measurements that fall outside the maximum bucket limit. This is known as the &quot;inf&quot; bucket.</p><p>The sink is free to convert the bucket counts into a suitable format for reporting.</p><h4 id="scaled-histogram-metric" tabindex="-1">Scaled Histogram Metric <a class="header-anchor" href="#scaled-histogram-metric" aria-label="Permalink to &quot;Scaled Histogram Metric&quot;">​</a></h4><p>A histogram metric that allows setting the bucket limit units in one domain, but take measurements in another domain. For example, the bucket limits may represent millisecond durations, yet it is more efficient to use execution cycles to take the measurements. A scaled histogram converts from the measurement domain (cycles) to the limit units domain using a scale factor provided at initialization. All conversions are encapsulated in the scaled histogram class such that no external scaling is required by any consumer such as a sink.</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><p>This section discusses configuration. Since Helm charts are capable of combining configuration data at a global level into a component&#39;s specific configuration, The combined configuration takes the form as shown below. Note that as the design progresses it is expected that there will be additions.</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      metrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        sinks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;sink_type&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&lt;sink name&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          settings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            sink_setting1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sink_setting_value1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">            sink_setting2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sink_setting_value2</span></span></code></pre></div><p>Where:</p><p>metrics</p><p>: Metrics configuration for the component</p><p>metrics.sinks</p><p>: List of defined sinks</p><p>metrics.sinks[].type</p><p>: The sink type. The type is substituted into the following pattern to determine the lib to load: libhpccmetrics&lt;type&gt;&lt;shared_object_extension&gt;</p><p>metrics.sinks[].name</p><p>: A name for the sink.</p><p>metrics.sinks[].settings</p><p>: A set of key/value pairs passed to the sink when initialized. It should contain information necessary for the operation of the sink. Nested YML (or XML) is supported. Example settings are the Prometheus server name, or the collection period for a periodic sink.</p><h2 id="metric-naming" tabindex="-1">Metric Naming <a class="header-anchor" href="#metric-naming" aria-label="Permalink to &quot;Metric Naming&quot;">​</a></h2><p>Metric names shall follow a convention as outlined in this section. Because different collection systems have different requirements for how metric value reports are generated, naming is split into two parts.</p><p>First, each metric is given a base name that describes what the underlying value is. Second, metadata is assigned to each metric to further qualify the value. For example, a set of metrics may count the number of requests a component has received. Each metric would have the same base name, but metadata would separate types of request (GET vs POST), or disposition such as pass or fail.</p><p>The combination of base name and metadata provides a unique signature for each metric.</p><h3 id="base-name" tabindex="-1">Base Name <a class="header-anchor" href="#base-name" aria-label="Permalink to &quot;Base Name&quot;">​</a></h3><p>The following convention defines how metric names are formed:</p><ul><li><p>Name consists of parts separated by a period (.)</p></li><li><p>Name must begin with a character and may not end with a period (.)</p></li><li><p>Only one period is allowed between parts</p></li><li><p>Only uppercase and lowercase letters and numbers are allowed in each part.</p></li><li><p>Each part shall use camel case (allows for compound names in each part). Note that a part, other than the first, may begin with a number.</p></li><li><p>Each name shall begin with a prefix representing the scope of the metric (For example: <em>esp</em> or <em>dali</em>)</p></li><li><p>The remainder of the name shall follow these conventions:</p><p>Gauges: &lt;scope&gt;.&lt;plural-noun&gt;.&lt;state&gt; Examples: esp.requests.waiting, esp.status.requests.waiting</p><p>Counters: &lt;scope&gt;.&lt;plural-noun&gt;.&lt;past-tense-verb&gt; Examples: thor.requests.failed, esp.gateway.requests.queued</p><p>Time: &lt;scope&gt;.&lt;singular-noun&gt;.&lt;state or active-verb&gt;.time Examples: dali.request.blocked.time, dali.request.process.time</p></li></ul><h3 id="metadata" tabindex="-1">Metadata <a class="header-anchor" href="#metadata" aria-label="Permalink to &quot;Metadata&quot;">​</a></h3><p>Metadata further qualifies a metric value. This allows metrics to have the same name, but different scopes or categories. Generally, metadata is only used to further qualify metrics that have the same base name, but need further distinction. An example best describes a use case for metadata. Consider a component that accepts HTTP requests, but needs to track GET and POST requests separately. Instead of defining metrics with names <em>post.requests.received</em> and <em>get.requests.received</em>, the component creates two metrics with the base name <em>requests.received</em> and attaches metadata describing the request type. In this case. &quot;post&quot; for the former, and &quot;get&quot; for the latter.</p><p>Use of metadata allows aggregating both types of requests into a single combined count of received requests while allowing a breakdown by type.</p><p>Metadata is represented as key/value pairs and is attached to the metric by the component during metric creation. The sink is responsible for converting metadata into useful information for the collection system during reporting.</p><p>The <em>Component Instrumentation</em> section covers how metadata is added to a metric.</p><p>The key for metadata is a string, a name, representing what the value is. The name string must be unique within the metadata for a metric. Names do not have any restrictions, but should be short and descriptive.</p><p>The value is a string must consist of only uppercase and lowercase letters and numbers. Generally the value should be a single word or number (such as a port number). The value should follow the camel case convention.</p><h2 id="component-instrumentation" tabindex="-1">Component Instrumentation <a class="header-anchor" href="#component-instrumentation" aria-label="Permalink to &quot;Component Instrumentation&quot;">​</a></h2><p>In order to instrument a component for metrics using the framework, a component must include the metrics header from jlib (<em>jmetrics.hpp</em>) and add jlib as a dependent lib (if not already doing so).</p><p>The general steps for instrumentation are</p><ol><li>Determine what component state to measure. This requires deep knowledge of the component.</li><li>Create metric objects for each measured state and add each to the manager.</li><li>Add updates for each metric throughout the component to track state changes and/or events.</li></ol><p>The component may retrieve the metrics manager singleton object and manually create and add metrics. To simplify the process of metric creation (2 above), the framework provides a set of register functions for each metric. Each creates a metric, registers it, and returns a shared pointer to the metric (see below). Use of the register functions is the recommended approach and alleviates the component from needing a reference to the manager.</p><p>If the component desires to get a reference to the metrics manager singleton, the following code is recommended:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MetricsManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">metricsManager </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> queryMetricsManager</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>Metrics are wrapped by a standard C++ shared pointer. The component is responsible for saving the pointer in order to maintain a reference to the metric. The framework keeps a weak pointer to each metric and thus does not maintain a reference.</p><p>As mentioned above, the framework provides a set of register functions for each metric type. See the header file for the complete list of register functions.</p><p>The following is an example of creating and registering a counter metric.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCounter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;metric.name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="metric-creation" tabindex="-1">Metric Creation <a class="header-anchor" href="#metric-creation" aria-label="Permalink to &quot;Metric Creation&quot;">​</a></h3><p>The method by which a component creates a metric depends on component implementation. The sections that follow provide guidance on different methods of metric creation. Choose the method that best matches component implementation.</p><p>Metrics are guaranteed to always be created. Problems only arise when registering. If there is a failure during registration, the metric can still be used within the component to update state. However, the metric will not be reported during collection. Generally, registration failures are for one of the following reasons:</p><ul><li>Duplicate metric name (for purposes of unique metric naming, the combination of metric name and metadata must be unique)</li><li>Invalid metric name or metadata value</li></ul><h4 id="during-module-initialization" tabindex="-1">During Module Initialization <a class="header-anchor" href="#during-module-initialization" aria-label="Permalink to &quot;During Module Initialization&quot;">​</a></h4><p>If the component is a shared library whose code is not also shared with a main application, then the component should create metrics during module initialization. The following code shows how to register a metric during module initialization:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCount;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MODULE_INIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(INIT_PRIORITY_STANDARD)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SMeasureCount);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MODULE_EXIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // note this is optional</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Note that the metric is not required to be a static variable. Other options include:</p><ul><li>A global variable</li><li>A static class member variable</li></ul><h4 id="during-construction" tabindex="-1">During Construction <a class="header-anchor" href="#during-construction" aria-label="Permalink to &quot;During Construction&quot;">​</a></h4><p>If the metric is based on measuring state in a class that is created and destroyed multiple times, then the metric should be a static variable in the class. The metric is created during the first construction and then reused for subsequent constructions. The metric is destroyed when the class static variables are destroyed. The following code shows how to register a metric once:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Allocate the class static variables</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::once_flag </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::metricsInitialized;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::pCount1;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassX</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCount1;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::once_flag metricsInitialized;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call_once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(metricsInitialized, []()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pCount1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;metric1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">method1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pCount1-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // Update state</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The static <em>once_flag</em> and <em>call_once</em> block ensure that the metric is only created once. The first time the constructor is called, the lambda is executed. Subsequent calls to the constructor do not execute the lambda. The static shared_ptr for each metric maintain references to each metric making them available throughout the class.</p><h4 id="static-creation" tabindex="-1">Static Creation <a class="header-anchor" href="#static-creation" aria-label="Permalink to &quot;Static Creation&quot;">​</a></h4><p>Static creation should be a last resort. If the above methods do not solve the problem of metric allocation and registering, then static creation is the next best choice. The primary reason to avoid static creation is that if there is a problem during creation, any log messages or exceptions are lost. Debugging is more difficult in this case.</p><p>An example of static creation is shown below:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Allocate the class static variables</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCount1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hpccMetrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;metric1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="metric-state-updates" tabindex="-1">Metric State Updates <a class="header-anchor" href="#metric-state-updates" aria-label="Permalink to &quot;Metric State Updates&quot;">​</a></h3><p>Note in the examples above, only a single line of code is needed to update state. This is true for all metric types.</p><p>That&#39;s it! There are no component requirements related to collection or reporting of metric values. That is handled by the framework and loaded sinks.</p><h3 id="custom-metrics" tabindex="-1">Custom Metrics <a class="header-anchor" href="#custom-metrics" aria-label="Permalink to &quot;Custom Metrics&quot;">​</a></h3><p>If your component is already tracking a metric, you may not need to convert it to a defined framework metric type. Instead, you can create a custom metric and pass a reference to the existing metric value. The metric value, however, must be a scalar value that can cast to a 64bit unsigned integer (__uint64).</p><p>The following is an example of creating a custom metric (you must provide the metric type):</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCustomMetric </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> registerCustomMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;customName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, metricType, value);</span></span></code></pre></div><h3 id="adding-metric-metadata" tabindex="-1">Adding Metric Metadata <a class="header-anchor" href="#adding-metric-metadata" aria-label="Permalink to &quot;Adding Metric Metadata&quot;">​</a></h3><p>A component, depending on requirements, may attach metadata to further qualify created metrics. Metadata takes the form of key value pairs. The base metric class <em>MetricBase</em> constructor defines a parameter for a vector of metadata. Metric subclasses also define metadata as a constructor parameter, however an empty vector is the default. The <em>IMetric</em> interface defines a method for retrieving the metadata.</p><p>Meta data is order dependent.</p><p>Below are two examples of registering a counter metric with metadata. The first creates the vector and passes it as a parameter. The second constructs the vector in place.</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MetricMetaData metaData1{{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCounter1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;requests.completed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SMeasureCount, metaData1);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::shared_ptr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CounterMetric</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pCounter2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    registerCounterMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;requests.completed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, SMeasureCount, MetricMetaData{{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}});</span></span></code></pre></div><h3 id="metric-units" tabindex="-1">Metric Units <a class="header-anchor" href="#metric-units" aria-label="Permalink to &quot;Metric Units&quot;">​</a></h3><p>Metric units are treated separately from the base name and metadata. The reason is to allow the sink to translate based on collection system requirements. The base framework provides a convenience method for converting units into a string. However, the sink is free to do any conversions, both actual units and the string representation, as needed.</p><p>Metric units are defined using a subset of the <em>StatisticMeasure</em> enumeration values defined in <strong>jstatscodes.h</strong>. The current values are used:</p><ul><li>SMeasureTimeNs - A time measurement in nanoseconds</li><li>SMeasureCount - A count of events</li><li>SMeasureSize - Size in bytes</li></ul>`,152)]))}const k=s(n,[["render",r]]);export{m as __pageData,k as default};
