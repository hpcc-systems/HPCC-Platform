## hpcc_common.lib
################################################################################
#    HPCC SYSTEMS software Copyright (C) 2012 HPCC SystemsÂ®.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
################################################################################
#
# A series of functions that are common to all hpcc-init processes
#

source  @INSTALL_DIR@/etc/init.d/init-functions
source  @INSTALL_DIR@/etc/init.d/export-path
source  @INSTALL_DIR@/etc/init.d/pid.sh
source  @INSTALL_DIR@/etc/init.d/lock.sh

START_STOP_DAEMON=@INSTALL_DIR@/bin/start-stop-daemon

# general logging message for init scripts
# expects $logfile to exist within the context of where it's called
log() {
  if [[ -z ${logfile+x} ]]; then
    # logfile isn't set within the context of this function call
    return 1
  fi

  local msg=$@
  local header=$( date +%Y_%m_%d_%H_%M_%S )
  local header="${header}: "
  printf "%s%s\n" "$header" "$msg" >> $logfile

  return 0
}

which_service(){
    SERV=`type --path service`
    if [ "${SERV}" == "" ]; then
        if [ -e "/sbin/service" ]; then
            SERV=/sbin/service
        elif [ -e "/usr/sbin/service" ]; then
            SERV=/usr/sbin/service
        fi
    fi
}

which_pidof(){
    PIDOF=`type --path pidof`
    if [ "${PIDOF}" == "" ]; then
        if [ -e /bin/pidof ]; then
            PIDOF=/bin/pidof
        elif [ -e /sbin/pidof  ]; then
            PIDOF=/sbin/pidof
        elif [ -e /usr/sbin/pidof ]; then
            PIDOF=/usr/sbin/pidof
        fi
    fi
}

## cfg.parser parses an ini format file and when given a section places
## the associated variables with the section in to local scope.
##
## $1="<path to ini file>"
####
cfg.parser () {
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Parsing $1 config file..."
    if [ ! -e $1 ] || [ $# -lt 1 ]; then
        [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 1 && return 1 || return 1
    fi
    OIFS=${IFS}
    IFS=$'\n' && ini=( $(cat $1 | sed -e 's/[[:blank:]]*=[[:blank:]]*/=/') )              # convert to line-array
    ini=( ${ini[*]//[;#]*/} )                   # remove comments
    ini=( ${ini[*]/#[/\}$'\n'cfg.section.} ) # set section prefix
    ini=( ${ini[*]/%]/ \(} )                 # convert text2function (1)
    ini=( ${ini[*]/=/=\( } )                 # convert item to array
    ini=( ${ini[*]/%/ \)} )                  # close array parenthesis
    ini=( ${ini[*]/%\( \)/\(\) \{} )         # convert text2function (2)
    ini=( ${ini[*]/%\} \)/\}} )              # remove extra parenthesis
    ini[0]=''                                # remove first element
    ini[${#ini[*]} + 1]='}'                  # add the last brace
    #echo "${ini[*]}"               # echoing the result
    eval "$(echo "${ini[*]}")"               # eval the result
    IFS=${OIFS} 
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 0
}

## dir.parser parses the return of configgen -listcommondirs and builds local scope
## arrays for each return from the generator. It also builds an array of which
## elements can be used in the local scope ($dirArray).
##
## $@="line1 . . lineN"
##
dir.parser() {
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Parsing configgen data..."
        if [ $# -lt 1 ]; then
            [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 1 && return 1 || return 1
        fi
        OIFS=${IFS}
        IFS=$'\n' && cmp=( $@ )
        cmp=( ${cmp[*]/#/dir_} )
        cmp=( ${cmp[*]/=/= dirItem=} )
        cmp=( ${cmp[*]/=/=\(} )
        cmp=( ${cmp[*]/%/ \)} )
        eval "$(echo "${cmp[*]}")"
        for i in ${!dir_*}; do
            dirArray=( ${dirArray[@]} $i )
        done
        IFS=${OIFS}
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 0
}

## dir.getByName allows the user to pass the name of a directory from the <Directories/>
## tag they would like to receive and in return sets $dir_return in the local scope
## to the array that has been requested.
##
## $1="<directory name>"
##
dir.getByName(){
    dir_return=""
    name=$1
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Retrieving dir by name: $1..\
."
    for x in ${dirArray[@]}; do
            eval z=(\${${x}[@]})
            if [ $x = "dir_${name}" ]; then
            dir_return=`echo ${z[@]} | awk -F" " '{print $1}' | awk -F"=" '{print $2}'`
            fi
    done
    if [[ "${VERBOSE:-0}" -eq 1 ]]; then
    if [ ! -z "${dir_return}" ]; then
        log_end_msg 0
        else
        log_end_msg 1
        fi
    fi

}

## comp.parser parses the return of configgen and builds local scope arrays for each
## return from the generator. It also builds an array of which elements can be used in
## the local scope ($compArray).
##
## $@="line1 . . lineN"
##
comp.parser() {
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Parsing configgen data..."
    if [ $# -lt 1 ]; then
        [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 1 && return 1 || return 1
    fi
    OIFS=${IFS}
    IFS=$'\n' && cmp=( $@ )
    cmp=( ${cmp[*]/#/comp_} )
    cmp=( ${cmp[*]/=/= compType=} )
    cmp=( ${cmp[*]/;/ compPath=} )
    cmp=( ${cmp[*]/;/ compStat=} )
    cmp=( ${cmp[*]/=/=\(} )
    cmp=( ${cmp[*]/%/ \)} )
    eval "$(echo "${cmp[*]}")"
    for i in ${!comp_*}; do
        compArray=( ${compArray[@]} $i )
    done
    IFS=${OIFS}
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 0
}

## comp.getByType allows the user to pass the type of component for the local system they
## would like to recieve and in return sets $comp_return in the local scope to the array
## that has been requested.
##
## $1="<component type>"
##
comp.getByType() {
    comp_return=""
    type=$1
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Retrieving components by type: $1..."
    for x in ${compArray[@]}; do
            eval z=(\${${x}[@]})
            eval $z
            if [ $compType = "${type}" ]; then
                comp_return=${z[@]}
            fi
    done
    if [[ "${VERBOSE:-0}" -eq 1 ]]; then
        if [ ! -z ${comp_return} ]; then
            echo "Returning 0"
            log_end_msg 0
        else
            echo "Returning 1"
            log_end_msg 1
        fi
    fi
}

## comp.getByName allows the user to pass the type of component for the local system they
## would like to receive and in return sets $comp_return in the local scope to the array
## that has been requested.
##
## $1="<component type>"
##
comp.getByName() {
    comp_return=""
    name=$1
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Retrieving component by name: $1..\
."
    for x in ${compArray[@]}; do
            eval z=(\${${x}[@]})
            eval $z
            if [ $x = "comp_${name}" ]; then
            comp_return=${z[@]}
            fi
    done
    if [[ "${VERBOSE:-0}" -eq 1 ]]; then
    if [ ! -z "${comp_return}" ]; then
        log_end_msg 0
        else
        log_end_msg 1
        fi
    fi
}


## createDir allows the user to pass a directory to be created.
##
## $1="/dir/to/be/created/"
##
createDir() {
    dir=$1
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Creating ${dir} directory..."
    if [ ! -d $dir ]; then
    mkdir -p $dir
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg $? && return $? || return $?
    fi
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 1 && return 1 || return 1
}

## removeDir allows the user to pass a directory to be removed.
##
## $1="/dir/to/be/removed/"
##
removeDir() {
    dir=$1
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_begin_msg "Removing ${dir} directory..."
    if [ -d $dir ]; then
    rm -rf $dir
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg $? && return $? || return $?
    fi
    [[ "${VERBOSE:-0}" -eq 1 ]] && log_end_msg 1 && return 1 || return 1
}


# returns OK if $1 contains $2
strstr() {
  [[ "${1#*$2*}" = "$1" ]] && return 1
  return 0
}

set_environmentvars() {
    HPCC_CONFIG=${HPCC_CONFIG:-@CONFIG_DIR@/@ENV_CONF_FILE@}

    ## Retrieve the Section to use from environment variable and if not set
    ## use default of "DEFAULT"
    ##
    SECTION=${SECTION:-DEFAULT}

    cfg.parser ${HPCC_CONFIG}
    cfg.section.${SECTION}

    if [ -n "${umask}" ]; then
        umask $umask
    fi
}

set_componentvars() {
    compName=$1
    comp.getByName ${compName}
    compPath=`echo $comp_return | cut -d ' ' -f 2 | cut -d '=' -f 2 `
    compType=`echo $comp_return | cut -d ' ' -f 1 | cut -d '=' -f 2 `
    PIDPATH=${pid}/init_${compName}.pid
    LOCKPATH=${lock}/$compName/$compName.lock
    COMPPIDPATH=${pid}/${compName}.pid
}

validate_configuration() {
    if ! validation_error=$(${path}/sbin/configgen -env ${envfile} -validateonly 2>&1); then
        log  "validate_configuration(): validation failure ${envfile}"
        log  "${validation_error}"
        echo -e "\033[31merror\033[0m: configgen xml validation failure"
        exit 1
    fi
}

get_commondirs() {
    DIRS=$(${path}/sbin/configgen -env ${envfile} -id ${path}/componentfiles/configxml -listcommondirs)
    rc=$?
    if [[ $rc -ne 0 ]]; then
        log  "get_commondirs(): failure in configgen call"
        echo -e "\033[31merror\033[0m: get_commondirs() -> failure in configgen call"
        exit 1
    fi
    dir.parser ${DIRS}
}

configGenCmd() {
    configcmd="@ADMIN_PATH@/configgen -env @CONFIG_DIR@/@ENV_XML_FILE@ -od @RUNTIME_PATH@ -id @COMPONENTFILES_PATH@/configxml -c ${compName}"
    log "$configcmd"
    if [ "$(whoami)" != "${user}" ]; then
        su ${user} -c "$configcmd" 2>/dev/null
    else
        ${configcmd} 2>/dev/null
    fi
    rc=$?
    if [[ $rc -ne 0 ]]; then
        log  "configGenCmd(): failure in configgen call"
        echo -e "\033[31merror\033[0m: configGenCmd() -> failure in configgen call"
        exit 1
    fi
}

createRuntime() {
    # Creating Directories for runtime environment
    if [ ! -d ${runtime} ]; then
        createDir ${runtime}
    fi

    if [ ! -d ${pid} ]; then
        createDir ${pid}
    fi

    if [ ! -d ${lock} ]; then
        createDir ${lock}
    fi

    if [ ! -d ${log} ]; then
        createDir ${log}
    fi


    chown -c $user:$group ${runtime}  1> /dev/null 2>/dev/null
    chown -c $user:$group ${pid}  1> /dev/null 2>/dev/null
    chown -c $user:$group ${lock} 1> /dev/null 2>/dev/null
    chown -c $user:$group ${log}  1> /dev/null 2>/dev/null

    [ -z "$compName" ] && return

    # Creating Component Specific directories
    # Creating pidfile specific directory and changing its owner permissions
    if [ ! -d "$pid/$compName" ]; then
        log "Creating Pidfile Directory $pid/$compName"
        createDir "$pid/$compName"
    fi

    if [ ! -d "$lock/$compName" ]; then
        log "Creating Lockfile Directory $lock/$compName"
        createDir "$lock/$compName"
    fi

    if [ ! -d "$log/$compName" ]; then
        log "Creating Log Directory $log/$compName"
        createDir "$log/$compName"
    fi

    # Creating runtime specific directory and changing its owner permissions
    if [ ! -d $compPath ]; then
        log "Creating Runtime Directory $compPath"
        createDir "$compPath"
    fi

    #change the permission for all component directory under var
    chown -c $user:$group "$pid/$compName"  1> /dev/null 2>/dev/null
    chown -c $user:$group "$lock/$compName"  1> /dev/null 2>/dev/null
    chown -c $user:$group "$log/$compName"  1> /dev/null 2>/dev/null
    chown -c $user:$group "$compPath"  1> /dev/null 2>/dev/null

    dir.getByName data
    chown -c $user:$group "${dir_return}"  1> /dev/null 2>/dev/null
    dir.getByName data2
    chown -c $user:$group "${dir_return}"  1> /dev/null 2>/dev/null
    dir.getByName data3
    chown -c $user:$group "${dir_return}"  1> /dev/null 2>/dev/null
    dir.getByName query
    chown -c $user:$group "${dir_return}"  1> /dev/null 2>/dev/null
    dir.getByName mirror
    chown -c $user:$group "${dir_return}"  1> /dev/null 2>/dev/null
}

# Check status of component
# Arg 1     string compType
# Arg 2     string compName
# Arg 2     0:1 sentinel file check
# rc 0      up
# rc 1      down
# rc 2      spawning process
check_status() {
    local compType=$1
    local compName=$2
    local sentinelCheck=$3

    checkPidExists @PID_PATH@/init_${compName}.pid
    if [[ $? -eq 0 ]]; then
        checkPidExists @PID_PATH@/${compName}.pid
        if [[ $? -eq 0 ]]; then
            [[ "${sentinelCheck}" -eq 0 ]] && return 0
            ! checkSentinelFile && return 0
            return 2
        fi
        return 2
    else
        return 1
    fi
}

# cleanup all standard files made during runtime
cleanupRuntimeEnvironment() {
    unlock ${lock}/${compName}/${compName}.lock
    removePid ${pid}/init_${compName}.pid
    removePid ${pid}/${compName}.pid
}

#--------------------------------------------------------------------------------
#                        Component Specific Functions
#--------------------------------------------------------------------------------


# Start component specified
# Arg 1     string compType
# Arg 2     string compName
# rc 0      successful
# rc 1      failed
start_component() {
    compType=$1
    compName=$2
    local sentinelCheck=1
    local _rc=0
    local _wait=120

    # Creating dirs for component if not present
    createDir @LOG_PATH@/${compName}
    createDir @RUNTIME_PATH@/${compName}

    # Stepping into new working directory
    cd @RUNTIME_PATH@/${compName} || return 1
    
    # check status and return if already up or spawning 
    check_status ${compType} ${compName} ${sentinelCheck}
    _rc=$?
    [[ ${_rc} -eq 0 ]] && printf "Running  %-21s" "${compName} ..." && log_success_msg && return 0
    [[ ${_rc} -eq 2 ]] && printf "Spawning %-21s" "${compName} ..." && log_success_msg && return 2

    printf "Starting %-21s" "$compName ..."
    log "Starting $compName"

    # setup limits for environment
    limits=(
      MIN_Hn_nofile="32768"
      MIN_Hc_core="unlimited"
      MIN_Hu_nproc="8192"
      MIN_Hr_rtprio="4"
      MIN_Hl_memlock="unlimited" )

    local i=0
    for element in "${limits[@]}"; do
        flag="-${element:4:2}"
        value=${element##*"="}

        default_value=$( ulimit $flag )
        if [[ "$value" != "unlimited" ]] && ([[ "$default_value" == "unlimited" ]] || [[ "$default_value" -gt "$value" ]]); then
            _temp=${element%%"="*}
            _temp="${_temp}=${default_value}"
            limits[i]=$_temp
        fi
        flag="-${element:5:1}"
        ulimit $flag ${limits[i]##*"="} 1>/dev/null 2>&1
        i=$((i+1))
    done

    # setup umask
    UMASK_ARG=""
    if [[ -n "${umask}" ]]; then
        UMASK_ARG="--umask ${umask}"
    fi

    # start the process in background
    startcmd="${START_STOP_DAEMON} -S -p @PID_PATH@/init_${compName}.pid -c ${user}:${group} -d @RUNTIME_PATH@/${compName} ${UMASK_ARG} -m -x @EXEC_PATH@/init_${compType} -b"
    log "${startcmd}"
    eval $startcmd

    # check for spawning health
    while [[ ${_wait} -gt 0 ]]; do
        _wait=`expr ${_wait} - 1`
        check_status ${compType} ${compName} ${sentinelCheck} 
        _rc=$?
        [[ ${_rc} -eq 0 ]] && log_success_msg && return 0
        [[ ${_rc} -eq 1 ]] && log_failure_msg && return 1
        sleep 1
    done

    # timeout met and process still spawning
    log_timeout_msg
    log "${compName} has timed out, but may still be starting"
    return 2
}

# Stop component specified
# Arg 1     string compType
# Arg 2     string compName
# rc 0      successful
# rc 1      failed
stop_component() {
    compType=$1
    compName=$2
    local sentinelCheck=1
    local _rc=0
    local _wait=30

    # Creating dirs for component if not present
    printf "Stopping %-21s" "${compName}... "

    check_status ${compType} ${compName} 0
    _rc=$?
    if [[ $_rc -eq 1 ]]; then
        log_success_msg
        return 0;
    fi

    stopcmd="${START_STOP_DAEMON} -K -p @PID_PATH@/init_${compName}.pid"
    log "$stopcmd"
    eval $stopcmd

    [[ "${compType}" = "dali" ]] && _wait=720
    while [[ $_rc -ne 1 && $_wait -gt 0 ]]; do
        check_status ${compType} ${compName} ${sentinelCheck}    
        _rc=$?
        ((WAITTIME--))
        if ! ((WAITTIME % 60)); then
            echo "still stopping ..."
        fi
        [[ $_rc -ne 1 ]] && sleep 1
    done

    if [[ $_rc -ne 1 ]]; then
        log_failure_msg
        return 1
    fi

    log_success_msg
    rm -f @PID_PATH@/init_${compName}.pid
    return 0
}

# status of component specified
# Arg 1     string compType
# Arg 2     string compName
# rc 0      successful
# rc 1      failed
status_component() {
    compType=$1
    compName=$2
    local sentinelCheck=1
    local _rc=0

    if [[ ${_use_systemd:-1} -eq 0 ]]; then
        systemctl is-active ${compType}@${compName}.service 1>/dev/null 2>&1
        _rc=$?
    else
        check_status ${compType} ${compName} ${sentinelCheck}
        _rc=$?
    fi
    # getpid returns __pidValue
    getPid @PID_PATH@/${compName}.pid

    if [[ $_rc -gt 0 && $_rc -ne 2 ]]; then
        log "${compName} ---> Stopped"
        printf "%-15s is stopped" "$compName"
    elif [[ $_rc -eq 2 ]]; then
        log "${compName} ---> Spawning"
        printf "%-15s is spawning" "$compName"
    elif [[ "${compType}" == "thor" ]]; then
        if [[ -e @RUNTIME_PATH@/${compName}/slaves && -e @RUNTIME_PATH@/${compName}/setvars ]]; then
            source @RUNTIME_PATH@/${compName}/setvars
            __slaves=$(cat @RUNTIME_PATH@/${compName}/slaves | wc -l)
            __slaveprocesses=$((${__slaves} * ${slavespernode}))
            log "${compName} ---> Running ( pid ${__pidValue} ) with {__slaveprocesses} slave process(es)"
            printf "%-15s ( pid %8s ) is running with %s slave process(es) ..." "${compName}" "${__pidValue}" "${__slaveprocesses}"
        else
            log "${compName} missing file in @RUNTIME_PATH@/${compName} necessary for status_component"
            printf "${compName} missing file in @RUNTIME_PATH@/${compName} necessary for status_component"
        fi
    else
        log "${compName} ---> Running ( pid ${__pidValue} )"
        printf "%-15s ( pid %8s ) is running ..." "${compName}" "${__pidValue}"
    fi
    echo ""
    return $_rc
}

create_dropzone() {
    OIFS=${IFS}
    unset IFS
    dropzones=$(@ADMIN_PATH@/configgen -env @CONFIG_DIR@/@ENV_XML_FILE@ -listdirs)
    rc=$?
    if [[ $rc -ne 0 ]]; then
        log  "create_dropzone(): failure in configgen call"
        echo -e "\033[31merror\033[0m: create_dropzone() -> failure in configgen call"
        exit 1
    fi
    for D in ${dropzones} ; do
        # Creating DropZone directory
        if [ ! -d ${D} ]; then
            mkdir -p $D > /dev/null 2>&1
            chown -c $user:$group $D > /dev/null 2>&1
            chmod 777 $D > /dev/null 2>&1
        fi
    done
    IFS=${OIFS}
}

check_user(){
    USER=$1
    id ${USER} > /dev/null
    if [ $? -eq 0 ];
    then
        return 1
    else
        return 0
    fi
}

check_group(){
    GROUP=$1
    touch /tmp/file.$$
    chgrp ${GROUP} /tmp/file.$$ > /dev/null 2>&1
    if [ $(stat -c %G /tmp/file.$$ 2>/dev/null || stat -f %Sg /tmp/file.$$ 2>/dev/null) = "${GROUP}" ];
    then
        rm -rf /tmp/file.$$
        return 1
    else
        rm -rf /tmp/file.$$
        return 0
    fi
}


add_user(){
    USER=$1
    GROUP=$2
    HOMEPATH=$3
    check_user ${USER}
    UFND=$?
    check_group ${GROUP}
    GFND=$?
    if [ ${GFND} -eq 1 ];
    then
        if [ ${UFND} -eq 1 ];
        then
            printf "Adding %s to group %s ..." "${USER}" "${GROUP}"
            CURRGROUPS=`id -nG ${USER} | tr ' ' ','`
            usermod -G ${CURRGROUPS},${GROUP} -c "${USER} Runtime User" ${USER}
            if [ $? -eq 0 ];
            then
                log_success_msg
            else
                log_failure_msg "Failed to add ${USER} to group ${GROUP}."
                return 1
            fi
        else
            printf "Adding %s to system ..." "${USER}"
            useradd -s ${SHELL} -r -m -d ${HOMEPATH} -g ${GROUP} -c "${USER} Runtime User" ${USER}
            passwd -l ${USER} 1>/dev/null 2>&1
            if [ $? -eq 0 ];
            then
                log_success_msg
            else
                log_failure_msg "Failed to add ${USER} to system."
                return 1
            fi
        fi
    else
        printf "Creating group %s ..." "${GROUP}"
        groupadd ${GROUP}
        if [ $? -eq 0 ];
        then
            log_success_msg
        else
            log_failure_msg "Failed to add group ${GROUP} to system."
            return 1
        fi
        if [ ${UFND} -eq 1 ];
        then
            printf "Adding %s to group %s ..." "${USER}" "${GROUP}"
            CURRGROUPS=`id -nG ${USER} | tr ' ' ','`
            usermod -G ${CURRGROUPS},${GROUP} -c "${USER} Runtime User" ${USER}
            if [ $? -eq 0 ];
            then
                log_success_msg
            else
                log_failure_msg "Failed to add ${USER} to group ${GROUP}."
                return 1
            fi
        else
            printf "Adding %s to system ..." "${USER}"
            useradd -s ${SHELL} -r -m -d ${HOMEPATH} -g ${GROUP} -c "${USER} Runtime User" ${USER}
            passwd -l ${USER} 1>/dev/null 2>&1
            if [ $? -eq 0 ];
            then
                log_success_msg
            else
                log_failure_msg "Failed to add ${USER} to system."
                return 1
            fi

        fi
    fi
    return 0
}

is_root(){
    if [ "$(id -u)" != "0" ]; then
        echo "This operation can be executed only by ROOT user"
        exit
    fi
}

is_user(){
    USER=$1
    if [ "$(id -u)" != "$(id -u ${USER})" ]; then
        echo "This operation should be run as ${USER}"
        exit
    fi
}


##
## Usage: is_python_installed <verion>
##    <version> (optional): format: <major>.<minor>
##         when specified return 0 if python version is equal or higher
##         than <version>. Otherwise return 1
##
is_python_installed () {
   _expected_version=$1

   which python > /dev/null 2>&1
   [ $? -ne 0 ] && return 1

   if [ -n "$_expected_version" ]
   then
      _actual_version=$(python -V 2>&1 | cut -d' ' -f 2 | cut -d '.' -f -2)
      echo $_actual_version | grep -q -e "^[0-9]\.[0-9]$"
      [ $? -ne 0 ] && return 1

      if [[ "$_actual_version" < "$_expected_version" ]]
      then
         return 1
      fi
   fi
   return 0
}

##
## Usage: run_cluster <script>  <flag> <ip list file>
##   script:  script file to run
##   flag (optional) :  1: exclude local host 0: run the script on all hosts in the cluster
##   ip list file (optional): when specified the ip list will be used instead of from
##      environment.xml
##
run_cluster() {
    _cmd=$1
    _exclude_local=0
    [[ -n "$2" ]] && _exclude_local=$2

    if [[ -z "$3" ]]; then
        validate_configuration
        t_IP=$(@INSTALL_DIR@/sbin/configgen -env @CONFIG_DIR@/@ENV_XML_FILE@ -machines)
        rc=$?
        if [[ $rc -ne 0 ]]; then
            log  "run_cluster(): failure in configgen call"
            echo -e "\033[31merror\033[0m: run_cluster() -> failure in configgen call"
            exit 1
        fi
        IPS0=$(echo $t_IP | awk 'BEGIN {FS=",";RS=" ";} {print $1;}' | sort | uniq)
    else
        IPS0=$(cat $3)
    fi

   # Exclude local ip if requested
   if [ $_exclude_local -eq 1 ]
   then
      local_IPS=$(/sbin/ifconfig -a | grep "[[:space:]]*inet[[:space:]]" | \
          sed 's/^[[:space:]]\+//g' | cut -d ' ' -f 2 | cut -d':' -f 2)
      for ip in $IPS0
      do
         _found=0
         for lip in $local_IPS
         do
            if [ "$ip" = "$lip" ]
            then
               _found=1
               break
            fi
         done
         [ $_found -eq 0 ] && IPS="${IPS:+"$IPS\\n"}$ip"
      done
      IPS=$(echo -e $IPS)
   else
      IPS=$IPS0
   fi

   _num_hosts=$(echo $IPS | wc -w)
   echo "Total $_num_hosts to process"
   _num_passed=0
   _num_failed=0
   _num_processed=0
   _pregress=0
   _log_file=@LOG_PATH@/cluster/se_$(basename $_cmd)_$(date +%Y%m%d_%H%M%S).log
   [ ! -d @LOG_PATH@/cluster ] && mkdir -p @LOG_PATH@/cluster
   [ -e $_log_file ] && rm -rf $_log_file
   if [ "$RUN_CLUSTER_DISPLAY_OUTPUT" != "TRUE" ]
   then
      echo ""
      echo  -ne "Execution progress: ${_progress}%, succeed: $_num_passed, failed: $_num_failed \r"
   fi
   for ip in $IPS
   do
      if [ "$RUN_CLUSTER_DISPLAY_OUTPUT" = "TRUE" ]
      then
          echo
          eval $_cmd $ip | tee -a $_log_file 2>&1
      else
          eval $_cmd $ip >> $_log_file 2>&1
      fi

      if [ ${PIPESTATUS[0]} -eq 0 ]
      then
         _num_passed=$(expr $_num_passed \+ 1)
      else
         _num_failed=$(expr $_num_failed \+ 1)
      fi

      _num_processed=$(expr $_num_processed \+ 1)
      if [ "$RUN_CLUSTER_DISPLAY_OUTPUT" != "TRUE" ]
      then
         _progress=$(expr $_num_processed \* 100  / $_num_hosts)
         echo  -ne "Execution progress: ${_progress}%, succeed: $_num_passed, failed: $_num_failed \r"
      fi
   done

   echo ""
   if [ $_num_passed -ne $_num_processed ]
   then
      echo "There are errors when executing $(basename $_cmd)"
      echo "Check log $_log_file for details."
   else
      echo "$(basename $_cmd) run successfully on all hosts in the the cluster."
   fi
   echo ""
}

##
## Usage: cluster_tools_init
##    Initialization for cluster tools
##
cluster_tools_init() {

   set_environmentvars

   #_cmd_prefix=
   #[ "$(id -u)" != "0" ] && _cmd_prefix=sudo

   # Check and set log directory
   CLUSTER_LOG_DIR=@LOG_PATH@/cluster
   #[ ! -d $LOG_DIR ]  && ${_cmd_prefix} @INIT_PATH@/hpcc-init status > /dev/null 2>&1
   [ ! -d $LOG_DIR ]  && @INIT_PATH@/hpcc-init status > /dev/null 2>&1

   [ ! -d $CLUSTER_LOG_DIR ] && mkdir -p $CLUSTER_LOG_DIR
   # workaround inconsistency of stat command
   cluster_log_dir_owner=$(ls -ld $CLUSTER_LOG_DIR | awk '{print $3}')
   [ "$cluster_log_dir_owner" != "${user}" ] && ${_cmd_prefix} chown ${user}:${group} $CLUSTER_LOG_DIR
}

## TODO: get rid of this if possible for update of init system
##
## Cleanup component
##
cleanup_component() {

    # used to get variables for frunssh
    # Necessary for when we source in setvars, since we aren't using the start-stop-demon the $HOME will
    # be set to /root or some other location, and not the appropriate directory, causing problems
    # with $SSHidentityfile
    set_environmentvars
    HOME=${home}/${user}
    instancedir=${runtime}/${compName}
    if [ -e $instancedir/setvars ]; then
        source $instancedir/setvars
    fi

    # grab the PID of our component, and in the case it doesn't exist, the pid of the init file (in case
    # it somehow is still alive)
    local cpidpath=${COMPPIDPATH}
    if [ "${compType}" = "thor" ] && [ ! -f "${cpidpath}" ]; then
        # if run_thor is sent a SIGKILL, the normal COMPPIDPATH file will no longer exist, we catch this and
        # fall back to the {compName}_master.pid file that will still be available.
        cpidpath=$( echo $cpidpath | sed 's/\.pid/_master.pid/' )
    fi
    getPid ${cpidpath}
    local mpid=$__pidValue
    if [ $mpid -eq 0 ]; then
        getPid ${PIDPATH}
        mpid=$__pidValue
    fi

    # start with SIGTERM and then follow up with SIGKILL if unsuccessful and force flag is set
    if [ $mpid -ne 0 ] ; then
        # use the mpid we collected to grab the group pid of the process, to kill off all siblings at once
        local pgid=$( ps -p $mpid -o pid,pgid | grep $mpid | awk '{ print $2 }' )

        kill -SIGTERM -$pgid > /dev/null 2>&1
        sleep 1
        local WAITTIME=60
        local RUNNING=1
        while [[ ${WAITTIME} -gt 0 ]]; do
            ((WAITTIME--))
            kill -0 -$pgid &> /dev/null
            if [[ $? -ne 0 ]];then
                log "${compName} orphans cleaned up"
                RUNNING=0
                break;
            else
                [[ "((WAITTIME % 5))" -eq 0 ]] && log "Waiting for ${compName} orphans to cleanup gracefully"
                sleep 1
            fi
        done

        # if still running and Force option is set, send sigkill
        if [[ ${RUNNING} -eq 1 && ${FORCE:-NO_FORCE} == "FORCE" ]]; then
            log "WARNING Force flag is set"
            log "WARNING sending SIGKILL to orphans in pid group for ${compName}"
            log "INFO    If sockets used by the process are still in a TIME_WAIT state"
            log "INFO       due to unclean shutdown, the operating system possibly will"
            log "INFO       not release them until 60 seconds after SIGKILL was sent"
            kill -SIGKILL -$pgid > /dev/null 2>&1
            [[ $? -eq 0 ]] && RUNNING=0
        elif [[ ${RUNNING} -eq 1 && ${FORCE:-NO_FORCE} == "NO_FORCE" ]]; then
            log "INFO    Unable to kill with SIGTERM.  Use --force|-f to attempt SIGKILL"
        fi
    fi
    return $RUNNING
}
