/**********************/
/*    Redis Plugin    */
/**********************/

This ECL plugin library is for the persistent key/value store 'redis' (http://redis.io). Utilising the C API
'hiredis' (http://github.com/redis/hirediscontains) and the event manager library libev
(http://software.schmorp.de/pkg/libev.html). Dependency notes at bottom.

It contains three modules - 'sync', 'async', and 'locking'. Each one containing the core GET/SET variations
(by ECL type) differing at their base communication layer with the redis servers. 'async' and 'locking' both
use the asynchronous hiredis API, and 'sync' the synchronous API. Due to the nature of ECL as a declarative
and non-functional language, no async activity breaches directly into the ECL layer in a usable manner, i.e.
callbacks can not be used by the ECL activities EVENT and/OR WAIT. This being said, due to the current
constraints the ECL plugin infrastructure, some async logic does actually surface into the ECL layer but is
not directly accessible by any ECL, other than via these plugin functions. Such logic only concerns the
pub/sub nature of redis based around a locking mechanism on keys.

A full list of redis commands can be found at http://redis.io/commands of which the following are directly
wrapped in the sync module only:

BOOLEAN Exists(CONST VARSTRING options, CONST VARSTRING key, UNSIGNED database = 0)
FlushDB(CONST VARSTRING options, UNSIGNED database = 0)
Del(CONST VARSTRING options, CONST VARSTRING key, UNSIGNED database = 0)
Persist(CONST VARSTRING options, CONST VARSTRING key, UNSIGNED database = 0)
Expire(CONST VARSTRING options, CONST VARSTRING key, UNSIGNED4 expire, UNSIGNED database = 0)
INTEGER DBSize(CONST VARSTRING options, UNSIGNED database = 0)

The redis command 'INFO ALL' is called once per instance of server:port combination and is written to the log
file (sync only). Only sync connections to a single redis server:port are cached internally, changes in db are
handled internally by the redis command 'SELECT DB'.

The core SET functions have the prototype pattern (e.g.)
SetString(CONST VARSTRING options, CONST VARSTRING key, CONST STRING value, UNSIGNED database = 0,  UNSIGNED4 expire = 0 /*days*/)
The core GET functions have the prototype pattern (e.g.)
STRING GetString(CONST VARSTRING options, CONST VARSTRING key, UNSIGNED database = 0)
'options' is the redis server ip:port in the format '--SERVER=<ip>:<port>'. This defaults to localhost:6379 if
omitted.

This pattern differs in the 'locking' module taking the following forms:

STRING SetString(UNSIGNED8 keyPtr, CONST STRING value, UNSIGNED4 expire = 0)
STRING GetString(UNSIGNED8 keyPtr)

Note that SET also returns a value. This is the vaue just set and not a wrapper for the redis command
'GETSET'. See the section on locks.

Within the sync and async modules, SETs overwrite their key values. The respective GETs (other than for
STRINGs) will fail upon reuqest for a non-existent key. If you're not sure use EXISTS first (certain
precaution has to be taken when using multiple plugin calls within ECL, regarding their actual execution
timing. Remember ECL is declarative and may decide to hoist your calls.) GetString will return an empty
STRING upon a cache miss.

/**********************/
/*     Locking        */
/**********************/
The locking module was designed with a particular use in mind. This concerns the scenario where multiple
ECL clients/threads wish to read the same key, at the same time, from the redis server and encounter an
non-existent key (cache miss). It is thus desirable to be able to then SET this missing key however, only
once and by one client/thread. This is such as to prevent redundant evaluation/retrieval of the new value
within this race condition. The core of this design is to have one instant (the first/race-winner), 'lock'
the key and then evaluate/retrieve the new value. The others clients/threads (race-losers) subscribe to
the locked key and wait for the winner to set the new value and publish the fact that it has done so.
This is done using the redis pub/sub paradigm. Note - in this implementation all publishes contain as
their message the very value that was just set, thus not requiring the subscriber to send subsequent GET
(this is not just an efficiency concern).

A note about the redis pub/sub mechanism is that it is completely independent from the keyspace and database
index. Subscribers do so to a 'channel' (any given char string) only and not the particular key in question.
Any publication on this channel is heard by all current subscribers regardless of database index. This being
said, this plugin implementation does not allow for direct channel selection, instead it IS in fact dependent
on the keyspace and database. This is done so in a one-to-one and unique fashion such that a given key on a
given server:port and database creates a unique channel that is independent of plugin call and client/thread.

Since redis does not implicitly support locks, it is this 'channel', itself, that represents the notion of a
lock within this plugin library. These channels/locks are a particular string prefixed by the string
'redis_ecl_lock'. When locked the key's value contains this channel/lock string. This is so lock acknowledging
GETs can subscribe to the key via the correct channel, being the  locked keys vaue itself.

Again, since redis does not implicitly support locks, such locking mechanisms as the above are not
enforced/asserted by the server. They have to be honoured/acknowledged by the client instead.
e.g. the sync module does not honour such locking and will SET and GET regardless. The async module also doesn't
honour locks however, upon attempting to SET a locked key, it will do so but then publish to the fact that
it has done so. This is implemented by using the redis command "GETSET key", i.e. overwriting the value regardless
but if the overwritten value happened to be a lock it then publishes the SET value on the retrieved channel.

How to use the locking module?

Based on the above described scenario, ideally this would be implemented by the following function design:

GET(options, key, theECLFunctionToCallUponMiss(params));

Unfortunately, it is not currently possible to pass ECL functions into SERVICE definitions, such as this plugin
is. It should also be noted that such functionality as communicating with a live and dynamic external service
(i.e. redis) requires great precaution within the declarative and non-functional paradigm of ECL. The primary
power to using ECL is that you tell it what you want and it figures out how to do it. These plugin function
calls can seriously hinder this capability due to their runtime execution nature.

Thus, to use the locking module two options are possible:

UNSIGNED lock := locking.GetLockObject(options, key, database);
STRING x := locking.GetString(lockObject);
IF( LENGTH(x=0), locking.SetString(lockObject, newValue), x);

for STRINGs only or for everything else (INTEGER example used here):

UNSIGNED lock := locking.GetLockObject(options, key, database);
IF( locking.MissThenLock(lockObject), locking.SetInteger(lockObject, newInt), locking.GetInteger(lockObject));

The two differ in implementation regarding the location of subscription (upon a cache miss). The first example
locks and subscribes within the initial GET. The winning locker returns an empty string indicating that no key
existed and that it has locked (see brief note on exceptions below). The losers subscribe and remain in this call.
The winner only enters locking.SetString(lockObject, newValue) where it sets and publishes


/**********************/
/*       REDIS        */
/**********************/
(WIP)
apt-get install redis-server #includes redis-cli
apt-get insatll libhiredis-dev
apt-get install libev-dev

