<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="OUTPUT">
  <title>OUTPUT</title>

  <para><emphasis><emphasis role="bold">[</emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT<indexterm>
      <primary>OUTPUT action</primary>
    </indexterm><indexterm>
      <primary>OUTPUT</primary>
    </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
  role="bold"> [, [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">] [</emphasis><emphasis>,file </emphasis><emphasis
  role="bold">[</emphasis><emphasis>thorfileoptions </emphasis><emphasis
  role="bold"> ] ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold">
  NOXPATH<indexterm>
      <primary>NOXPATH</primary>
    </indexterm> ] </emphasis><emphasis role="bold">[, UNORDERED | 
    ORDERED(</emphasis> <emphasis>bool </emphasis><emphasis role="bold">) ] [, 
    STABLE | UNSTABLE ] [, PARALLEL [ (</emphasis> <emphasis>numthreads
  </emphasis><emphasis role="bold">) ] ] [, ALGORITHM(</emphasis>
  <emphasis>name </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] 
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">, 
  [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">]</emphasis><emphasis> ,file
  </emphasis><emphasis>,</emphasis><emphasis role="bold"> CSV<indexterm>
      <primary>CSV</primary>
    </indexterm> [ (</emphasis><emphasis>csvoptions</emphasis><emphasis
  role="bold">) ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>csvfileoptions </emphasis><emphasis
  role="bold"> ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] 
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">, 
  [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">]</emphasis><emphasis> , file </emphasis><emphasis role="bold">
  </emphasis><emphasis>,</emphasis><emphasis role="bold"> XML<indexterm>
      <primary>XML</primary>
    </indexterm> [ (</emphasis><emphasis>xmloptions</emphasis><emphasis
  role="bold">) ]</emphasis><emphasis role="bold"> </emphasis><emphasis
  role="bold">[</emphasis><emphasis>xmlfileoptions </emphasis><emphasis
  role="bold"> ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] 
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">, 
  [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">]</emphasis><emphasis> , file </emphasis><emphasis role="bold">
  </emphasis><emphasis>,</emphasis><emphasis role="bold"> JSON<indexterm>
      <primary>JSON</primary>
    </indexterm> [ (</emphasis><emphasis>jsonoptions</emphasis><emphasis
  role="bold">) ]</emphasis><emphasis role="bold"> </emphasis><emphasis
  role="bold">[</emphasis><emphasis>jsonfileoptions </emphasis><emphasis
  role="bold"> ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] <emphasis role="bold">[, UNORDERED | ORDERED(</emphasis> <emphasis>bool
  </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] [, PARALLEL [ 
  (</emphasis> <emphasis>numthreads </emphasis><emphasis role="bold">) ] ] [, 
  ALGORITHM(</emphasis> <emphasis>name </emphasis><emphasis role="bold">) ] 
  );</emphasis></emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] 
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">, 
  [</emphasis><emphasis> format </emphasis><emphasis role="bold">]
  </emphasis><emphasis> ,</emphasis><emphasis role="bold">PIPE<indexterm>
      <primary>PIPE</primary>
    </indexterm>(</emphasis><emphasis> pipeoptions </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] 
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">
  [,</emphasis><emphasis> format </emphasis><emphasis role="bold">]
  </emphasis><emphasis>, </emphasis><emphasis role="bold">NAMED<indexterm>
      <primary>NAMED</primary>
    </indexterm>(</emphasis><emphasis> name </emphasis><emphasis role="bold">) 
    [,EXTEND<indexterm>
      <primary>EXTEND</primary>
    </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
  role="bold">ALL<indexterm>
      <primary>ALL</primary>
    </indexterm>] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> expression
  </emphasis><emphasis role="bold">[</emphasis><emphasis>,</emphasis><emphasis
  role="bold"> NAMED(</emphasis><emphasis> name </emphasis><emphasis
  role="bold">) ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> recordset 
  ,</emphasis><emphasis role="bold"> THOR<indexterm>
      <primary>THOR</primary>
    </indexterm> </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH 
  ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis>
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name
  </emphasis><emphasis role="bold">) ] );</emphasis></para>

  <para><informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="93.80pt" />

        <colspec />

        <tbody>
          <row>
            <entry><emphasis>attr</emphasis></entry>

            <entry>Opcional. O nome da ação transforma a ação em uma 
	    definição; consequentemente, não é executado até que 
            <emphasis>attr</emphasis>  seja usado como ação.</entry>
          </row>

          <row>
            <entry><emphasis>recordset</emphasis></entry>

            <entry>O conjunto de registros para processamento. Pode ser o nome 
	    de um dataset ou de um record set derivado de algumas condições de 
	    filtro, ou qualquer expressão que resulte em um record set 
	    derivado.</entry>
          </row>

          <row>
            <entry><emphasis>format</emphasis></entry>

            <entry>Opcional. O formato dos registros de resultado. Se omitido, 
	    todos os campos em  <emphasis>recordset</emphasis>  serão 
	    resultados. Se não for omitido, deve ser o nome de uma definição 
	    de estrutura RECORD previamente definida ou um layout de registro 
	    "dinâmico” dentro de chaves ({}), e deve atender aos mesmos 
	    requisitos da estrutura RECORD para a função TABLE (a forma "corte 
	    vertical") definindo o tipo, nome e origem dos dados para cada 
	    campo.</entry>
          </row>

          <row>
            <entry><emphasis>file</emphasis></entry>

            <entry>Opcional. O nome lógico do arquivo no qual os registros 
	    serão gravados. Consulte a seção Escopo e Nomes de arquivos 
	    lógicos da Referência de Linguagem para obter mais detalhes sobre 
	    nomes de arquivos lógicos Se omitido, o fluxo dos dados formatados 
	    retorna apenas para o emissor do comando (linha de comando ou IDE) 
	    e não é gravado em um arquivo de disco.</entry>
          </row>

          <row>
            <entry><emphasis>thorfileoptions</emphasis></entry>

            <entry>Opcional. Uma lista delimitada por vírgula das opções 
	    válidas para um arquivo THOR/FLAT (consulte a seção abaixo para 
	    obter mais detalhes).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">NOXPATH</emphasis></entry>

            <entry>Especifica que qualquer XPATHs definido na estrutura 
            <emphasis>format</emphasis>  ou RECORD do 
            <emphasis>recordset</emphasis>  é ignorado, sendo substituídos 
	    pelos nomes do campo.   Isso permite controlar se XPATHs estão sendo 
	    usados para obter resultados, assim os XPATHs específicos para 
	    entrada xml ou json podem ser ignorados para resultados.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">UNORDERED</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de resultado 
	    não é importante.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ORDERED</emphasis></entry>

            <entry>Especifica a importância da ordem do registro de 
	    resultado.</entry>
          </row>

          <row>
            <entry><emphasis>bool</emphasis></entry>

            <entry>Quando for False, especifica que a ordem do registro de 
	    resultado não é importante. Quando for True, especifica a ordem 
	    padrão do registro de resultado.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">STABLE</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de entrada é 
	    importante.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">UNSTABLE</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de entrada não 
	    é importante.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">PARALLEL</emphasis></entry>

            <entry>Opcional. Tenta avaliar essa atividade em paralelo.</entry>
          </row>

          <row>
            <entry><emphasis>numthreads</emphasis></entry>

            <entry>Opcional. Tenta avaliar essa atividade usando
            <emphasis>numthreads</emphasis> threads</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ALGORITHM</emphasis></entry>

            <entry>Opcional. Substitui o algoritmo usado para essa 
	    atividade.</entry>
          </row>

          <row>
            <entry><emphasis>name</emphasis></entry>

            <entry>O algoritmo a ser usado para essa atividade. Precisa fazer 
	    parte da lista de algoritmos compatíveis com as opções STABLE e 
	    UNSTABLE da função SORT.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">CSV</emphasis></entry>

            <entry>Especifica que o arquivo é um arquivo ASCII delimitado por 
	    campo (geralmente com valores separados por vírgula).</entry>
          </row>

          <row>
            <entry><emphasis>csvoptions</emphasis></entry>

            <entry>Opcional. Uma lista delimitada por vírgula das opções que 
	    definem como o arquivo é delimitado.</entry>
          </row>

          <row>
            <entry><emphasis>csvfileoptions</emphasis></entry>

            <entry>Opcional. Uma lista delimitada por vírgula das opções 
	    válidas para um arquivo CSV (consulte a seção abaixo para obter 
	    mais detalhes).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">XML</emphasis></entry>

            <entry>Especifica que o arquivo é produzido na forma de dados XML 
	    com o nome de cada campo no formato, tornando-se a tag XML para 
	    esses dados do campo.</entry>
          </row>

          <row>
            <entry><emphasis>xmloptions</emphasis></entry>

            <entry>Opcional. Uma lista separada por vírgula das opções que 
	    definem como o arquivo XML de resultado é delimitado.</entry>
          </row>

          <row>
            <entry><emphasis>xmlfileoptions</emphasis></entry>

            <entry>Opcional. Uma lista delimitada por vírgula das opções 
	    válidas para um arquivo XML (consulte a seção abaixo para obter 
	    mais detalhes).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">JSON</emphasis></entry>

            <entry>Especifica que o arquivo é produzido na forma de dados JSON 
	    com o nome de cada campo no formato, tornando-se a tag JSON para 
	    esses dados do campo.</entry>
          </row>

          <row>
            <entry><emphasis>jsonoptions</emphasis></entry>

            <entry>Opcional. Uma lista separada por vírgula das opções que 
	    definem como o arquivo JSON de resultado é delimitado.</entry>
          </row>

          <row>
            <entry><emphasis>jsonfileoptions</emphasis></entry>

            <entry>Opcional. Uma lista delimitada por vírgula das opções 
	    válidas para um arquivo JSON (consulte a seção abaixo para obter 
	    mais detalhes).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">PIPE</emphasis></entry>

            <entry>Indica que o comando especificado é executado com o 
            <emphasis>recordset</emphasis>  fornecido como entrada padrão do 
	    comando.  Este é um pipe de "gravação”.</entry>
          </row>

          <row>
            <entry><emphasis>pipeoptions</emphasis></entry>

            <entry>O nome de um programa a ser executado, que toma o 
            <emphasis>arquivo</emphasis>  como seu fluxo de entrada, juntamente 
	    com as opções válidas para um PIPE de resultado.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">NAMED</emphasis></entry>

            <entry>Especifica o nome do resultado que aparece na workunit. Não 
	    é válido se o parâmetro do arquivo estiver presente. </entry>
          </row>

          <row>
            <entry><emphasis>name</emphasis></entry>

            <entry>Uma constante de string que contém o rótulo do resultado. 
	    Deve ser uma constante de tempo de compilação e deve cumprir com 
	    os requisitos de nomeação de atributo. Este deve ser um rótulo 
	    válido (consulte  <link linkend="Attribute_Name_Rules">Definition 
	    Name Rules</link>)</entry>
          </row>

          <row>
            <entry><emphasis role="bold">EXTEND</emphasis></entry>

            <entry>Opcional. Especifica o acréscimo ao 
            <emphasis>nome</emphasis>  do resultado existente NAMED (NOMEADO) 
	    na workunit. O uso deste recurso exige que todos os OUTPUTs NAMED 
	    (RESULTADOS NOMEADOS) com o mesmo nome tenham a opção EXTEND 
	    disponível, incluindo a primeira instância.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ALL</emphasis></entry>

            <entry>Opcional. Especifica todos que todos os registros no 
            <emphasis>recordset</emphasis>  são enviados ao ECL IDE.</entry>
          </row>

          <row>
            <entry><emphasis>expression</emphasis></entry>

            <entry>Qualquer expressão ECL válida que resulta em um único valor 
	    escalar.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">THOR</emphasis></entry>

            <entry>Especifica que o record set resultante é armazenado como um 
	    arquivo em disco “de propriedade” da workunit, em vez de ser 
	    armazenado diretamente dentro da workunit. O nome do arquivo no 
	    DFU é scope::RESULT::workunitid.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable></para>

  <para>A ação  <emphasis role="bold">OUTPUT </emphasis> um resultado do recordset 
  no supercomputador com base na forma e opções que você escolher. 
  Se nenhum  <emphasis>arquivo</emphasis>  for especificado para gravação, 
  o resultado é armazenado na workunit e retornado para o programa que o acionou 
  na forma de fluxo de dados.</para>

  <sect2 id="OUTPUT_Field_Names">
    <title>Nome dos Campos OUTPUT</title>

    <para>Os nomes de campo em formato de registro "dinâmico" {...} devem ser 
    exclusivos, caso contrário resultará em erro de sintaxe. Por 
    exemplo:</para>

    <programlisting>          OUTPUT(person(), {module1.attr1, module2.attr1});</programlisting>

    <para>resultará em um erro de sintaxe. Os nomes dos campos do resultado 
    são adotados com base nos nomes de definição.</para>

    <para>Para mudar isso, é possível especificar um nome exclusivo para o 
    campo do resultado no formato de registro “dinâmico”, como este:</para>

    <programlisting>          OUTPUT (person (), {module1.attr1, name: = module2.attr1});</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Thor-Flat_Files">
    <title>OUTPUT Arquivos Thor/Flat  <indexterm>
        <primary>Flat Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT Thor/Flat Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold"> [, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">] [</emphasis><emphasis>,file </emphasis><emphasis
    role="bold">[, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis> key </emphasis><emphasis
    role="bold">) ] </emphasis></para>

    <para><emphasis role="bold"> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">COMPRESSED<indexterm>
        <primary>COMPRESSED</primary>
      </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm>]<emphasis role="bold">[, UPDATE<indexterm>
        <primary>UPDATE</primary>
      </indexterm>]</emphasis></emphasis><emphasis role="bold">
    [</emphasis><emphasis>,</emphasis><emphasis role="bold">EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [</emphasis><emphasis> days </emphasis><emphasis
    role="bold">] ) ] ] ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em uma lista 
	      específica de clusters de destino. Se omitido, o arquivo é 
	      gravado no cluster pelo qual a workunit é executada. O número de 
	      partes do arquivo físico gravado em disco sempre é determinado 
	      pelo número de nós no cluster onde a workunit é executada, 
	      independentemente do número de nós nos clusters de 
	      destino.</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>Uma lista delimitada por vírgula das constantes de string 
	      que contêm os nomes dos clusters para os quais o arquivo será 
	      gravado. Os nomes devem estar listados como aparecem na página 
	      de Atividade do ECL Watch, ou como são retornados pela função 
	      Std.System.Thorlib.Group(); opcionalmente, podem apresentar 
	      colchetes contendo uma lista delimitada por vírgula dos números 
	      dos nós (baseado em 1) e/ou dos intervalos (especificados com um 
	      traço, como p.ex., n-m) para indicar o conjunto específico de 
	      nós para gravar.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em disco 
	      usando a criptografia AES de 256 bits e a compactação LZW 
	      .</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>Uma constante de string que contém a chave de 
	      criptografia que será usada para criptografar os dados.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">COMPRESSED</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo usando a 
	      compactação LZW.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Opcional. Especifica a substituição do arquivo caso ele 
	      exista.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">UPDATE</emphasis></entry>

              <entry>Especifica que o arquivo deve ser regravado apenas se 
	      houver alteração nos dados de código ou de entrada.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Opcional. Especifica que se trata de um arquivo 
	      temporário que pode ser removido automaticamente após um 
	      determinado número de dias, após a leitura ter sido 
	      feita.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Opcional. O número de dias contados a partir da última 
	      leitura do arquivo em que o arquivo será automaticamente 
	      removido. Se EXPIRE for especificado sem o número de dias, por 
	      padrão ele usará as configurações do ExpiryDefault no 
	      Sasha.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Esta forma grava o  <emphasis>record set</emphasis>  em um 
    <emphasis>arquivo</emphasis>  especificado no  <emphasis>formato</emphasis> 
    determinado. Se o  <emphasis>formato</emphasis>  for omitido, todos os 
    campos do emphasis>recordset</emphasis>  serão considerados como 
    resultados. Se <emphasis>file</emphasis> se o arquivo for omitido, o 
    resultado é enviado de volta para o programa que o solicitou (geralmente o 
    ECL IDE ou o programa que enviou a consulta SOAP para o Roxie).</para>

    <para>Exemplo:</para>

    <programlisting>OutputFormat1 := RECORD
  People.firstname;
  People.lastname;
END;
  
A_People := People(lastname[1]='A');
Score1 := HASHCRC(People.firstname);
Attr1 := People.firstname[1] = 'A';

OUTPUT(SORT(A_People,Score1),OutputFormat1,'hold01::fred.out');
  // writes the sorted A_People set to the fred.out file in
  // the format declared in the OutputFormat1 definition

OUTPUT(People,{firstname,lastname});
  // writes just First and Last Names to the command issuer
  // full qualification of the fields is unnecessary, since
  // the "on-the-fly" records structure is within the
  // scope of the OUTPUT -- People is assumed

OUTPUT(People(Attr1=FALSE));
  // writes all Peeople fields from records where Attr1 is
  // false to the command issuer
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_CSV_Files">
    <title>Saída de arquivos CSV<indexterm>
        <primary>CSV Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - CSV Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold">, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">]</emphasis><emphasis> ,file
    </emphasis><emphasis>,</emphasis><emphasis role="bold"> CSV<indexterm>
        <primary>CSV</primary>
      </indexterm>[ (</emphasis><emphasis>csvoptions</emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> </emphasis><emphasis
    role="bold">[, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">)] <emphasis role="bold">[,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">) 
      ]</emphasis> [,COMPRESSED]</emphasis></para>

    <para><emphasis role="bold">[</emphasis><emphasis>,</emphasis><emphasis
    role="bold"> OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm> ]</emphasis><emphasis role="bold"><emphasis role="bold">[, 
      UPDATE<indexterm>
        <primary>UPDATE</primary>
      </indexterm>]</emphasis> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold"> EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [ </emphasis><emphasis>days </emphasis><emphasis
    role="bold">] ) ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em uma lista 
	      específica de clusters de destino. Se omitido, o arquivo é 
	      gravado no cluster pelo qual a workunit é executada. O número de 
	      partes do arquivo físico gravado em disco sempre é determinado 
	      pelo número de nós no cluster onde a workunit é executada, 
	      independentemente do número de nós nos clusters de 
	      destino.</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>Uma lista delimitada por vírgula das constantes de string 
	      que contêm os nomes dos clusters para os quais o arquivo será 
	      gravado. Os nomes devem estar listados como aparecem na página 
	      de Atividade do ECL Watch, ou como são retornados pela função 
	      Std.System.Thorlib.Group(); opcionalmente, podem apresentar 
	      colchetes contendo uma lista delimitada por vírgula dos números 
	      dos nós (baseado em 1) e/ou dos intervalos (especificados com um 
	      traço, como p.ex., n-m) para indicar o conjunto específico de 
	      nós para gravar.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em disco 
	      usando a criptografia AES de 256 bits e a compactação LZW 
	      .</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>Uma constante de string que contém a chave de 
	      criptografia que será usada para criptografar os dados.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">COMPRESSED</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo usando a 
	      compactação LZW.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Opcional. Especifica a substituição do arquivo caso ele 
	      exista.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">UPDATE</emphasis></entry>

              <entry>Especifica que o arquivo deve ser regravado apenas se 
	      houver alteração nos dados de código ou de entrada.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Opcional. Especifica que se trata de um arquivo 
	      temporário que pode ser removido automaticamente após um 
	      determinado número de dias.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Opcional. O número de dias em que o arquivo será 
	      automaticamente removido. Se omitido, o padrão é sete 
	      (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Esta forma grava o  <emphasis>recordset</emphasis>  no 
    <emphasis>arquivo</emphasis>  especificado e no  
    <emphasis>formato</emphasis>  determinado na forma de arquivo ASCII com 
    valores separados por vírgula. Um conjunto válido de
    <emphasis>csvoptions</emphasis>  é:</para>

    <para><emphasis role="bold">HEADING<indexterm>
        <primary>HEADING</primary>
      </indexterm>( [</emphasis> <emphasis>headertext</emphasis> <emphasis
    role="bold">[</emphasis> <emphasis>, footertext</emphasis> <emphasis
    role="bold">] ] [, SINGLE<indexterm>
        <primary>SINGLE</primary>
      </indexterm> ][, FORMAT<indexterm>
        <primary>FORMAT</primary>
      </indexterm></emphasis><emphasis>(stringfunction)</emphasis><emphasis
    role="bold"> ] )</emphasis></para>

    <para><emphasis role="bold">SEPARATOR<indexterm>
        <primary>SEPARATOR</primary>
      </indexterm>(</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">)</emphasis></para>

    <para><emphasis role="bold">TERMINATOR<indexterm>
        <primary>TERMINATOR</primary>
      </indexterm>(</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">)</emphasis></para>

    <para><emphasis role="bold">QUOTE<indexterm>
        <primary>QUOTE</primary>
      </indexterm>( [</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">ASCII<indexterm>
        <primary>ASCII</primary>
      </indexterm> | EBCDIC<indexterm>
        <primary>EBCDIC</primary>
      </indexterm> | UNICODE<indexterm>
        <primary>UNICODE</primary>
      </indexterm></emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="95.80pt" />

        <colspec />

        <tbody>
          <row>
            <entry><emphasis role="bold">HEADING</emphasis></entry>

            <entry>Especifica os cabeçalhos e os rodapés do arquivo.</entry>
          </row>

          <row>
            <entry><emphasis>headertext</emphasis></entry>

            <entry>Opcional. O texto do registro de cabeçalho a ser colocado 
	    no arquivo.  Se omitido, os nomes do campo serão 
	    utilizados.</entry>
          </row>

          <row>
            <entry><emphasis>footertext</emphasis></entry>

            <entry>Opcional. O texto do registro de rodapé a ser colocado no 
	    arquivo.  Se omitido, nenhum  <emphasis>footertext</emphasis>  será 
	    gerado. </entry>
          </row>

          <row>
            <entry><emphasis role="bold">SINGLE</emphasis></entry>

            <entry>Opcional. Especifica o uso da 
	    <emphasis>headertext</emphasis> especifica que o texto do 
	    cabeçalho é gravado apenas no início da parte 1 e o 
            <emphasis>footertext</emphasis>  é gravado apenas no final da parte 
	    n (gerando um arquivo CSV “padrão”). Se omitido, o padrão é:
            <emphasis>headertext</emphasis> e <emphasis>footertext</emphasis> 
	    se omitido, o texto de cabeçalho e o texto de rodapé são colocados 
	    no início e no fim de cada parte do arquivo (útil para gerar 
	    resultados XML complexos).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">FORMAT</emphasis></entry>

            <entry>Opcional. Especifica que o texto de cabeçalho deve ser 
	    formatado usando  <emphasis>stringfunction</emphasis>.</entry>
          </row>

          <row>
            <entry><emphasis>stringfunction</emphasis></entry>

            <entry>Opcional. A função usada para formatar os títulos 
	    (cabeçalhos) da coluna. Pode ser qualquer função que toma um único 
	    parâmetro de string e retorna um resultado da string.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">SEPARATOR</emphasis></entry>

            <entry>Especifica os delimitadores do campo.</entry>
          </row>

          <row>
            <entry><emphasis>delimiters</emphasis></entry>

            <entry>Uma constante de string única (ou uma lista de constantes 
	    de string delimitada por vírgula) que define os caracteres usados 
	    para delimitar os dados no arquivo CSV.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">TERMINATOR</emphasis></entry>

            <entry>Especifica os delimitadores do registro.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">QUOTE</emphasis></entry>

            <entry>Especifica os  <emphasis>delimitadores</emphasis>  do texto 
	    dos valores da string que podem conter 
            <emphasis>delimitadores</emphasis>  SEPARATOR ou TERMINATOR como 
	    parte dos seus dados.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ASCII</emphasis></entry>

            <entry>Especifica que todos os resultados estão em formato ASCII, 
	    incluindo quaisquer campos EBCDIC ou UNICODE.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">EBCDIC</emphasis></entry>

            <entry>Especifica que todos os resultados estão em formato EBCDIC, 
	    exceto SEPARATOR e TERMINATOR (que são definidos como valores 
	    ASCII).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">UNICODE</emphasis></entry>

            <entry>Especifica que todos os resultados estão em formato Unicode 
	    UTF8</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Se nenhuma das opções ASCII, EBCDIC, ou UNICODE forem especificadas, 
    o resultado padrão será no formato ASCII com quaisquer campos UNICODE no 
    formato UTF8. As outras  <emphasis>csvoptions</emphasis>  padrão são: 
    <programlisting>           CSV(HEADING('',''), SEPARATOR(','), TERMINATOR('\n'), QUOTE())</programlisting></para>

    <para>Exemplo:</para>

    <programlisting>//SINGLE option writes the header only to the first file part:
OUTPUT(ds,,'~thor::outdata.csv',CSV(HEADING(SINGLE)));

//This example writes the header and footer to every file part:
OUTPUT(XMLds,,'~thor::outdata.xml',CSV(HEADING('&lt;XML&gt;','&lt;/XML&gt;')));

//FORMAT option writes the header using the specified formatting function:
IMPORT STD;
OUTPUT(ds,,'~thor::outdata.csv',CSV(HEADING(FORMAT(STD.Str.ToUpperCase))));
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_XML_Files">
    <title>Saída de Arquivos XML<indexterm>
        <primary>XML Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - XML Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold">, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">]</emphasis><emphasis> ,file </emphasis><emphasis role="bold">
    </emphasis><emphasis>,</emphasis><emphasis role="bold">XML<indexterm>
        <primary>XML</primary>
      </indexterm> [ (</emphasis><emphasis>xmloptions</emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis> key </emphasis><emphasis
    role="bold">) ] [, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">) ] [</emphasis><emphasis>,</emphasis><emphasis role="bold">
    OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm> ]</emphasis><emphasis role="bold"><emphasis role="bold">[, 
      UPDATE<indexterm>
        <primary>UPDATE</primary>
      </indexterm>]</emphasis> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold"> EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [ </emphasis><emphasis>days </emphasis><emphasis
    role="bold">] ) ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em uma lista 
	      específica de clusters de destino. Se omitido, o arquivo é 
	      gravado no cluster pelo qual a workunit é executada. O número de 
	      partes do arquivo físico gravado em disco sempre é determinado 
	      pelo número de nós no cluster onde a workunit é executada, 
	      independentemente do número de nós nos clusters de 
	      destino.</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>Uma lista delimitada por vírgula das constantes de string 
	      que contêm os nomes dos clusters para os quais o arquivo será 
	      gravado. Os nomes devem estar listados como aparecem na página 
	      de Atividade do ECL Watch, ou como são retornados pela função 
	      Std.System.Thorlib.Group(); opcionalmente, podem apresentar 
	      colchetes contendo uma lista delimitada por vírgula dos números
              dos nós (baseado em 1) e/ou dos intervalos (especificados com um 
	      traço, como p.ex., n-m) para indicar o conjunto específico de 
	      nós para gravar.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em disco 
	      usando a criptografia AES de 256 bits e a compactação LZW 
	      .</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>Uma constante de string que contém a chave de 
	      criptografia que será usada para criptografar os dados.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Opcional. Especifica a substituição do arquivo caso ele 
	      exista.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">UPDATE</emphasis></entry>

              <entry>Especifica que o arquivo deve ser regravado apenas se 
	      houver alteração nos dados de código ou de entrada.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Opcional. Especifica que se trata de um arquivo 
	      temporário que pode ser removido automaticamente após um 
	      determinado número de dias.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Opcional. O número de dias em que o arquivo será 
	      automaticamente removido. Se omitido, o padrão é sete 
	      (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Esta forma grava o  <emphasis>recordset</emphasis>  em um 
    <emphasis>arquivo</emphasis>  específico na forma de dados XML com o nome 
    de cada campo no  <emphasis>formato</emphasis>  especificado, tornando-se a 
    tag XML para esses dados do arquivo. O conjunto válido de 
    <emphasis>xmloptions</emphasis>  é:</para>

    <para><emphasis
    role="bold">'</emphasis><emphasis>rowtag</emphasis><emphasis
    role="bold">'</emphasis></para>

    <para><emphasis role="bold">HEADING<indexterm>
        <primary>HEADING</primary>
      </indexterm>( </emphasis><emphasis>headertext </emphasis><emphasis
    role="bold">[</emphasis><emphasis>, footertext </emphasis><emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">TRIM<indexterm>
        <primary>TRIM</primary>
      </indexterm></emphasis><emphasis role="bold"> </emphasis></para>

    <para><emphasis role="bold">OPT<indexterm>
        <primary>OPT</primary>
      </indexterm><indexterm>
        <primary>TRIM OPT</primary>
      </indexterm></emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="84.45pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis>rowtag</emphasis></entry>

              <entry>O texto a ser incluído na tag de delimitação do 
	      registro.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">HEADING</emphasis></entry>

              <entry>Especifica a inclusão dos registros de cabeçalho e rodapé 
	      no arquivo.</entry>
            </row>

            <row>
              <entry><emphasis>headertext</emphasis></entry>

              <entry>O texto do registro de cabeçalho a ser colocado no 
	      arquivo. </entry>
            </row>

            <row>
              <entry><emphasis>footertext</emphasis></entry>

              <entry>O texto do registro de rodapé a ser colocado no 
	      arquivo. </entry>
            </row>

            <row>
              <entry><emphasis role="bold">TRIM</emphasis></entry>

              <entry>Especifica a remoção dos espaços em branco dos campos da 
	      string antes da produção do resultado</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OPT</emphasis></entry>

              <entry>Especifica as tags omitidas em qualquer campo de string 
	      vazio do resultado.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Se nenhuma  <emphasis>xmloptions</emphasis> for especificada, o 
    padrão é:</para>

    <programlisting>         XML('Row',HEADING('&lt;Dataset&gt;\n','&lt;/Dataset&gt;\n'))</programlisting>

    <para>Exemplo:</para>

    <programlisting>R := {STRING10 fname,STRING12 lname};
B := DATASET([{'Fred','Bell'},{'George','Blanda'},{'Sam',''}],R);

OUTPUT(B,,'fred1.xml', XML); // writes B to the fred1.xml file
/* the Fred1.XML file looks like this:
&lt;Dataset&gt;
  &lt;Row&gt;&lt;fname&gt;Fred &lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/Row&gt;
  &lt;Row&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda &lt;/lname&gt;&lt;/Row&gt;
  &lt;Row&gt;&lt;fname&gt;Sam &lt;/fname&gt;&lt;lname&gt;&lt;/lname&gt;&lt;/Row&gt;
&lt;/Dataset&gt; */

OUTPUT(B,,'fred2.xml',XML('MyRow', HEADING('&lt;?xml version=1.0 ...?&gt;
    \n&lt;filetag&gt;\n','&lt;/filetag&gt;\n')));
/* the Fred2.XML file looks like this:
&lt;?xml version=1.0 ...?&gt;
&lt;filetag&gt;
  &lt;MyRow&gt;&lt;fname&gt;Fred &lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;Sam &lt;/fname&gt;&lt;lname&gt;&lt;/lname&gt;&lt;/MyRow&gt;
&lt;/filetag&gt; */

OUTPUT(B,,'fred3.xml',XML('MyRow',TRIM,OPT));
/* the Fred3.XML file looks like this:
&lt;Dataset&gt;
  &lt;MyRow&gt;&lt;fname&gt;Fred&lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;Sam&lt;/fname&gt;&lt;/MyRow&gt;
&lt;/Dataset&gt; */
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_JSON_Files">
    <title>Saída de Arquivos Json<indexterm>
        <primary>JSON Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - JSON Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold">, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">]</emphasis><emphasis> ,file </emphasis><emphasis role="bold">
    </emphasis><emphasis>,</emphasis><emphasis role="bold">JSON<indexterm>
        <primary>JSON</primary>
      </indexterm> [ (</emphasis><emphasis>jsonoptions</emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis> key </emphasis><emphasis
    role="bold">) ] [, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">) ] [</emphasis><emphasis>,</emphasis><emphasis role="bold">
    OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm> ]</emphasis><emphasis role="bold"><emphasis role="bold">[, 
      UPDATE<indexterm>
        <primary>UPDATE</primary>
      </indexterm>]</emphasis> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold"> EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [ </emphasis><emphasis>days </emphasis><emphasis
    role="bold">] ) ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em uma lista 
	      específica de clusters de destino. Se omitido, o arquivo é 
	      gravado no cluster pelo qual a workunit é executada. O número de 
	      partes do arquivo físico gravado em disco sempre é determinado 
	      pelo número de nós no cluster onde a workunit é executada, 
	      independentemente do número de nós nos clusters de 
	      destino.</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>Uma lista delimitada por vírgula das constantes de string 
	      que contêm os nomes dos clusters para os quais o arquivo será 
	      gravado. Os nomes devem estar listados como aparecem na página 
	      de Atividade do ECL Watch, ou como são retornados pela função 
	      Std.System.Thorlib.Group(); opcionalmente, podem apresentar 
	      colchetes contendo uma lista delimitada por vírgula dos números 
	      dos nós (baseado em 1) e/ou dos intervalos (especificados com um 
	      traço, como p.ex., n-m) para indicar o conjunto específico de 
	      nós para gravar.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Opcional. Especifica a gravação do arquivo em disco 
	      usando a criptografia AES de 256 bits e a compactação LZW 
	      .</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>Uma constante de string que contém a chave de 
	      criptografia que será usada para criptografar os dados.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Opcional. Especifica a substituição do arquivo caso ele 
	      exista.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">UPDATE</emphasis></entry>

              <entry>Especifica que o arquivo deve ser regravado apenas se 
	      houver alteração nos dados de código ou de entrada.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Opcional. Especifica que se trata de um arquivo 
	      temporário que pode ser removido automaticamente após um 
	      determinado número de dias.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Opcional. O número de dias em que o arquivo será 
	      automaticamente removido. Se omitido, o padrão é sete 
	      (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Esta forma grava o  <emphasis>recordset</emphasis>  em um 
    <emphasis>arquivo</emphasis>  específico na forma de dados JSON com o nome 
    de cada campo no  <emphasis>formato</emphasis>  especificado, tornando-se a 
    tag JSON para esses dados do arquivo. O conjunto válido de 
    <emphasis>jsonoptions</emphasis>é:</para>

    <para><emphasis
    role="bold">'</emphasis><emphasis>rowtag</emphasis><emphasis
    role="bold">'</emphasis></para>

    <para><emphasis role="bold">HEADING<indexterm>
        <primary>HEADING</primary>
      </indexterm>( </emphasis><emphasis>headertext </emphasis><emphasis
    role="bold">[</emphasis><emphasis>, footertext </emphasis><emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">TRIM<indexterm>
        <primary>TRIM</primary>
      </indexterm></emphasis><emphasis role="bold"> </emphasis></para>

    <para><emphasis role="bold">OPT<indexterm>
        <primary>OPT</primary>
      </indexterm><indexterm>
        <primary>TRIM OPT</primary>
      </indexterm></emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="84.45pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis>rowtag</emphasis></entry>

              <entry>O texto a ser incluído na tag de delimitação do 
	      registro.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">HEADING</emphasis></entry>

              <entry>Especifica a inclusão dos registros de cabeçalho e rodapé 
	      no arquivo.</entry>
            </row>

            <row>
              <entry><emphasis>headertext</emphasis></entry>

              <entry>O texto do registro de cabeçalho a ser colocado no 
	      arquivo. </entry>
            </row>

            <row>
              <entry><emphasis>footertext</emphasis></entry>

              <entry>O texto do registro de rodapé a ser colocado no 
	      arquivo. </entry>
            </row>

            <row>
              <entry><emphasis role="bold">TRIM</emphasis></entry>

              <entry>Especifica a remoção dos espaços em branco dos campos da 
	      string antes da produção do resultado</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OPT</emphasis></entry>

              <entry>Especifica as tags omitidas em qualquer campo de string 
	      vazio do resultado.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Se nenhum  <emphasis>jsonoptions</emphasis>  for especificado, o 
    padrão é:</para>

    <programlisting>         JSON('Row',HEADING('[',']'))</programlisting>

    <para>Exemplo:</para>

    <programlisting>R := {STRING10 fname,STRING12 lname};
B := DATASET([{'Fred','Bell'},{'George','Blanda'},{'Sam',''}],R);

OUTPUT(B,,'fred1.json', JSON); // writes B to the fred1.json file
/* the Fred1.json file looks like this:
{"Row": [
{"fname": "Fred      ", "lname": "Bell        "},
{"fname": "George    ", "lname": "Blanda      "},
{"fname": "Sam       ", "lname": "            "}
]}
*/
OUTPUT(B,,'fred2.json',JSON('MyResult', HEADING('[', ']')));
/* the Fred2.json file looks like this:
["MyResult": [
{"fname": "Fred      ", "lname": "Bell        "},
{"fname": "George    ", "lname": "Blanda      "},
{"fname": "Sam       ", "lname": "            "}
]]
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_PIPE_Files">
    <title>Saída de Arquivos PIPE<indexterm>
        <primary>OUTPUT Pipe Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] 
    OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">, 
    [</emphasis><emphasis> format </emphasis><emphasis role="bold">]
    </emphasis><emphasis> ,</emphasis><emphasis role="bold">PIPE<indexterm>
        <primary>PIPE</primary>
      </indexterm>(</emphasis><emphasis> command </emphasis><emphasis
    role="bold">[</emphasis>, <emphasis role="bold"> CSV<indexterm>
        <primary>CSV</primary>
      </indexterm> | XML<indexterm>
        <primary>XML</primary>
      </indexterm>])</emphasis><emphasis> </emphasis><emphasis
    role="bold">[</emphasis>,<emphasis role="bold"> REPEAT<indexterm>
        <primary>REPEAT</primary>
      </indexterm>] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">PIPE</emphasis></entry>

              <entry>Indica que o comando especificado é executado com o 
	      recordset fornecido como entrada padrão do comando. Este é um 
	      pipe de "gravação”.</entry>
            </row>

            <row>
              <entry><emphasis>command</emphasis></entry>

              <entry>O nome de um programa a ser executado que usa o arquivo 
	      como seu fluxo de entrada.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">CSV</emphasis></entry>

              <entry>Opcional. Especifica que o formato dos dados de resultado 
	      é CSV. Se omitido, o formato será raw.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">XML</emphasis></entry>

              <entry>Opcional. Especifica que o formato dos dados de resultado 
	      é em XML. Se omitido, o formato será raw.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">REPEAT</emphasis></entry>

              <entry>Opcional. Indica uma nova instância que o comando 
	      especificado executa para cada linha no conjunto de 
	      registros.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Esta forma envia o  <emphasis>recordset</emphasis>  no 
    <emphasis>formato </emphasis> especificado na forma de entrada padrão para 
    o <emphasis>comando</emphasis>. Isso é comumente conhecido como "pipe de 
    resultado."</para>

    <para>Exemplo:</para>

    <programlisting>OUTPUT(A_People,,PIPE('MyCommandLIneProgram'),OVERWRITE); 
    // sends the A_People to MyCommandLIneProgram as 
    // standard in</programlisting>
  </sect2>

  <sect2 id="Named_OUTPUT">
    <title>Saída Named<indexterm>
        <primary>NAMED OUTPUT</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - NAMED Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold"> [,</emphasis><emphasis> format </emphasis><emphasis
    role="bold">] </emphasis><emphasis>,</emphasis><emphasis
    role="bold">NAMED<indexterm>
        <primary>NAMED</primary>
      </indexterm>(</emphasis><emphasis> name </emphasis><emphasis
    role="bold">) [,EXTEND<indexterm>
        <primary>EXTEND</primary>
      </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">ALL<indexterm>
        <primary>ALL</primary>
      </indexterm>])</emphasis></para>

    <para>Esta forma grava o  <emphasis>recordset</emphasis>  na workunit com o 
    <emphasis>nome</emphasis> especificado. Este deve ser um rótulo válido 
    (consulte  <link linkend="Attribute_Name_Rules">Definition Name 
    Rules</link>)</para> <para>A opção EXTEND permite várias ações 
    OUTPUT em um mesmo resultado <emphasis>nomeado</emphasis> . A opção 
    ALL é usada para substituir CHOOSEN implícita aplicada às consultas 
    interativas no Programa do Compilador de Consultas ECL.  Isso especifica o 
    retorno de todos os registros.</para>

    <para>Exemplo:</para>

    <programlisting>OUTPUT(CHOOSEN(people(firstname[1]='A'),10));
  // writes the A People to the query builder
OUTPUT(CHOOSEN(people(firstname[1]='A'),10),ALL);
  // writes all the A People to the query builder
OUTPUT(CHOOSEN(people(firstname[1]='A'),10),NAMED('fred'));
  // writes the A People to the fred named output
  
//a NAMED, EXTEND example:
errMsgRec := RECORD
  UNSIGNED4 code;
  STRING text;
END;
makeErrMsg(UNSIGNED4 _code,STRING _text) := DATASET([{_code, _text}], errMsgRec);
rptErrMsg(UNSIGNED4 _code,STRING _text) := OUTPUT(makeErrMsg(_code,_text),
                                                  NAMED('ErrorResult'),EXTEND);

OUTPUT(DATASET([{100, 'Failed'}],errMsgRec),NAMED('ErrorResult'),EXTEND);
  //Explicit syntax.

//Something else creates the dataset
OUTPUT(makeErrMsg(101, 'Failed again'),NAMED('ErrorResult'),EXTEND);
  
//output and dataset handled elsewhere.
rptErrMsg(102, 'And again');
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Scalar_Values">
    <title>OUTPUT Scalar Values<indexterm>
        <primary>OUTPUT Scalar Values</primary>
      </indexterm><indexterm>
        <primary>Scalar OUTPUT</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis> expression </emphasis><emphasis
    role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold">
    NAMED<indexterm>
        <primary>NAMED</primary>
      </indexterm>(</emphasis><emphasis> name </emphasis><emphasis
    role="bold">) ] )</emphasis></para>

    <para>Esta forma é usada para permitir o envio da  
    <emphasis>expressão</emphasis> escalar, especialmente dentro das ações 
    <indexterm>
        <primary>SEQUENTIAL</primary>
      </indexterm> e PARALLEL.</para>

    <para>Exemplo:</para>

    <programlisting>OUTPUT(10) // scalar value output 
    OUTPUT('Fred') // scalar value output
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Workunit_Files">
    <title>Saída de Arquivos Workunit<indexterm>
        <primary>OUTPUT Workunit Files</primary>
      </indexterm><indexterm>
        <primary>Workunit OUTPUT</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> recordset 
    ,</emphasis><emphasis role="bold"> THOR<indexterm>
        <primary>THOR</primary>
      </indexterm> )</emphasis></para>

    <para>Esta forma é usada para armazenar o <emphasis>recordset</emphasis> 
    resultante na forma de arquivo em disco "de propriedade" da workunit. O
     nome do arquivo na DFU é 
     <emphasis>scope</emphasis>::RESULT::<emphasis>workunitid</emphasis>. Isso 
    é útil quando é preciso exibir um <emphasis>recordset</emphasis> de 
    resultado grande no programa Compilador de Consultas ECL, porém sem que os 
    dados ocupem memória no armazenamento de dados do sistema.</para>

    <para>Exemplo:</para>

    <programlisting>OUTPUT(Person(per_st='FL'), THOR) 
    // output records to screen, but store the 
    // result on disk instead of in the workunit</programlisting>

    <para>Ver também: <link linkend="TABLE">TABLE</link>, <link
    linkend="DATASET">DATASET</link>, <link linkend="PIPE">PIPE</link>, <link
    linkend="CHOOSEN">CHOOSEN</link></para>
  </sect2>
</sect1>
