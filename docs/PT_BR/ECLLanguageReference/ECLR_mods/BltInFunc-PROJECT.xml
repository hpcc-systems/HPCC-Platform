<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="PROJECT">
  <title>PROJECT</title>

  <para><emphasis role="bold">PROJECT<indexterm>
      <primary>PROJECT</primary>
    </indexterm><indexterm>
      <primary>PROJECT function</primary>
    </indexterm>(</emphasis><emphasis> recordset, transform
  </emphasis><emphasis role="bold">[, PREFETCH<indexterm>
      <primary>PREFETCH</primary>
    </indexterm> [ (</emphasis><emphasis>lookahead </emphasis><emphasis
  role="bold">[, PARALLEL<indexterm>
      <primary>PARALLEL</primary>
    </indexterm>]) ] ]</emphasis><emphasis role="bold"> [, KEYED<indexterm>
      <primary>KEYED</primary>
    </indexterm> ] [, LOCAL<indexterm>
      <primary>LOCAL</primary>
    </indexterm> ] </emphasis><emphasis role="bold">[, UNORDERED | 
    ORDERED(</emphasis> <emphasis>bool </emphasis><emphasis role="bold">) ] [, 
    STABLE | UNSTABLE ] [, PARALLEL [ (</emphasis> <emphasis>numthreads 
    </emphasis><emphasis role="bold">) ] ] [, ALGORITHM(</emphasis> 
    <emphasis>name </emphasis><emphasis role="bold">) ] )</emphasis></para>

  <para><emphasis role="bold">PROJECT(</emphasis><emphasis> recordset, record
  </emphasis><emphasis role="bold">[, PREFETCH<indexterm>
      <primary>PREFETCH</primary>
    </indexterm> [ (</emphasis><emphasis>lookahead </emphasis><emphasis
  role="bold">[, PARALLEL]) ] ]</emphasis><emphasis role="bold"> [, KEYED ] [, 
  LOCAL ] </emphasis><emphasis role="bold">[, UNORDERED | ORDERED(</emphasis> 
  <emphasis>bool </emphasis><emphasis role="bold">) ] [, STABLE | UNSTABLE ] 
  [, PARALLEL [ (</emphasis> <emphasis>numthreads </emphasis><emphasis 
  role="bold">) ] ] [, ALGORITHM(</emphasis> <emphasis>name 
  </emphasis><emphasis role="bold">) ] )</emphasis></para>

  <para><informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="84.85pt" />

        <colspec />

        <tbody>
          <row>
            <entry><emphasis>recordset</emphasis></entry>

            <entry>O conjunto de registros para processamento. Esse pode ser 
	    um DATASET em linha de registro único.</entry>
          </row>

          <row>
            <entry><emphasis>transform</emphasis></entry>

            <entry>A função TRANSFORM a ser acionada para cada registro no 
	    recordset.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">PREFETCH</emphasis></entry>

            <entry>Opcional. Permite que leituras de índice dentro do transfom 
	    sejam tão eficientes quanto JOINs com chave. Válido apenas para 
	    consultas ECL no Roxie.</entry>
          </row>

          <row>
            <entry><emphasis>lookahead</emphasis></entry>

            <entry>Opcional. Especifica o número de leituras antecipadas. Se 
	    omitido, o padrão é o valor da tag _PrefetchProjectPreload na 
	    consulta enviada. Se for omitido, o valor de 
	    defaultPrefetchProjectPreload especificado no arquivo 
	    RoxieTopology será usado quando o Roxie foi implantado. Se for 
	    omitido, 10 será usado por padrão.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">PARALLEL</emphasis></entry>

            <entry>Opcional. Especifica que a consulta avançada é feita em um 
	    thread separado, em paralelo com a execução da consulta.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">KEYED</emphasis></entry>

            <entry>Opcional. Especifica que a atividade faz parte de uma 
	    operação de leitura de índice, a qual permite que o otimizador 
	    gere o código ideal para a operação.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">LOCAL</emphasis></entry>

            <entry>Opcional. Especifica que a operação é realizada em cada nó 
	    de supercomputador de forma independente, sem exigir interação com 
	    todos os outros nós para obter dados; a operação mantém a 
	    distribuição de qualquer operação DISTRIBUTE anterior.</entry>
          </row>

          <row>
            <entry><emphasis>record</emphasis></entry>

            <entry>A estrutura RECORD do resultado estrutura <indexterm>
                <primary>RECORD structure</primary>
              </indexterm>  para uso em cada registro no recordset.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">UNORDERED</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de resultado 
	    não é importante.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">ORDERED</emphasis></entry>

            <entry>Especifica a importância da ordem do registro de 
	    resultado.</entry>
          </row>
          <row>
            <entry><emphasis>bool</emphasis></entry>

            <entry>Quando for “False” (Falso), especifica que a ordem do 
	    registro de resultado não é importante. Quando for “True’ 
	    (Verdadeiro), especifica a ordem padrão do registro de 
	    resultado.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">STABLE</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de entrada é 
	    importante.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">UNSTABLE</emphasis></entry>

            <entry>Opcional. Especifica que a ordem do registro de entrada não 
	    é importante.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">PARALLEL</emphasis></entry>

            <entry>Opcional. Tenta avaliar essa atividade em paralelo.</entry>
          </row>
          <row>
            <entry><emphasis>numthreads</emphasis></entry>

            <entry>Opcional. Tenta avaliar essa atividade usando 
	    <emphasis>numthreads</emphasis> threads.</entry>
          </row>
          <row>
            <entry><emphasis role="bold">ALGORITHM</emphasis></entry>

            <entry>Opcional. Substitui o algoritmo usado para essa 
	    atividade.</entry>
          </row>
          <row>
            <entry><emphasis>name</emphasis></entry>

            <entry>O algoritmo a ser usado para essa atividade. Precisa fazer 
	    parte da lista de algoritmos compatíveis com as opções STABLE e 
	    UNSTABLE da função SORT.</entry>
          </row>

          <row>
            <entry>Return:</entry>

            <entry>PROJECT retorna um conjunto de registros.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable></para>

  <para>A função  <emphasis role="bold">PROJECT </emphasis> processa todos os 
  registros no  <emphasis>recordset </emphasis>, os quais realizam a função 
  <emphasis>transform</emphasis>  em cada registro por vez.</para>

  <para>O form PROJECT(<emphasis>recordset,record</emphasis>) é basicamente um 
  sinônimo abreviado para:</para>

  <para>PROJECT(<emphasis>recordset</emphasis>,TRANSFORM(<emphasis>record</emphasis>,SELF 
  := LEFT)).</para>

  <para>simplificando a transferência de dados de uma estrutura para outra sem 
  um TRANSFORM, contanto que todos os campos na estrutura de 
  <emphasis>registro</emphasis>  de resultado estejam presentes no 
  <emphasis>recordset</emphasis> de entrada.</para>

  <sect2 id="TRANSFORM_Function_Requirements_Project">
    <title>Função TRANSFORM<indexterm>
        <primary>Função TRANSFORM</primary>
      </indexterm> Requisitos<indexterm>
        <primary>Requerimentos da Função TRANSFORM</primary>
      </indexterm><indexterm>
        <primary>Requisitos TRANSFORM</primary>
      </indexterm>  - PROJECT<indexterm>
        <primary>Requisitos TRANSFORM PROJECT</primary>
      </indexterm></title>

    <para>A função <emphasis> transform</emphasis>  precisa usar no mínimo um 
    parâmetro: um registro LEFT de mesmo formato que o 
    <emphasis>recordset</emphasis>. Opcionalmente, ele pode usar um segundo 
    parâmetro: um COUNTER inteiro que especifique o número de vezes que a 
    função <emphasis>transform</emphasis> foi acionada para o <emphasis> 
    recordset </emphasis>, ou outro grupo atual no 
    <emphasis>recordset</emphasis>  (consulte a função GROUP). O segundo form 
    de parâmetro é útil para adicionar números de sequência. O formato do 
    conjunto de registro resultante não precisa ser o mesmo do da 
    entrada.</para>

    <para>Exemplo:</para>

    <programlisting>//form one example **********************************
Ages := RECORD
  STRING15 per_first_name;
  STRING25 per_last_name;
  INTEGER8 Age;
END;
TodaysYear := 2001;


Ages CalcAges(person l) := TRANSFORM
  SELF.Age := TodaysYear - l.birthdate[1..4];
  SELF := l;
END;
AgedRecs := PROJECT(person, CalcAges(LEFT));

//COUNTER example **********************************
SequencedAges := RECORD
  Ages;
  INTEGER8 Sequence := 0;
END;

SequencedAges AddSequence(Ages l, INTEGER c) :=
          TRANSFORM
  SELF.Sequence := c;
  SELF := l;
END;
SequencedAgedRecs := PROJECT(AgedRecs,
          AddSequence(LEFT,COUNTER));

//form two example **********************************
NewRec := RECORD
  STRING15 firstname;
  STRING25 lastname;
  STRING15 middlename;
END;
NewRecs := PROJECT(People,NewRec);
//equivalent to:
//NewRecs := PROJECT(People,TRANSFORM(NewRec,SELF :=
          LEFT));


//LOCAL example **********************************
MyRec := RECORD
  STRING1 Value1;
  STRING1 Value2;
END;

SomeFile := DATASET([{'C','G'},{'C','C'},{'A','X'},
                     {'B','G'},{'A','B'}],MyRec);

MyOutRec := RECORD
  SomeFile.Value1;
  SomeFile.Value2;
  STRING6 CatValues;
END;

DistFile := DISTRIBUTE(SomeFile,HASH32(Value1,Value2));

MyOutRec CatThem(SomeFile L, INTEGER C) := TRANSFORM
  SELF.CatValues := L.Value1 + L.Value2 + '-' +
                    (Std.System.Thorlib.Node()+1) + '-' + (STRING)C;
  SELF := L;
END;

CatRecs := PROJECT(DistFile,CatThem(LEFT,COUNTER<indexterm>
        <primary>COUNTER</primary>
      </indexterm>),LOCAL);

OUTPUT(CatRecs);

/* CatRecs result set is:
Rec# Value1 Value2 CatValues
1      C      C      CC-1-1
2      B      G      BG-2-1
3      A      X      AX-2-2
4      A      B      AB-3-1
5      C      G      CG-3-2
*/
</programlisting>

    <para>Ver também: <link linkend="TRANSFORM_Structure">Estrutura 
    TRANSFORM</link>, <link linkend="RECORD_Structure">Estrutura 
    RECORD</link>, <link linkend="ROW">ROW</link>, <link 
    linkend="DATASET">DATASET</link></para>
  </sect2>

  <sect2 id="BuiltinFunction_PROJECT">
    <title>PROJECT - Module</title>

    <para><emphasis role="bold">PROJECT<indexterm>
        <primary>PROJECT</primary>
      </indexterm>(</emphasis><emphasis> module, interface
    </emphasis><emphasis role="bold">[, OPT<indexterm>
        <primary>OPT</primary>
      </indexterm> | </emphasis><emphasis>attributelist </emphasis><emphasis
    role="bold">] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="80.20pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis>module</emphasis></entry>

              <entry>A estrutura MODULE que contém definições de atributo 
	      cujos valores passam como a interface.</entry>
            </row>

            <row>
              <entry><emphasis>interface</emphasis></entry>

              <entry>A estrutura INTERFACE para passar.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OPT</emphasis></entry>

              <entry>Opcional. Suprime a mensagem de erro que é gerada quando 
	      um atributo definido na interface não é definido também no 
	      módulo.</entry>
            </row>

            <row>
              <entry><emphasis>attributelist</emphasis></entry>

              <entry>Opcional. Uma lista de atributos específicos delimitada 
	      por vírgula no módulo para fornecer à interface. Isso permite a 
	      implementação de uma lista especificada de atributos, algo que é 
	      útil se você quiser um controle mais rígido ou se os tipos de 
	      parâmetros não corresponderem.</entry>
            </row>

            <row>
              <entry>Return:</entry>

              <entry>PROJECT retorna um MODULE compatível com a 
	      interface.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>A função  <emphasis role="bold">PROJECT </emphasis> passa os 
    atributos de um <emphasis>módulo </emphasis> na forma de 
    <emphasis>interface</emphasis>  para uma função definida para aceitar 
    parâmetros estruturados como a  <emphasis>interface</emphasis> 
    especificada. Isso permite que você crie um módulo para uma <emphasis> 
    interface</emphasis>  com os valores fornecidos por outra interface. Os 
    atributos no <emphasis>módulo</emphasis>  precisam ser compatíveis com os 
    atributos na <emphasis>interface</emphasis>  (do mesmo tipo e mesmos 
    parâmetros, se usar algum parâmetro).</para>

    <para>Exemplo:</para>

    <programlisting>PROJECT(x,y)
/*is broadly equivalent to
MODULE(y)
  SomeAttributeInY := x.someAttributeInY
  //... repeated for all attributes in Y ...
END;
*/

myService(myInterface myArgs) := FUNCTION
  childArgs := MODULE(PROJECT(myArgs,Iface,isDead,did,ssn,address))
    BOOLEAN isFCRA := myArgs.isFCRA OR myArgs.fakeFCRA
  END;
  RETURN childService(childArgs);
  END;

// you could directly pass PROJECT as a module parameter
// to an attribute:
myService(myInterface myArgs) := childService(PROJECT(myArgs, childInterface));
</programlisting>

    <para>Ver também: <link linkend="MODULE_Structure">Estrutura 
    MODULE</link>, <link linkend="INTERFACE_Structure">Estrutura 
    INTERFACE</link>, <link linkend="FUNCTION_Structure">Estrutura 
    FUNCTION</link>, <link linkend="STORED">STORED</link></para>
  </sect2>
</sect1>
