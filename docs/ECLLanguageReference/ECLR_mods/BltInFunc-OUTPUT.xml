<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="OUTPUT">
  <title>OUTPUT</title>

  <para><emphasis><emphasis role="bold">[</emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT<indexterm>
      <primary>OUTPUT action</primary>
    </indexterm><indexterm>
      <primary>OUTPUT</primary>
    </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
  role="bold"> [, [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">] [</emphasis><emphasis>,file </emphasis><emphasis
  role="bold">[</emphasis><emphasis>thorfileoptions </emphasis><emphasis
  role="bold"> ] ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold">
  NOXPATH<indexterm>
      <primary>NOXPATH</primary>
    </indexterm> ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ]
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">,
  [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">]</emphasis><emphasis> ,file
  </emphasis><emphasis>,</emphasis><emphasis role="bold"> CSV<indexterm>
      <primary>CSV</primary>
    </indexterm> [ (</emphasis><emphasis>csvoptions</emphasis><emphasis
  role="bold">) ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>csvfileoptions </emphasis><emphasis
  role="bold"> ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ]
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">,
  [</emphasis><emphasis> format </emphasis><emphasis
  role="bold">]</emphasis><emphasis> , file </emphasis><emphasis role="bold">
  </emphasis><emphasis>,</emphasis><emphasis role="bold"> XML<indexterm>
      <primary>XML</primary>
    </indexterm> [ (</emphasis><emphasis>xmloptions</emphasis><emphasis
  role="bold">) ]</emphasis><emphasis role="bold"> </emphasis><emphasis
  role="bold">[</emphasis><emphasis>xmlfileoptions </emphasis><emphasis
  role="bold"> ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ]
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">,
  [</emphasis><emphasis> format </emphasis><emphasis role="bold">]
  </emphasis><emphasis> ,</emphasis><emphasis role="bold">PIPE<indexterm>
      <primary>PIPE</primary>
    </indexterm>(</emphasis><emphasis> pipeoptions </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ]
  OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">
  [,</emphasis><emphasis> format </emphasis><emphasis role="bold">]
  </emphasis><emphasis>, </emphasis><emphasis role="bold">NAMED<indexterm>
      <primary>NAMED</primary>
    </indexterm>(</emphasis><emphasis> name </emphasis><emphasis role="bold">)
  [,EXTEND<indexterm>
      <primary>EXTEND</primary>
    </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
  role="bold">ALL<indexterm>
      <primary>ALL</primary>
    </indexterm>] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> expression
  </emphasis><emphasis role="bold">[</emphasis><emphasis>,</emphasis><emphasis
  role="bold"> NAMED(</emphasis><emphasis> name </emphasis><emphasis
  role="bold">) ] </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
  :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> recordset
  ,</emphasis><emphasis role="bold"> THOR<indexterm>
      <primary>THOR</primary>
    </indexterm> </emphasis><emphasis
  role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold"> NOXPATH
  ] );</emphasis></para>

  <para><informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="93.80pt" />

        <colspec />

        <tbody>
          <row>
            <entry><emphasis>attr</emphasis></entry>

            <entry>Optional. The action name, which turns the action into a
            definition, therefore not executed until the
            <emphasis>attr</emphasis> is used as an action.</entry>
          </row>

          <row>
            <entry><emphasis>recordset</emphasis></entry>

            <entry>The set of records to process. This may be the name of a
            dataset or a record set derived from some filter condition, or any
            expression that results in a derived record set.</entry>
          </row>

          <row>
            <entry><emphasis>format</emphasis></entry>

            <entry>Optional. The format of the output records. If omitted, all
            fields in the <emphasis>recordset</emphasis> are output. If not
            omitted, this must be either the name of a previously defined
            RECORD structure definition or an "on-the-fly" record layout
            enclosed within curly braces ({}), and must meet the same
            requirements as a RECORD structure for the TABLE function (the
            "vertical slice" form) by defining the type, name, and source of
            the data for each field.</entry>
          </row>

          <row>
            <entry><emphasis>file</emphasis></entry>

            <entry>Optional. The logical name of the file to write the records
            to. See the Scope &amp; Logical Filenames section of the Language
            Reference for more on logical filenames. If omitted, the formatted
            data stream only returns to the command issuer (command line or
            IDE) and is not written to a disk file.</entry>
          </row>

          <row>
            <entry><emphasis>thorfileoptions</emphasis></entry>

            <entry>Optional. A comma-delimited list of options valid for a
            THOR/FLAT file (see the section below for details).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">NOXPATH</emphasis></entry>

            <entry>Specifies any XPATHs defined in the
            <emphasis>format</emphasis> or the RECORD structure of the
            <emphasis>recordset</emphasis> are ignored and field names are
            used instead. This allows control of whether XPATHs are used for
            output, so that XPATHs that were meant only for xml input can be
            ignored for output.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">CSV</emphasis></entry>

            <entry>Specifies the file is a field-delimited (usually comma
            separated values) ASCII file.</entry>
          </row>

          <row>
            <entry><emphasis>csvoptions</emphasis></entry>

            <entry>Optional. A comma-delimited list of options defining how
            the file is delimited.</entry>
          </row>

          <row>
            <entry><emphasis>csvfileoptions</emphasis></entry>

            <entry>Optional. A comma-delimited list of options valid for a CSV
            file (see the section below for details).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">XML</emphasis></entry>

            <entry>Specifies the file is output as XML data with the name of
            each field in the format becoming the XML tag for that field's
            data.</entry>
          </row>

          <row>
            <entry><emphasis>xmloptions</emphasis></entry>

            <entry>Optional. A comma separated list of options that define how
            the output XML file is delimited.</entry>
          </row>

          <row>
            <entry><emphasis>xmlfileoptions</emphasis></entry>

            <entry>Optional. A comma-delimited list of options valid for an
            XML file (see the section below for details).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">PIPE</emphasis></entry>

            <entry>Indicates the specified command executes with the
            <emphasis>recordset</emphasis> provided as standard input to the
            command. This is a "write" pipe.</entry>
          </row>

          <row>
            <entry><emphasis>pipeoptions</emphasis></entry>

            <entry>The name of a program to execute, which takes the
            <emphasis>file</emphasis> as its input stream, along with the
            options valid for an output PIPE.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">NAMED</emphasis></entry>

            <entry>Specifies the result name that appears in the workunit. Not
            valid if the file parameter is present.</entry>
          </row>

          <row>
            <entry><emphasis>name</emphasis></entry>

            <entry>A string constant containing the result label. This must be
            a compile-time constant and meet the attribute naming
            requirements.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">EXTEND</emphasis></entry>

            <entry>Optional. Specifies appending to the existing NAMED result
            <emphasis>name</emphasis> in the workunit. Using this feature
            requires that all NAMED OUTPUTs to the same name have the EXTEND
            option present, including the first instance.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ALL</emphasis></entry>

            <entry>Optional. Specifies all records in the
            <emphasis>recordset</emphasis> are output to the ECL IDE.</entry>
          </row>

          <row>
            <entry><emphasis>expression</emphasis></entry>

            <entry>Any valid ECL expression that results in a single scalar
            value.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">THOR</emphasis></entry>

            <entry>Specifies the resulting recordset is stored as a file on
            disk, "owned" by the workunit, instead of storing it directly
            within the workunit. The name of the file in the DFU is
            scope::RESULT::workunitid.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable></para>

  <para>The <emphasis role="bold">OUTPUT </emphasis>action produces a
  recordset result from the supercomputer, based on which form and options you
  choose. If no <emphasis>file</emphasis> to write to is specified, the result
  is stored in the workunit and returned to the calling program as a data
  stream.</para>

  <sect2 id="OUTPUT_Field_Names">
    <title>OUTPUT Field Names</title>

    <para>Field names in an "on the fly" record format {…} must be unique or a
    syntax error results. For example:</para>

    <programlisting>          OUTPUT(person(), {module1.attr1, module2.attr1});</programlisting>

    <para>will result in a syntax error. Output Field Names are assumed from
    the definition names.</para>

    <para>To get around this situation, you can specify a unique name for the
    output field in the on-the-fly record format, like this:</para>

    <programlisting>          OUTPUT(person(), {module1.attr1, name := module2.attr1});</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Thor-Flat_Files">
    <title>OUTPUT Thor/Flat Files<indexterm>
        <primary>Flat Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT Thor/Flat Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold"> [, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">] [</emphasis><emphasis>,file </emphasis><emphasis
    role="bold">[, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis> key </emphasis><emphasis
    role="bold">) ] </emphasis></para>

    <para><emphasis role="bold"> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">COMPRESSED<indexterm>
        <primary>COMPRESSED</primary>
      </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm>]</emphasis><emphasis role="bold">
    [</emphasis><emphasis>,</emphasis><emphasis role="bold">EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [</emphasis><emphasis> days </emphasis><emphasis
    role="bold">] ) ] ] ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Optional. Specifies writing the file to the specified
              list of target clusters. If omitted, the file is written to the
              cluster on which the workunit executes. The number of physical
              file parts written to disk is always determined by the number of
              nodes in the cluster on which the workunit executes, regardless
              of the number of nodes on the target cluster(s).</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>A comma-delimited list of string constants containing the
              names of the clusters to write the file to. The names must be
              listed as they appear on the ECL Watch Activity page or returned
              by the Std.System.Thorlib.Group() function, optionally with
              square brackets containing a comma-delimited list of
              node-numbers (1-based) and/or ranges (specified with a dash, as
              in n-m) to indicate the specific set of nodes to write
              to.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Optional. Specifies writing the file to disk using both
              256-bit AES encryption and LZW compression.</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>A string constant containing the encryption key to use to
              encrypt the data.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">COMPRESSED</emphasis></entry>

              <entry>Optional. Specifies writing the file using LZW
              compression.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Optional. Specifies overwriting the file if it already
              exists.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Optional. Specifies the file is a temporary file that may
              be automatically deleted after the specified number of days
              since the file was read.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Optional. The number of days from last file read after
              which the file may be automatically deleted. If omitted, the
              default is seven (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>This form writes the <emphasis>recordset</emphasis> to the specified
    <emphasis>file</emphasis> in the specified <emphasis>format</emphasis>. If
    the <emphasis>format</emphasis> is omitted, all fields in the
    <emphasis>recordset</emphasis> are output. If the
    <emphasis>file</emphasis> is omitted, then the result is sent back to the
    requesting program (usually the ECL IDE or the program that sent the SOAP
    query to a Roxie).</para>

    <para>Example:</para>

    <programlisting>OutputFormat1 := RECORD
  People.firstname;
  People.lastname;
END;
  
A_People := People(lastname[1]='A');
Score1 := HASHCRC(People.firstname);
Attr1 := People.firstname[1] = 'A';

OUTPUT(SORT(A_People,Score1),OutputFormat1,'hold01::fred.out');
  // writes the sorted A_People set to the fred.out file in
  // the format declared in the OutputFormat1 definition

OUTPUT(People,{firstname,lastname});
  // writes just First and Last Names to the command issuer
  // full qualification of the fields is unnecessary, since
  // the "on-the-fly" records structure is within the
  // scope of the OUTPUT -- People is assumed

OUTPUT(People(Attr1=FALSE));
  // writes all Peeople fields from records where Attr1 is
  // false to the command issuer
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_CSV_Files">
    <title>OUTPUT CSV Files<indexterm>
        <primary>CSV Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - CSV Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold">, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">]</emphasis><emphasis> ,file
    </emphasis><emphasis>,</emphasis><emphasis role="bold"> CSV<indexterm>
        <primary>CSV</primary>
      </indexterm> [ (</emphasis><emphasis>csvoptions</emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> </emphasis><emphasis
    role="bold">[, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">)] <emphasis role="bold">[,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ]</emphasis> </emphasis></para>

    <para><emphasis role="bold">[</emphasis><emphasis>,</emphasis><emphasis
    role="bold"> OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm> ]</emphasis><emphasis role="bold">
    [</emphasis><emphasis>,</emphasis><emphasis role="bold"> EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [ </emphasis><emphasis>days </emphasis><emphasis
    role="bold">] ) ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Optional. Specifies writing the file to the specified
              list of target clusters. If omitted, the file is written to the
              cluster on which the workunit executes. The number of physical
              file parts written to disk is always determined by the number of
              nodes in the cluster on which the workunit executes, regardless
              of the number of nodes on the target cluster(s).</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>A comma-delimited list of string constants containing the
              names of the clusters to write the file to. The names must be
              listed as they appear on the ECL Watch Activity page or returned
              by the Std.System.Thorlib.Group() function, optionally with
              square brackets containing a comma-delimited list of
              node-numbers (1-based) and/or ranges (specified with a dash, as
              in n-m) to indicate the specific set of nodes to write
              to.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Optional. Specifies writing the file to disk using both
              256-bit AES encryption and LZW compression.</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>A string constant containing the encryption key to use to
              encrypt the data.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Optional. Specifies overwriting the file if it already
              exists.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Optional. Specifies the file is a temporary file that may
              be automatically deleted after the specified number of
              days.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Optional. The number of days after which the file may be
              automatically deleted. If omitted, the default is seven
              (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>This form writes the <emphasis>recordset</emphasis> to the specified
    <emphasis>file</emphasis> in the specified <emphasis>format</emphasis> as
    a comma separated values ASCII file. The valid set of
    <emphasis>csvoptions</emphasis> are:</para>

    <para><emphasis role="bold">HEADING<indexterm>
        <primary>HEADING</primary>
      </indexterm>( [</emphasis> <emphasis>headertext</emphasis> <emphasis
    role="bold">[</emphasis> <emphasis>, footertext</emphasis> <emphasis
    role="bold">] ] [, SINGLE<indexterm>
        <primary>SINGLE</primary>
      </indexterm> ] )</emphasis></para>

    <para><emphasis role="bold">SEPARATOR<indexterm>
        <primary>SEPARATOR</primary>
      </indexterm>(</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">)</emphasis></para>

    <para><emphasis role="bold">TERMINATOR<indexterm>
        <primary>TERMINATOR</primary>
      </indexterm>(</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">)</emphasis></para>

    <para><emphasis role="bold">QUOTE<indexterm>
        <primary>QUOTE</primary>
      </indexterm>( [</emphasis> <emphasis>delimiters</emphasis> <emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">ASCII<indexterm>
        <primary>ASCII</primary>
      </indexterm> | EBCDIC<indexterm>
        <primary>EBCDIC</primary>
      </indexterm> | UNICODE<indexterm>
        <primary>UNICODE</primary>
      </indexterm></emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="95.80pt" />

        <colspec />

        <tbody>
          <row>
            <entry><emphasis role="bold">HEADING</emphasis></entry>

            <entry>Specifies file headers and footers.</entry>
          </row>

          <row>
            <entry><emphasis>headertext</emphasis></entry>

            <entry>Optional. The text of the header record to place in the
            file. If omitted, the field names are used.</entry>
          </row>

          <row>
            <entry><emphasis>footertext</emphasis></entry>

            <entry>Optional. The text of the footer record to place in the
            file. If omitted, no <emphasis>footertext</emphasis> is
            output.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">SINGLE</emphasis></entry>

            <entry>Optional. Specifies the <emphasis>headertext</emphasis> is
            written only to the beginning of part 1 and the
            <emphasis>footertext</emphasis> is written only at the end of part
            n (producing a "standard" CSV file). If omitted, the
            <emphasis>headertext</emphasis> and
            <emphasis>footertext</emphasis> are placed at the beginning and
            end of each file part (useful for producing complex XML
            output).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">SEPARATOR</emphasis></entry>

            <entry>Specifies the field delimiters.</entry>
          </row>

          <row>
            <entry><emphasis>delimiters</emphasis></entry>

            <entry>A single string constant (or comma-delimited list of string
            constants) that define the character(s) used to delimit the data
            in the CSV file.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">TERMINATOR</emphasis></entry>

            <entry>Specifies the record delimiters.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">QUOTE</emphasis></entry>

            <entry>Specifies the quotation <emphasis>delimiters</emphasis> for
            string values that may contain SEPARATOR or TERMINATOR
            <emphasis>delimiters</emphasis> as part of their data.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">ASCII</emphasis></entry>

            <entry>Specifies all output is in ASCII format, including any
            EBCDIC or UNICODE fields.</entry>
          </row>

          <row>
            <entry><emphasis role="bold">EBCDIC</emphasis></entry>

            <entry>Specifies all output is in EBCDIC format except the
            SEPARATOR and TERMINATOR (which are expressed as ASCII
            values).</entry>
          </row>

          <row>
            <entry><emphasis role="bold">UNICODE</emphasis></entry>

            <entry>Specifies all output is in Unicode UTF8 format</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>If none of the ASCII, EBCDIC, or UNICODE options are specified, the
    default output is in ASCII format with any UNICODE fields in UTF8 format.
    The other default <emphasis>csvoptions</emphasis> are: <programlisting>           CSV(HEADING('',''), SEPARATOR(','), TERMINATOR('\n'), QUOTE())</programlisting></para>

    <para>Example:</para>

    <programlisting>//SINGLE option writes the header only to the first file part:
OUTPUT(ds,,'~thor::outdata.csv',CSV(HEADING(SINGLE)));

//This example writes the header and footer to every file part:
OUTPUT(XMLds,,'~thor::outdata.xml',CSV(HEADING('&lt;XML&gt;','&lt;/XML&gt;')));
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_XML_Files">
    <title>OUTPUT XML Files<indexterm>
        <primary>XML Files</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - XML Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold">, [</emphasis><emphasis> format </emphasis><emphasis
    role="bold">]</emphasis><emphasis> ,file </emphasis><emphasis role="bold">
    </emphasis><emphasis>,</emphasis><emphasis role="bold">XML<indexterm>
        <primary>XML</primary>
      </indexterm> [ (</emphasis><emphasis>xmloptions</emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis> key </emphasis><emphasis
    role="bold">) ] [, CLUSTER<indexterm>
        <primary>CLUSTER</primary>
      </indexterm>(</emphasis><emphasis> target </emphasis><emphasis
    role="bold">) ] [</emphasis><emphasis>,</emphasis><emphasis role="bold">
    OVERWRITE<indexterm>
        <primary>OVERWRITE</primary>
      </indexterm> ]</emphasis><emphasis role="bold">
    [</emphasis><emphasis>,</emphasis><emphasis role="bold"> EXPIRE<indexterm>
        <primary>EXPIRE</primary>
      </indexterm>( [ </emphasis><emphasis>days </emphasis><emphasis
    role="bold">] ) ] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">CLUSTER</emphasis></entry>

              <entry>Optional. Specifies writing the file to the specified
              list of target clusters. If omitted, the file is written to the
              cluster on which the workunit executes. The number of physical
              file parts written to disk is always determined by the number of
              nodes in the cluster on which the workunit executes, regardless
              of the number of nodes on the target cluster(s).</entry>
            </row>

            <row>
              <entry><emphasis>target</emphasis></entry>

              <entry>A comma-delimited list of string constants containing the
              names of the clusters to write the file to. The names must be
              listed as they appear on the ECL Watch Activity page or returned
              by the Std.System.Thorlib.Group() function, optionally with
              square brackets containing a comma-delimited list of
              node-numbers (1-based) and/or ranges (specified with a dash, as
              in n-m) to indicate the specific set of nodes to write
              to.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">ENCRYPT</emphasis></entry>

              <entry>Optional. Specifies writing the file to disk using both
              256-bit AES encryption and LZW compression.</entry>
            </row>

            <row>
              <entry><emphasis>key</emphasis></entry>

              <entry>A string constant containing the encryption key to use to
              encrypt the data.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OVERWRITE</emphasis></entry>

              <entry>Optional. Specifies overwriting the file if it already
              exists.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">EXPIRE</emphasis></entry>

              <entry>Optional. Specifies the file is a temporary file that may
              be automatically deleted after the specified number of
              days.</entry>
            </row>

            <row>
              <entry><emphasis>days</emphasis></entry>

              <entry>Optional. The number of days after which the file may be
              automatically deleted. If omitted, the default is seven
              (7).</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>This form writes the <emphasis>recordset</emphasis> to the specified
    <emphasis>file</emphasis> as XML data with the name of each field in the
    specified <emphasis>format</emphasis> becoming the XML tag for that
    field's data. The valid set of <emphasis>xmloptions</emphasis> are:</para>

    <para><emphasis
    role="bold">‘</emphasis><emphasis>rowtag</emphasis><emphasis
    role="bold">'</emphasis></para>

    <para><emphasis role="bold">HEADING<indexterm>
        <primary>HEADING</primary>
      </indexterm>( </emphasis><emphasis>headertext </emphasis><emphasis
    role="bold">[</emphasis><emphasis>, footertext </emphasis><emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">TRIM<indexterm>
        <primary>TRIM</primary>
      </indexterm></emphasis><emphasis role="bold"> </emphasis></para>

    <para><emphasis role="bold">OPT<indexterm>
        <primary>OPT</primary>
      </indexterm><indexterm>
        <primary>TRIM OPT</primary>
      </indexterm></emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="84.45pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis>rowtag</emphasis></entry>

              <entry>The text to place in record delimiting tag.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">HEADING</emphasis></entry>

              <entry>Specifies placing header and footer records in the
              file.</entry>
            </row>

            <row>
              <entry><emphasis>headertext</emphasis></entry>

              <entry>The text of the header record to place in the
              file.</entry>
            </row>

            <row>
              <entry><emphasis>footertext</emphasis></entry>

              <entry>The text of the footer record to place in the
              file.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">TRIM</emphasis></entry>

              <entry>Specifies removing trailing blanks from string fields
              before output.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">OPT</emphasis></entry>

              <entry>Specifies omitting tags for any empty string field from
              the output.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>If no <emphasis>xmloptions</emphasis> are specified, the defaults
    are:</para>

    <programlisting>         XML('Row',HEADING('&lt;Dataset&gt;\n','&lt;/Dataset&gt;\n'))</programlisting>

    <para>Example:</para>

    <programlisting>R := {STRING10 fname,STRING12 lname};
B := DATASET([{'Fred','Bell'},{'George','Blanda'},{'Sam',''}],R);

OUTPUT(B,,'fred1.xml', XML); // writes B to the fred1.xml file
/* the Fred1.XML file looks like this:
&lt;Dataset&gt;
  &lt;Row&gt;&lt;fname&gt;Fred &lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/Row&gt;
  &lt;Row&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda &lt;/lname&gt;&lt;/Row&gt;
  &lt;Row&gt;&lt;fname&gt;Sam &lt;/fname&gt;&lt;lname&gt;&lt;/lname&gt;&lt;/Row&gt;
&lt;/Dataset&gt; */

OUTPUT(B,,'fred2.xml',XML('MyRow', HEADING('&lt;?xml version=1.0 ...?&gt;\n&lt;filetag&gt;\n','&lt;/filetag&gt;\n')));
/* the Fred2.XML file looks like this:
&lt;?xml version=1.0 ...?&gt;
&lt;filetag&gt;
  &lt;MyRow&gt;&lt;fname&gt;Fred &lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;Sam &lt;/fname&gt;&lt;lname&gt;&lt;/lname&gt;&lt;/MyRow&gt;
&lt;/filetag&gt; */

OUTPUT(B,,'fred3.xml',XML('MyRow',TRIM,OPT));
/* the Fred3.XML file looks like this:
&lt;Dataset&gt;
  &lt;MyRow&gt;&lt;fname&gt;Fred&lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda&lt;/lname&gt;&lt;/MyRow&gt;
  &lt;MyRow&gt;&lt;fname&gt;Sam&lt;/fname&gt;&lt;/MyRow&gt;
&lt;/Dataset&gt; */
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_PIPE_Files">
    <title>OUTPUT PIPE Files<indexterm>
        <primary>OUTPUT Pipe Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ]
    OUTPUT(</emphasis><emphasis>recordset</emphasis><emphasis role="bold">,
    [</emphasis><emphasis> format </emphasis><emphasis role="bold">]
    </emphasis><emphasis> ,</emphasis><emphasis role="bold">PIPE<indexterm>
        <primary>PIPE</primary>
      </indexterm>(</emphasis><emphasis> command </emphasis><emphasis
    role="bold">[</emphasis>, <emphasis role="bold"> CSV<indexterm>
        <primary>CSV</primary>
      </indexterm> | XML<indexterm>
        <primary>XML</primary>
      </indexterm>])</emphasis><emphasis> </emphasis><emphasis
    role="bold">[</emphasis>,<emphasis role="bold"> REPEAT<indexterm>
        <primary>REPEAT</primary>
      </indexterm>] )</emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="93.80pt" />

          <colspec />

          <tbody>
            <row>
              <entry><emphasis role="bold">PIPE</emphasis></entry>

              <entry>Indicates the specified command executes with the
              recordset provided as standard input to the command. This is a
              "write" pipe.</entry>
            </row>

            <row>
              <entry><emphasis>command</emphasis></entry>

              <entry>The name of a program to execute, which takes the file as
              its input stream.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">CSV</emphasis></entry>

              <entry>Optional. Specifies the output data format is CSV. If
              omitted, the format is raw.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">XML</emphasis></entry>

              <entry>Optional. Specifies the output data format is XML. If
              omitted, the format is raw.</entry>
            </row>

            <row>
              <entry><emphasis role="bold">REPEAT</emphasis></entry>

              <entry>Optional. Indicates a new instance of the specified
              command executes for each row in the recordset.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>This form sends the <emphasis>recordset</emphasis> in the specified
    <emphasis>format </emphasis>as standard input to the
    <emphasis>command</emphasis>. This is commonly known as an "output
    pipe."</para>

    <para>Example:</para>

    <programlisting>OUTPUT(A_People,,PIPE('MyCommandLIneProgram'),OVERWRITE);
   // sends the A_People to MyCommandLIneProgram as
   // standard in</programlisting>
  </sect2>

  <sect2 id="Named_OUTPUT">
    <title>Named OUTPUT<indexterm>
        <primary>NAMED OUTPUT</primary>
      </indexterm><indexterm>
        <primary>OUTPUT - NAMED Files</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis>recordset</emphasis><emphasis
    role="bold"> [,</emphasis><emphasis> format </emphasis><emphasis
    role="bold">] </emphasis><emphasis>,</emphasis><emphasis
    role="bold">NAMED<indexterm>
        <primary>NAMED</primary>
      </indexterm>(</emphasis><emphasis> name </emphasis><emphasis
    role="bold">) [,EXTEND<indexterm>
        <primary>EXTEND</primary>
      </indexterm>] [</emphasis><emphasis>,</emphasis><emphasis
    role="bold">ALL<indexterm>
        <primary>ALL</primary>
      </indexterm>])</emphasis></para>

    <para>This form writes the <emphasis>recordset</emphasis> to the workunit
    with the specified <emphasis>name</emphasis>. The EXTEND option allows
    multiple OUTPUT actions to the same <emphasis>named</emphasis> result. The
    ALL option is used to override the implicit CHOOSEN applied to interactive
    queries in the Query Builder program. This specifies returning all
    records.</para>

    <para>Example:</para>

    <programlisting>OUTPUT(CHOOSEN(people(firstname[1]='A'),10));
  // writes the A People to the query builder
OUTPUT(CHOOSEN(people(firstname[1]='A'),10),ALL);
  // writes all the A People to the query builder
OUTPUT(CHOOSEN(people(firstname[1]='A'),10),NAMED('fred'));
  // writes the A People to the fred named output
  
//a NAMED, EXTEND example:
errMsgRec := RECORD
  UNSIGNED4 code;
  STRING text;
END;
makeErrMsg(UNSIGNED4 _code,STRING _text) := DATASET([{_code, _text}], errMsgRec);
rptErrMsg(UNSIGNED4 _code,STRING _text) := OUTPUT(makeErrMsg(_code,_text),
                                                  NAMED('ErrorResult'),EXTEND);

OUTPUT(DATASET([{100, 'Failed'}],errMsgRec),NAMED('ErrorResult'),EXTEND);
  //Explicit syntax.

//Something else creates the dataset
OUTPUT(makeErrMsg(101, 'Failed again'),NAMED('ErrorResult'),EXTEND);
  
//output and dataset handled elsewhere.
rptErrMsg(102, 'And again');
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Scalar_Values">
    <title>OUTPUT Scalar Values<indexterm>
        <primary>OUTPUT Scalar Values</primary>
      </indexterm><indexterm>
        <primary>Scalar OUTPUT</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT<indexterm>
        <primary>OUTPUT</primary>
      </indexterm>(</emphasis><emphasis> expression </emphasis><emphasis
    role="bold">[</emphasis><emphasis>,</emphasis><emphasis role="bold">
    NAMED<indexterm>
        <primary>NAMED</primary>
      </indexterm>(</emphasis><emphasis> name </emphasis><emphasis
    role="bold">) ] )</emphasis></para>

    <para>This form is used to allow scalar <emphasis>expression</emphasis>
    output, particularly within SEQUENTIAL and PARALLEL action<indexterm>
        <primary>PARALLEL action</primary>
      </indexterm>s.</para>

    <para>Example:</para>

    <programlisting>OUTPUT(10) // scalar value output
OUTPUT('Fred') // scalar value output
</programlisting>
  </sect2>

  <sect2 id="OUTPUT_Workunit_Files">
    <title>OUTPUT Workunit Files<indexterm>
        <primary>OUTPUT Workunit Files</primary>
      </indexterm><indexterm>
        <primary>Workunit OUTPUT</primary>
      </indexterm></title>

    <para><emphasis role="bold">[</emphasis><emphasis>attr</emphasis>
    :=<emphasis role="bold"> ] OUTPUT(</emphasis><emphasis> recordset
    ,</emphasis><emphasis role="bold"> THOR<indexterm>
        <primary>THOR</primary>
      </indexterm> )</emphasis></para>

    <para>This form is used to store the resulting
    <emphasis>recordset</emphasis> as a file on disk "owned" by the workunit.
    The name of the file in the DFU is
    <emphasis>scope</emphasis>::RESULT::<emphasis>workunitid</emphasis>. This
    is useful when you want to view a large result
    <emphasis>recordset</emphasis> in the Query Builder program but do not
    want that much data to take up memory in the system data store.</para>

    <para>Example:</para>

    <programlisting>OUTPUT(Person(per_st='FL'), THOR)
  // output records to screen, but store the 
  // result on disk instead of in the workunit</programlisting>

    <para>See Also: <link linkend="TABLE">TABLE</link>, <link
    linkend="DATASET">DATASET</link>, <link linkend="PIPE">PIPE</link>, <link
    linkend="CHOOSEN">CHOOSEN</link></para>
  </sect2>
</sect1>
