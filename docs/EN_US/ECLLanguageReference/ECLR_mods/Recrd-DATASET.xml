<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="DATASET">
  <!-- DNT-Start --><title>DATASET<indexterm>
      <primary>DATASET</primary>
    </indexterm></title><!-- DNT-End -->

  <para><emphasis>attr</emphasis><emphasis role="bold"> :=
  <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> file, struct, filetype </emphasis><emphasis
  role="bold">[,<!-- DNT-Start -->LOOKUP<!-- DNT-End -->]);</emphasis></para>

  <para><emphasis>attr</emphasis><emphasis role="bold"> :=
  <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> dataset, file, filetype </emphasis><emphasis
  role="bold">[,<!-- DNT-Start -->LOOKUP<!-- DNT-End -->]);</emphasis></para>

  <para><emphasis>attr</emphasis><emphasis role="bold"> :=
  <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> </emphasis><emphasis
  role="bold"><!-- DNT-Start -->WORKUNIT<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->WORKUNIT<!-- DNT-End --></primary>
    </indexterm>( </emphasis>[ <emphasis>wuid ,</emphasis> ]<emphasis>
  namedoutput </emphasis><emphasis role="bold">)</emphasis><emphasis>, struct
  </emphasis><emphasis role="bold">);</emphasis></para>

  <para><emphasis role="bold">[ </emphasis><emphasis>attr</emphasis><emphasis
  role="bold"> := ] <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> recordset
  </emphasis><emphasis role="bold">[</emphasis><emphasis>, recstruct
  </emphasis><emphasis role="bold">] );</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> row
  </emphasis><emphasis role="bold">)</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> childstruct
  </emphasis><emphasis role="bold"> [</emphasis><emphasis>,
  </emphasis><emphasis role="bold"><!-- DNT-Start -->COUNT<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->COUNT<!-- DNT-End --></primary>
    </indexterm>(</emphasis><emphasis> count </emphasis><emphasis
  role="bold">) | <!-- DNT-Start -->LENGTH<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->LENGTH<!-- DNT-End --></primary>
    </indexterm>(</emphasis><emphasis> size </emphasis><emphasis role="bold">)
  ]</emphasis><emphasis role="bold"> [</emphasis><emphasis>,
  </emphasis><emphasis role="bold"><!-- DNT-Start -->CHOOSEN<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->CHOOSEN<!-- DNT-End --></primary>
    </indexterm>(</emphasis><emphasis> maxrecs </emphasis><emphasis
  role="bold">) ] )</emphasis></para>

  <para><emphasis role="bold">[<!-- DNT-Start -->GROUPED<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->GROUPED<!-- DNT-End --></primary>
    </indexterm>] [<!-- DNT-Start -->LINKCOUNTED<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->LINKCOUNTED<!-- DNT-End --></primary>
    </indexterm>] [<!-- DNT-Start -->STREAMED<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->STREAMED<!-- DNT-End --></primary>
    </indexterm>] <!-- DNT-Start -->DATASET<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->DATASET<!-- DNT-End --></primary>
    </indexterm>(</emphasis><emphasis> struct </emphasis><emphasis
  role="bold">)</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> dict
  </emphasis><emphasis role="bold">)</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> count, transform
  </emphasis><emphasis role="bold"> [, <!-- DNT-Start -->DISTRIBUTED<!-- DNT-End --> | <!-- DNT-Start -->LOCAL<!-- DNT-End --> ]
  )</emphasis></para>

  <informaltable colsep="1" frame="all" rowsep="1">
    <tgroup cols="2">
      <colspec align="left" colwidth="122.40pt" />

      <colspec />

      <tbody>
        <row>
          <entry><!-- DNT-Start --><emphasis>attr</emphasis><!-- DNT-End --></entry>

          <entry>The name of the <!-- DNT-Start -->DATASET<!-- DNT-End --> for later use in other
          definitions.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>file</emphasis><!-- DNT-End --></entry>

          <entry>A string constant containing the logical file name. See the
          <emphasis>Scope &amp; Logical Filenames</emphasis> section for more
          on logical filenames.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>struct</emphasis><!-- DNT-End --></entry>

          <entry>The <!-- DNT-Start -->RECORD<!-- DNT-End --> structure defining the layout of the fields. This
          may use <!-- DNT-Start -->RECORDOF<!-- DNT-End -->.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>filetype</emphasis><!-- DNT-End --></entry>

          <entry>One of the following keywords, optionally followed by
          relevant options for that specific type of file: <!-- DNT-Start -->THOR<!-- DNT-End --> /<!-- DNT-Start -->FLAT<!-- DNT-End -->, <!-- DNT-Start -->CSV<!-- DNT-End -->,
          <!-- DNT-Start -->XML<!-- DNT-End -->, <!-- DNT-Start -->JSON<!-- DNT-End -->, <!-- DNT-Start -->PIPE<!-- DNT-End -->. Each of these is discussed in its own section,
          below.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>dataset</emphasis><!-- DNT-End --></entry>

          <entry>A previously-defined <!-- DNT-Start -->DATASET<!-- DNT-End --> or recordset from which the
          record layout is derived. This form is primarily used by the <!-- DNT-Start -->BUILD<!-- DNT-End -->
          action and is equivalent to: <programlisting>      ds := <!-- DNT-Start -->DATASET<!-- DNT-End -->('filename',<!-- DNT-Start -->RECORDOF<!-- DNT-End -->(anotherdataset), ... )</programlisting></entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">LOOKUP</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies that the file layout should be looked up
          at compile time. See <emphasis>File Layout Resolution at Compile
          Time</emphasis> in the <emphasis>Programmer's Guide</emphasis> for
          more details.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">WORKUNIT</emphasis><!-- DNT-End --></entry>

          <entry>Specifies the <!-- DNT-Start -->DATASET<!-- DNT-End --> is the result of an <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the
          <!-- DNT-Start -->NAMED<!-- DNT-End --> option within the same or another workunit.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>wuid</emphasis><!-- DNT-End --></entry>

          <entry>Optional. A string expression that specifies the workunit
          identifier of the job that produced the <!-- DNT-Start -->NAMED<!-- DNT-End --> <!-- DNT-Start -->OUTPUT<!-- DNT-End -->.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>namedoutput</emphasis><emphasis
          role="bold"></emphasis><!-- DNT-End --></entry>

          <entry>A string expression that specifies the name given in the
          <!-- DNT-Start -->NAMED<!-- DNT-End --> option.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>recordset</emphasis><!-- DNT-End --></entry>

          <entry><para>A set of in-line data records. This can simply name a
          previously-defined set definition or explicitly use square brackets
          to indicate an in-line set definition. Within the square brackets
          records are separated by commas. The records are specified by
          either:</para><para>1) Using curly braces ({}) to surround the field
          values for each record. The field values within each record are
          comma-delimited.</para><para>2) A comma-delimited list of in-line
          transform functions that produce the data rows. All the transform
          functions in the list must produce records in the same result
          format.</para></entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>recstruct</emphasis><!-- DNT-End --></entry>

          <entry>Optional. The <!-- DNT-Start -->RECORD<!-- DNT-End --> structure of the
          <emphasis>recordset.</emphasis> Omittable <emphasis
          role="underline">only</emphasis> if the
          <emphasis>recordset</emphasis> parameter is just one record or a
          list of in-line transform functions.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>row</emphasis><!-- DNT-End --></entry>

          <entry>A single data record. This may be a single-record passed
          parameter, or the <!-- DNT-Start -->ROW<!-- DNT-End --> or <!-- DNT-Start -->PROJECT<!-- DNT-End --> function that defines a 1-row
          dataset.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>childstruct</emphasis><!-- DNT-End --></entry>

          <entry>The <!-- DNT-Start -->RECORD<!-- DNT-End --> structure of the child records being defined. This
          may use the <!-- DNT-Start -->RECORDOF<!-- DNT-End --> function.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">COUNT</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies the number of child records attached to
          the parent (for use when interfacing to external file
          formats).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>count</emphasis><!-- DNT-End --></entry>

          <entry>An expression defining the number of child records. This may
          be a constant or a field in the enclosing <!-- DNT-Start -->RECORD<!-- DNT-End --> structure
          (addressed as <!-- DNT-Start -->SELF<!-- DNT-End -->.<emphasis>fieldname</emphasis>).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">LENGTH</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies the <emphasis>size</emphasis> of the
          child records attached to the parent (for use when interfacing to
          external file formats).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>size</emphasis><!-- DNT-End --></entry>

          <entry>An expression defining the size of child records. This may be
          a constant or a field in the enclosing <!-- DNT-Start -->RECORD<!-- DNT-End --> structure (addressed
          as <!-- DNT-Start -->SELF<!-- DNT-End -->.<emphasis>fieldname</emphasis>).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">CHOOSEN</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Limits the number of child records attached to the
          parent. This implicitly uses the <!-- DNT-Start -->CHOOSEN<!-- DNT-End --> function wherever the child
          dataset is read.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>maxrecs</emphasis><!-- DNT-End --></entry>

          <entry>An expression defining the maximum number of child records
          for a single parent.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">GROUPED</emphasis><!-- DNT-End --></entry>

          <entry>Specifies the <!-- DNT-Start -->DATASET<!-- DNT-End --> being passed has been grouped using the
          <!-- DNT-Start -->GROUP<!-- DNT-End --> function.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">LINKCOUNTED</emphasis><!-- DNT-End --></entry>

          <entry>Specifies the <!-- DNT-Start -->DATASET<!-- DNT-End --> being passed or returned uses the link
          counted format (each row is stored as a separate memory allocation)
          instead of the default (embedded) format where the rows of a dataset
          are all stored in a single block of memory. This is primarily for
          use in <!-- DNT-Start -->BEGINC<!-- DNT-End -->++ functions or external C++ library functions.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">STREAMED</emphasis><!-- DNT-End --></entry>

          <entry>Specifies the <!-- DNT-Start -->DATASET<!-- DNT-End --> being returned is returned as a pointer
          to an IRowStream interface (see the eclhelper.hpp include file for
          the definition).<emphasis role="bold">Valid only as a return
          type.</emphasis> This is primarily for use in <!-- DNT-Start -->BEGINC<!-- DNT-End -->++ functions or
          external C++ library functions.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>struct</emphasis><!-- DNT-End --></entry>

          <entry>The <!-- DNT-Start -->RECORD<!-- DNT-End --> structure of the dataset field or parameter. This
          may use the <!-- DNT-Start -->RECORDOF<!-- DNT-End --> function.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>dict</emphasis><!-- DNT-End --></entry>

          <entry>The name of a <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> definition.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>count</emphasis><!-- DNT-End --></entry>

          <entry>An integer expression specifying the number of records to
          create.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>transform</emphasis><!-- DNT-End --></entry>

          <entry>The <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function that will create the records. This may
          take an integer <!-- DNT-Start -->COUNTER<!-- DNT-End --> parameter.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">DISTRIBUTED</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies distributing the created records across
          all nodes of the cluster. If omitted, all records are created on
          node 1.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">LOCAL</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies records are created on every
          node.</entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>

  <para>The <emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End --></emphasis> declaration defines a
  file of records, on disk or in memory. The layout of the records is
  specified by a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure (the <emphasis>struct</emphasis> or
  <emphasis>recstruct</emphasis> parameters described above). The distribution
  of records across execution nodes is undefined in general, as it depends on
  how the <!-- DNT-Start -->DATASET<!-- DNT-End --> came to be (sprayed in from a landing zone or written to
  disk by an <!-- DNT-Start -->OUTPUT<!-- DNT-End --> action), the size of the cluster on which it resides, and
  the size of the cluster on which it is used (to specify distribution
  requirements for a particular operation, see the <!-- DNT-Start -->DISTRIBUTE<!-- DNT-End -->
  function).</para>

  <para>The first two forms are alternatives to each other and either may be
  used with any of the <emphasis>filetypes</emphasis> described below
  (<emphasis role="bold"><!-- DNT-Start -->THOR<!-- DNT-End -->/<!-- DNT-Start -->FLAT<!-- DNT-End -->, <!-- DNT-Start -->CSV<!-- DNT-End -->, <!-- DNT-Start -->XML<!-- DNT-End -->, <!-- DNT-Start -->JSON<!-- DNT-End -->, <!-- DNT-Start -->PIPE<!-- DNT-End --></emphasis>).</para>

  <para>The third form defines the result of an <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->NAMED<!-- DNT-End --> option
  within the same workunit or the workunit specified by the
  <emphasis>wuid</emphasis> (see <emphasis role="bold">Named Output
  <!-- DNT-Start -->DATASETs<!-- DNT-End --></emphasis> below).</para>

  <para>The fourth form defines an in-line dataset (see <emphasis
  role="bold">In-line <!-- DNT-Start -->DATASETs<!-- DNT-End --></emphasis> below).</para>

  <para>The fifth form is only used in an expression context to allow you to
  in-line a single record dataset (see <emphasis role="bold">Single-row
  <!-- DNT-Start -->DATASET<!-- DNT-End --> Expressions</emphasis> below).</para>

  <para>The sixth form is only used as a value type in a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure to
  define a child dataset (see <emphasis role="bold">Child <!-- DNT-Start -->DATASETs<!-- DNT-End --></emphasis>
  below).</para>

  <para>The seventh form is only used as a value type to pass <!-- DNT-Start -->DATASET<!-- DNT-End -->
  parameters<indexterm>
      <primary><!-- DNT-Start -->DATASET<!-- DNT-End --> parameters</primary>
    </indexterm> (see <emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End --> as a Parameter Type
  </emphasis>below).</para>

  <para>The eighth form is used to define a <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> as a <!-- DNT-Start -->DATASET<!-- DNT-End --> (see
  <emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End --> from <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> </emphasis>below).</para>

  <para>The ninth form is used to create a <!-- DNT-Start -->DATASET<!-- DNT-End --> using a <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function
  (see <emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End --> from <!-- DNT-Start -->TRANSFORM<!-- DNT-End --></emphasis> below)</para>

  <sect2 id="THOR-FLAT_Files">
    <!-- DNT-Start --><title>THOR/FLAT Files</title><!-- DNT-End -->

    <para><emphasis> attr</emphasis><emphasis role="bold"> :=
    <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold"><!-- DNT-Start -->THOR<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->THOR<!-- DNT-End --></primary>
      </indexterm> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold"><!-- DNT-Start -->__COMPRESSED__<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->COMPRESSED<!-- DNT-End --></primary>
      </indexterm><indexterm>
        <primary><!-- DNT-Start -->__COMPRESSED__<!-- DNT-End --></primary>
      </indexterm>][,<!-- DNT-Start -->OPT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->OPT<!-- DNT-End --></primary>
      </indexterm> ]</emphasis><emphasis role="bold"> [,<!-- DNT-Start -->UNSORTED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->UNSORTED<!-- DNT-End --></primary>
      </indexterm>][,<!-- DNT-Start -->PRELOAD<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->PRELOAD<!-- DNT-End --></primary>
      </indexterm>([</emphasis><emphasis>nbr</emphasis><emphasis
    role="bold">])]</emphasis><emphasis role="bold"> [,<!-- DNT-Start -->ENCRYPT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ENCRYPT<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ]);</emphasis></para>

    <para><emphasis> attr</emphasis><emphasis role="bold"> :=
    <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold"><!-- DNT-Start -->FLAT<!-- DNT-End --> [</emphasis><emphasis>,</emphasis><emphasis
    role="bold"><!-- DNT-Start -->__COMPRESSED__<!-- DNT-End -->] [,<!-- DNT-Start -->OPT<!-- DNT-End -->]</emphasis><emphasis role="bold">
    [,<!-- DNT-Start -->UNSORTED<!-- DNT-End -->] [,<!-- DNT-Start -->PRELOAD<!-- DNT-End -->([</emphasis><emphasis>nbr</emphasis><emphasis
    role="bold">])]</emphasis><emphasis role="bold">
    [,<!-- DNT-Start -->ENCRYPT<!-- DNT-End -->(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ]);</emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">THOR</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is in the Data
            Refinery (may optionally be specified as <emphasis
            role="bold"><!-- DNT-Start -->FLAT<!-- DNT-End --></emphasis><indexterm>
                <primary><!-- DNT-Start -->FLAT<!-- DNT-End --></primary>
              </indexterm>, which is synonymous with <!-- DNT-Start -->THOR<!-- DNT-End --> in this
            context).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">__COMPRESSED__</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies that the <!-- DNT-Start -->THOR<!-- DNT-End --> <emphasis>file</emphasis>
            is compressed because it is a result of the <!-- DNT-Start -->PERSIST<!-- DNT-End --> Workflow
            Service or was <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->COMPRESSED<!-- DNT-End --> option.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">__GROUPED__</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <!-- DNT-Start -->DATASET<!-- DNT-End --> has been grouped using the <!-- DNT-Start -->GROUP<!-- DNT-End -->
            function.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">OPT</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies that using dataset when the <!-- DNT-Start -->THOR<!-- DNT-End -->
            <emphasis>file</emphasis> doesn't exist results in an empty
            recordset instead of an error condition.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">UNSORTED</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <!-- DNT-Start -->THOR<!-- DNT-End --> <emphasis>file</emphasis> is
            not sorted, as a hint to the optimizer.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">PRELOAD</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <emphasis>file</emphasis> is left
            in memory after loading (valid only for Rapid Data Delivery Engine
            use).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>nbr</emphasis><!-- DNT-End --></entry>

            <entry>Optional. An integer constant specifying how many indexes
            to create âon the flyâ for speedier access to the dataset. If &gt;
            1000, specifies the amount of memory set aside for these
            indexes.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ENCRYPT</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <emphasis>file</emphasis> was
            created by <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->ENCRYPT<!-- DNT-End --> option.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->key<!-- DNT-End --></entry>

            <entry>A string constant containing the encryption key used to
            create the file.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This form defines a <!-- DNT-Start -->THOR<!-- DNT-End --> file that exists in the Data Refinery. This
    could contain either fixed-length or variable-length records, depending on
    the layout specified in the <!-- DNT-Start -->RECORD<!-- DNT-End --> <emphasis>struct</emphasis>.</para>

    <para>The <emphasis>struct</emphasis> may contain an <!-- DNT-Start -->UNSIGNED<!-- DNT-End -->8 field with
    either <emphasis>{virtual(fileposition)}</emphasis> or
    <emphasis>{virtual(localfileposition)}</emphasis> appended to the field
    name. This indicates the field contains the record's position within the
    file (or part), and is used for those instances where a usable pointer to
    the record is needed, such as the <!-- DNT-Start -->BUILD<!-- DNT-End --> function.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>PtblRec := RECORD
  STRING2 State := Person.per_st;
  STRING20 City := Person.per_full_city;
  STRING25 Lname := Person.per_last_name;
  STRING15 Fname := Person.per_first_name;
END;
          
Tbl := TABLE(Person,PtblRec);
         
PtblOut := OUTPUT(Tbl,,'RTTEMP::TestFile');
          //write a THOR file
         
Ptbl := DATASET('~Thor400::RTTEMP::TestFile',
                {PtblRec,UNSIGNED8 __fpos {virtual(fileposition)}},
                THOR,OPT);
             // __fpos contains the "pointer" to each record
             // Thor400 is the scope name and RTTEMP is the
             // directory in which TestFile is located
             //using ENCRYPT
OUTPUT(Tbl,,'~Thor400::RTTEMP::TestFileEncrypted',ENCRYPT('mykey'));
PtblE := DATASET('~Thor400::RTTEMP::TestFileEncrypted',
                 PtblRec,
                 THOR,OPT,ENCRYPT('mykey'));</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="CSV_Files">
    <!-- DNT-Start --><title>CSV Files<indexterm>
        <primary>CSV Files</primary>
      </indexterm></title><!-- DNT-End -->

    <para><emphasis> attr</emphasis><emphasis role="bold"> :=
    <!-- DNT-Start -->DATASET<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->DATASET<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold"> <!-- DNT-Start -->CSV<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->CSV<!-- DNT-End --></primary>
      </indexterm> [ ( [ <!-- DNT-Start -->HEADING<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->HEADING<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>n</emphasis><emphasis role="bold"> )
    ] [, <!-- DNT-Start -->SEPARATOR<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SEPARATOR<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>f_delimiters</emphasis><emphasis
    role="bold"> ) ]</emphasis><emphasis role="bold"> </emphasis></para>

    <para><emphasis role="bold"> [, <!-- DNT-Start -->TERMINATOR<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->TERMINATOR<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>r_delimiters</emphasis><emphasis
    role="bold"> ) ] [, <!-- DNT-Start -->QUOTE<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->QUOTE<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>characters</emphasis><emphasis
    role="bold"> ) ]</emphasis><emphasis role="bold"> [, <!-- DNT-Start -->ESCAPE<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ESCAPE<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>esc</emphasis><emphasis role="bold">
    ) ] [, <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->MAXLENGTH<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>size</emphasis><emphasis role="bold">
    ) ]</emphasis></para>

    <para><emphasis role="bold"> [ <!-- DNT-Start -->ASCII<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ASCII<!-- DNT-End --></primary>
      </indexterm> | <!-- DNT-Start -->EBCDIC<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->EBCDIC<!-- DNT-End --></primary>
      </indexterm> | <!-- DNT-Start -->UNICODE<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->UNICODE<!-- DNT-End --></primary>
      </indexterm> ]</emphasis><emphasis role="bold"> [, <!-- DNT-Start -->NOTRIM<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->NOTRIM<!-- DNT-End --></primary>
      </indexterm> ]) ]</emphasis><emphasis role="bold"> [,<!-- DNT-Start -->ENCRYPT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ENCRYPT<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ] [, <!-- DNT-Start -->__COMPRESSED__<!-- DNT-End -->]);</emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">CSV</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is a âcomma
            separated valuesâ <!-- DNT-Start -->ASCII<!-- DNT-End --> file.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis
            role="bold">HEADING(</emphasis><emphasis>n</emphasis><emphasis
            role="bold">)</emphasis><!-- DNT-End --></entry>

            <entry>Optional. The number of header records in the
            <emphasis>file</emphasis>. If omitted, the default is zero
            (0).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">SEPARATOR</emphasis><!-- DNT-End --></entry>

            <entry>Optional. The field delimiter. If omitted, the default is a
            comma (',') or the delimiter specified in the spray operation that
            put the file on disk.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>f_delimiters</emphasis><!-- DNT-End --></entry>

            <entry>A single string constant, or set of string constants, that
            define the character(s) used as the field delimiter. If Unicode
            constants are used, then the <!-- DNT-Start -->UTF<!-- DNT-End -->8 representation of the
            character(s) will be used.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">TERMINATOR</emphasis><!-- DNT-End --></entry>

            <entry><para>Optional. The record delimiter. If omitted, the
            default is a line feed ('\n') or the delimiter specified in the
            spray operation that put the file on disk.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>r_delimiters</emphasis><!-- DNT-End --></entry>

            <entry><para>A single string constant, or set of string constants,
            that define the character(s) used as the record
            delimiter.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">QUOTE</emphasis><!-- DNT-End --></entry>

            <entry><para>Optional. The string quote character used. If
            omitted, the default is a single quote ('\'') or the delimiter
            specified in the spray operation that put the file on
            disk.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>characters</emphasis><!-- DNT-End --></entry>

            <entry><para>A single string constant, or set of string constants,
            that define the character(s) used as the string value
            delimiter.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ESCAPE</emphasis><!-- DNT-End --></entry>

            <entry><para>Optional. The string escape character used to
            indicate the next character (usually a control character) is part
            of the data and not to be interpreted as a field or row delimiter.
            If omitted, the default is the escape character specified in the
            spray operation that put the file on disk (if any).</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>esc</emphasis><!-- DNT-End --></entry>

            <entry><para>A single string constant, or set of string constants,
            that define the character(s) used to escape control
            characters.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis
            role="bold">MAXLENGTH(</emphasis><emphasis>size</emphasis><emphasis
            role="bold">)</emphasis><!-- DNT-End --></entry>

            <entry><para>Optional. Maximum record length in the
            <emphasis>file</emphasis>. If omitted, the default is
            4096.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ASCII</emphasis><!-- DNT-End --></entry>

            <entry><para>Specifies all input is in <!-- DNT-Start -->ASCII<!-- DNT-End --> format, including any
            <!-- DNT-Start -->EBCDIC<!-- DNT-End --> or <!-- DNT-Start -->UNICODE<!-- DNT-End --> fields.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">EBCDIC</emphasis><!-- DNT-End --></entry>

            <entry><para>Specifies all input is in <!-- DNT-Start -->EBCDIC<!-- DNT-End --> format except the
            <!-- DNT-Start -->SEPARATOR<!-- DNT-End --> and <!-- DNT-Start -->TERMINATOR<!-- DNT-End --> (which are expressed as <!-- DNT-Start -->ASCII<!-- DNT-End -->
            values).</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">UNICODE</emphasis><!-- DNT-End --></entry>

            <entry><para>Specifies all input is in Unicode <!-- DNT-Start -->UTF<!-- DNT-End -->8
            format.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">NOTRIM</emphasis><!-- DNT-End --></entry>

            <entry><para>Specifies preserving all whitespace in the input data
            (the default is to trim leading blanks).</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ENCRYPT</emphasis><!-- DNT-End --></entry>

            <entry><para>Optional. Specifies the <emphasis>file</emphasis> was
            created by <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->ENCRYPT<!-- DNT-End --> option.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>key</emphasis><!-- DNT-End --></entry>

            <entry><para>A string constant containing the encryption key used
            to create the file.</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">__COMPRESSED__</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies that the <emphasis>file</emphasis> is
            compressed because it was <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->COMPRESSED<!-- DNT-End -->
            option.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This form is used to read an <!-- DNT-Start -->ASCII<!-- DNT-End --> <!-- DNT-Start -->CSV<!-- DNT-End --> file. This can also be used
    to read any variable-length record file that has a defined record
    delimiter. If none of the <!-- DNT-Start -->ASCII<!-- DNT-End -->, <!-- DNT-Start -->EBCDIC<!-- DNT-End -->, or <!-- DNT-Start -->UNICODE<!-- DNT-End --> options are specified,
    the default input is in <!-- DNT-Start -->ASCII<!-- DNT-End --> format with any <!-- DNT-Start -->UNICODE<!-- DNT-End --> fields in <!-- DNT-Start -->UTF<!-- DNT-End -->8
    format.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>CSVRecord := RECORD
  UNSIGNED4 person_id;
  STRING20 per_surname;
  STRING20 per_forename;
END;

file1 := DATASET('MyFile.CSV',CSVrecord,CSV);            //all defaults
file2 := DATASET('MyFile.CSV',CSVrecord,CSV(HEADING(1)); //1 header
file3 := DATASET('MyFile.CSV',
                 CSVrecord,
                 CSV(HEADING(1),
                     SEPARATOR([',','\t']),
                     TERMINATOR(['\n','\r\n','\n\r'])));
          //1 header record, either comma or tab field delimiters,
          // either LF or CR/LF or LF/CR record delimiters</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="XML_Files">
    <!-- DNT-Start --><title>XML Files</title><!-- DNT-End -->

    <!-- DNT-Start --><para><emphasis> attr</emphasis><emphasis role="bold"> :=
    DATASET(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold">XML<indexterm>
        <primary>XML</primary>
      </indexterm>( </emphasis><emphasis>xpath</emphasis><emphasis
    role="bold"> [, NOROOT<indexterm>
        <primary>NOROOT</primary>
      </indexterm> ] ) [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ]);</emphasis></para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">XML</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is an <!-- DNT-Start -->XML<!-- DNT-End -->
            file.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>xpath</emphasis><!-- DNT-End --></entry>

            <entry>A string constant containing the full <!-- DNT-Start -->XPATH<!-- DNT-End --> to the tag that
            delimits the records in the <emphasis>file</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">NOROOT</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is an <!-- DNT-Start -->XML<!-- DNT-End --> file with
            no file tags, only row tags.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold"><emphasis
            role="bold">ENCRYPT</emphasis></emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <emphasis>file</emphasis> was
            created by <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->ENCRYPT<!-- DNT-End --> option.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>key</emphasis><!-- DNT-End --></entry>

            <entry>A string constant containing the encryption key used to
            create the file.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This form is used to read an <!-- DNT-Start -->XML<!-- DNT-End --> file into the Data Refinery. The
    <emphasis>xpath</emphasis> parameter defines the record delimiter tag
    using a subset of standard <!-- DNT-Start -->XPATH<!-- DNT-End --> (<emphasis
    role="underline">www.w3.org/<!-- DNT-Start -->TR<!-- DNT-End -->/xpath</emphasis>) syntax (see the <emphasis
    role="bold"><!-- DNT-Start -->XPATH<!-- DNT-End --> Support</emphasis> section under the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure
    discussion for a description of the supported subset).</para>

    <para>The key to getting individual field values from the <!-- DNT-Start -->XML<!-- DNT-End --> lies in the
    <!-- DNT-Start -->RECORD<!-- DNT-End --> structure<indexterm>
        <primary><!-- DNT-Start -->RECORD<!-- DNT-End --> structure</primary>
      </indexterm> field definitions. If the field name exactly matches a
    lower case <!-- DNT-Start -->XML<!-- DNT-End --> tag containing the data, then nothing special is required.
    Otherwise, <emphasis>{xpath(xpathtag)} </emphasis>appended to the field
    name (where the <emphasis>xpathtag</emphasis> is a string constant
    containing standard <!-- DNT-Start -->XPATH<!-- DNT-End --> syntax) is required to extract the data. An
    <!-- DNT-Start -->XPATH<!-- DNT-End --> consisting of empty angle brackets (&lt;&gt;) indicates the field
    receives the entire record. An absolute <!-- DNT-Start -->XPATH<!-- DNT-End --> is used to access properties
    of parent elements. Because <!-- DNT-Start -->XML<!-- DNT-End --> is case sensitive, and <!-- DNT-Start -->ECL<!-- DNT-End --> identifiers are
    case insensitive, xpaths need to be specified if the tag contains any
    upper case characters.</para>

    <para><emphasis role="bold">NOTE:</emphasis> <!-- DNT-Start -->XML<!-- DNT-End --> reading and parsing can
    consume a large amount of memory, depending on the usage. In particular,
    if the specified xpath matches a very large amount of data, then a large
    data structure will be provided to the transform. Therefore, the more you
    match, the more resources you consume per match. For example, if you have
    a very large document and you match an element near the root that
    virtually encompasses the whole thing, then the whole thing will be
    constructed as a referenceable structure that the <!-- DNT-Start -->ECL<!-- DNT-End --> can get at.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>/* an XML file called "MyFile" contains this XML data:
&lt;library&gt;
  &lt;book isbn="123456789X"&gt;
    &lt;author&gt;Bayliss&lt;/author&gt;
    &lt;title&gt;A Way Too Far&lt;/title&gt;
  &lt;/book&gt;
  &lt;book isbn="1234567801"&gt;
    &lt;author&gt;Smith&lt;/author&gt;
    &lt;title&gt;A Way Too Short&lt;/title&gt;
  &lt;/book&gt;
&lt;/library&gt;
*/

rform := RECORD
  STRING author; //data from author tag -- tag name is lowercase and matches field name
  STRING name {XPATH('title')}; //data from title tag, renaming the field
  STRING isbn {XPATH('@isbn')}; //isbn definition data from book tag
tag
END;
books := DATASET('MyFile',rform,XML('library/book'));</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="JSON_Files">
    <!-- DNT-Start --><title>JSON Files</title><!-- DNT-End -->

    <!-- DNT-Start --><para><emphasis> attr</emphasis><emphasis role="bold"> :=
    DATASET(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold">JSON<indexterm>
        <primary>JSON</primary>
      </indexterm>( </emphasis><emphasis>xpath</emphasis><emphasis
    role="bold"> [, NOROOT<indexterm>
        <primary>NOROOT</primary>
      </indexterm> ] ) [,ENCRYPT<indexterm>
        <primary>ENCRYPT</primary>
      </indexterm>(</emphasis><emphasis>key</emphasis><emphasis role="bold">)
    ]);</emphasis></para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">JSON</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is a <!-- DNT-Start -->JSON<!-- DNT-End -->
            file.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>xpath</emphasis><!-- DNT-End --></entry>

            <entry>A string constant containing the full <!-- DNT-Start -->XPATH<!-- DNT-End --> to the tag that
            delimits the records in the <emphasis>file</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">NOROOT</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis> is a <!-- DNT-Start -->JSON<!-- DNT-End --> file with
            no root level markup, only a collection of objects.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold"><emphasis
            role="bold">ENCRYPT</emphasis></emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <emphasis>file</emphasis> was
            created by <!-- DNT-Start -->OUTPUT<!-- DNT-End --> with the <!-- DNT-Start -->ENCRYPT<!-- DNT-End --> option.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>key</emphasis><!-- DNT-End --></entry>

            <entry>A string constant containing the encryption key used to
            create the file.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This form is used to read a <!-- DNT-Start -->JSON<!-- DNT-End --> file. The
    <emphasis>xpath</emphasis> parameter defines the path used to locate
    records within the <!-- DNT-Start -->JSON<!-- DNT-End --> content using a subset of standard <!-- DNT-Start -->XPATH<!-- DNT-End -->
    (<emphasis role="underline">www.w3.org/<!-- DNT-Start -->TR<!-- DNT-End -->/xpath</emphasis>) syntax (see
    the <emphasis role="bold"><!-- DNT-Start -->XPATH<!-- DNT-End --> Support</emphasis> section under the
    <!-- DNT-Start -->RECORD<!-- DNT-End --> structure discussion for a description of the supported
    subset).</para>

    <para>The key to getting individual field values from the <!-- DNT-Start -->JSON<!-- DNT-End --> lies in the
    <!-- DNT-Start -->RECORD<!-- DNT-End --> structure<indexterm>
        <primary><!-- DNT-Start -->RECORD<!-- DNT-End --> structure</primary>
      </indexterm> field definitions. If the field name exactly matches a
    lower case <!-- DNT-Start -->JSON<!-- DNT-End --> tag containing the data, then nothing special is required.
    Otherwise, <emphasis>{xpath(xpathtag)} </emphasis>appended to the field
    name (where the <emphasis>xpathtag</emphasis> is a string constant
    containing standard <!-- DNT-Start -->XPATH<!-- DNT-End --> syntax) is required to extract the data. An
    <!-- DNT-Start -->XPATH<!-- DNT-End --> consisting of empty quotes ('') indicates the field receives the
    entire record. An absolute <!-- DNT-Start -->XPATH<!-- DNT-End --> is used to access properties of child
    elements. Because <!-- DNT-Start -->JSON<!-- DNT-End --> is case sensitive, and <!-- DNT-Start -->ECL<!-- DNT-End --> identifiers are case
    insensitive, xpaths need to be specified if the tag contains any upper
    case characters.</para>

    <para><emphasis role="bold">NOTE:</emphasis> <!-- DNT-Start -->JSON<!-- DNT-End --> reading and parsing can
    consume a large amount of memory, depending on the usage. In particular,
    if the specified xpath matches a very large amount of data, then a large
    data structure will be provided to the transform. Therefore, the more you
    match, the more resources you consume per match. For example, if you have
    a very large document and you match an element near the root that
    virtually encompasses the whole thing, then the whole thing will be
    constructed as a referenceable structure that the <!-- DNT-Start -->ECL<!-- DNT-End --> can get at.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>/* a JSON  file called "MyBooks.json" contains this data:
[
  {
    "id" : "978-0641723445",
    "name" : "The Lightning Thief",
    "author" : "Rick Riordan"
  }
,
  {
    "id" : "978-1423103349",
    "name" : "The Sea of Monsters",
    "author" : "Rick Riordan"
  }
]
*/

BookRec := RECORD
  STRING ID {XPATH('id')}; //data from id tag -- renames field to uppercase
  STRING title {XPATH('name')}; //data from name tag, renaming the field
  STRING author; //data from author tag -- tag name is lowercase and matches field name  
END;

books := DATASET('~jd::mybooks.json',BookRec,JSON('/'));
OUTPUT(books);</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="PIPE_Files">
    <!-- DNT-Start --><title>PIPE Files<indexterm>
        <primary>PIPE Files</primary>
      </indexterm></title><!-- DNT-End -->

    <!-- DNT-Start --><para><emphasis> attr</emphasis><emphasis role="bold"> :=
    DATASET(</emphasis><emphasis> file, struct, </emphasis><emphasis
    role="bold">PIPE<indexterm>
        <primary>Pipe</primary>
      </indexterm>(</emphasis><emphasis> command </emphasis><emphasis
    role="bold"> [, CSV<indexterm>
        <primary>CSV</primary>
      </indexterm> | XML<indexterm>
        <primary>XML</primary>
      </indexterm> ]) );</emphasis></para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">PIPE</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>file</emphasis>comes from the
            <emphasis>command</emphasis>program. This is a âreadâ
            pipe.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>command</emphasis><!-- DNT-End --></entry>

            <entry>The name of the program to execute, which must output
            records in the <emphasis>struct</emphasis> format to standard
            output.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">CSV</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the output data format is <!-- DNT-Start -->CSV<!-- DNT-End -->. If
            omitted, the format is raw.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">XML</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the output data format is <!-- DNT-Start -->XML<!-- DNT-End -->. If
            omitted, the format is raw.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This form uses <!-- DNT-Start -->PIPE<!-- DNT-End -->(<emphasis>command</emphasis>) to send the
    <emphasis>file</emphasis> to the <emphasis>command</emphasis> program,
    which then returns the records to standard output in the
    <emphasis>struct</emphasis> format. This is also known as an input <!-- DNT-Start -->PIPE<!-- DNT-End -->
    (analogous to the <!-- DNT-Start -->PIPE<!-- DNT-End --> function<indexterm>
        <primary><!-- DNT-Start -->PIPE<!-- DNT-End --> function</primary>
      </indexterm> and <!-- DNT-Start -->PIPE<!-- DNT-End --> option on <!-- DNT-Start -->OUTPUT<!-- DNT-End -->).</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>PtblRec := RECORD
  STRING2 State;
  STRING20 City;
  STRING25 Lname;
  STRING15 Fname;
END;
         
Ptbl := DATASET('~Thor50::RTTEMP::TestFile',
                PtblRec,
                PIPE('ProcessFile'));
          // ProcessFile is the input pipe</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="Named_Output_DATASETs">
    <!-- DNT-Start --><title>Named Output DATASET<indexterm>
        <primary>Named Output Dataset</primary>
      </indexterm>s</title><!-- DNT-End -->

    <para><emphasis> attr</emphasis><emphasis role="bold"> :=
    <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> </emphasis><emphasis
    role="bold"><!-- DNT-Start -->WORKUNIT<!-- DNT-End --><indexterm>
        <primary>Workunit</primary>
      </indexterm>( </emphasis>[ <emphasis>wuid ,</emphasis> ]<emphasis>
    namedoutput </emphasis><emphasis role="bold">)</emphasis><emphasis>,
    struct </emphasis><emphasis role="bold">);</emphasis></para>

    <para>This form allows you to use as a <!-- DNT-Start -->DATASET<!-- DNT-End --> the result of an <!-- DNT-Start -->OUTPUT<!-- DNT-End -->
    with the <!-- DNT-Start -->NAMED<!-- DNT-End --> option within the same workunit, or the workunit specified
    by the <emphasis>wuid</emphasis> (workunit <!-- DNT-Start -->ID<!-- DNT-End -->). This is a feature most
    useful in the Rapid Data Delivery Engine.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>//Named Output DATASET in the same workunit:
a := OUTPUT(Person(per_st='FL') ,NAMED('FloridaFolk'));
x := DATASET(WORKUNIT('FloridaFolk'),
             RECORDOF(Person));
b := OUTPUT(x(per_first_name[1..4]='RICH'));
          
SEQUENTIAL(a,b);

//Named Output DATASET in separate workunits:
//First Workunit (wuid=W20051202-155102) contains this code:
MyRec := {STRING1 Value1,STRING1 Value2, INTEGER1 Value3};
SomeFile := DATASET([{'C','G',1},{'C','C',2},{'A','X',3},
                     {'B','G',4},{'A','B',5}],MyRec);
OUTPUT(SomeFile,NAMED('Fred'));

// Second workunit contains this code, producing the same result:
ds := DATASET(WORKUNIT('W20051202-155102','Fred'), MyRec);
OUTPUT(ds);</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="In-line_DATASETs">
    <!-- DNT-Start --><title>In-line DATASET<indexterm>
        <primary>In-Line Dataset</primary>
      </indexterm><indexterm>
        <primary>In Line Dataset</primary>
      </indexterm>s</title><!-- DNT-End -->

    <para><emphasis role="bold"> [
    </emphasis><emphasis>attr</emphasis><emphasis role="bold"> := ]
    <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> recordset , recstruct</emphasis><emphasis
    role="bold"> );</emphasis></para>

    <para>This form allows you to in-line a set of data<indexterm>
        <primary>in-line a set of data</primary>
      </indexterm> and have it treated as a file. This is useful in situations
    where file operations are needed on dynamically generated data (such as
    the runtime values of a set of pre-defined expressions). It is also useful
    to test any boundary conditions for definitions by creating a small
    well-defined set of records with constant values<indexterm>
        <primary>constant values</primary>
      </indexterm> that specifically exercise those boundaries. This form may
    be used in an expression context.</para>

    <para>Nested <!-- DNT-Start -->RECORD<!-- DNT-End --> structure<indexterm>
        <primary><!-- DNT-Start -->RECORD<!-- DNT-End --> structure</primary>
      </indexterm>s may be represented by nesting records within records.
    Nested child datasets may also be initialized inside <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> functions
    using inline datasets (see the <emphasis role="bold">Child
    <!-- DNT-Start -->DATASETs<!-- DNT-End --></emphasis> discussion).</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>//Inline DATASET using definition values
myrec := {REAL diff, INTEGER1 reason};
rms5008 := 10.0;
rms5009 := 11.0;
rms5010 := 12.0;
btable := DATASET([{rms5008,72},{rms5009,7},{rms5010,65}], myrec);
          
//Inline DATASET with nested RECORD structures
nameRecord := {STRING20 lname,STRING10 fname,STRING1 initial := ''};
personRecord := RECORD
  nameRecord primary;
  nameRecord mother;
  nameRecord father;
END;
personDataset := DATASET([{{'James','Walters','C'},
                           {'Jessie','Blenger'},
                           {'Horatio','Walters'}},
                          {{'Anne','Winston'},
                           {'Sant','Aclause'},
                           {'Elfin','And'}}], personRecord);
        
        
// Inline DATASET containing a Child DATASET
childPersonRecord := {STRING fname,UNSIGNED1 age};
personRecord := RECORD
  STRING20 fname;
  STRING20 lname;
  UNSIGNED2 numChildren;
  DATASET(childPersonRecord) children;
END;
123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
personDataset := DATASET([{'Kevin','Hall',2,[{'Abby',2},{'Nat',2}]},
                          {'Jon','Simms',3,[{'Jen',18},{'Ali',16},{'Andy',13}]}],
                         personRecord);
         
         
// Inline DATASET derived from a dynamic SET function
SetIDs(STRING fname) := SET(People(firstname=fname),id);
ds := DATASET(SetIDs('RICHARD'),{People.id});
         
// Inline DATASET derived from a list of transforms
IDtype := UNSIGNED8;
FMtype := STRING15;
Ltype := STRING25;

resultRec := RECORD
  IDtype id;
  FMtype firstname;
  Ltype lastname;
  FMtype middlename;
END;
          
T1(IDtype idval,FMtype fname,Ltype lname ) :=
  TRANSFORM(resultRec,
            SELF.id := idval,
            SELF.firstname := fname,
            SELF.lastname := lname,
            SELF := []);
          
T2(IDtype idval,FMtype fname,FMtype mname, Ltype lname ) :=
  TRANSFORM(resultRec,
            SELF.id := idval,
            SELF.firstname := fname,
            SELF.middlename := mname,
            SELF.lastname := lname);
ds := DATASET([T1(123,'Fred','Jones'),
               T2(456,'John','Q','Public'),
               T1(789,'Susie','Smith')]);</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="Single-row_DATASET_Expressions">
    <!-- DNT-Start --><title>Single-row DATASET<indexterm>
        <primary>Single-Row Dataset</primary>
      </indexterm><indexterm>
        <primary>Single Row Dataset</primary>
      </indexterm> Expressions</title><!-- DNT-End -->

    <para><emphasis role="bold"> <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> row
    </emphasis><emphasis role="bold">)</emphasis></para>

    <para>This form is only used in an expression context. It allows you to
    in-line a single record dataset.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>//the following examples demonstrate 4 ways to do the same thing:
personRecord := RECORD
  STRING20 surname;
  STRING10 forename;
  INTEGER2 age := 25;
END;
         
namesRecord := RECORD
  UNSIGNED     id;
  personRecord;
END;
          
namesTable := DATASET('RTTEST::TestRow',namesRecord,THOR);
//simple dataset file declaration form
         
addressRecord := RECORD
  UNSIGNED         id;
  DATASET(personRecord) people;   //child dataset form
  STRING40       street;
  STRING40       town;
  STRING2        st;
END;
         
personRecord tc0(namesRecord L) := TRANSFORM
  SELF := L;
END;
 
//** 1st way - using in-line dataset form in an expression  context
addressRecord t0(namesRecord L) := TRANSFORM
  SELF.people := PROJECT(DATASET([{L.id,L.surname,L.forename,L.age}],
                                 namesRecord),
                         tc0(LEFT));
  SELF.id := L.id;
  SELF := [];
END;
 
p0 := PROJECT(namesTable, t0(LEFT));
OUTPUT(p0);
 
//** 2nd way - using single-row dataset form
addressRecord t1(namesRecord L) := TRANSFORM
  SELF.people := PROJECT(DATASET(L), tc0(LEFT));
  SELF.id := L.id;
  SELF := [];
END;

p1 := PROJECT(namesTable, t1(LEFT));
OUTPUT(p1);

//** 3rd way - using single-row dataset form and ROW function
addressRecord t2(namesRecord L) := TRANSFORM
  SELF.people := DATASET(ROW(L,personRecord));
  SELF.id := L.id;
  SELF := [];
END;

p2 := PROJECT(namesTable, t2(LEFT));
OUTPUT(p2);

//** 4th way - using in-line dataset form in an expression context
addressRecord t4(namesRecord l) := TRANSFORM
  SELF.people := PROJECT(DATASET([L], namesRecord), tc0(LEFT));
  SELF.id := L.id;
  SELF := [];
END;
p3 := PROJECT(namesTable, t4(LEFT));
OUTPUT(p3);</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="Child_DATASETs">
    <!-- DNT-Start --><title>Child DATASET<indexterm>
        <primary>Child Dataset</primary>
      </indexterm>s</title><!-- DNT-End -->

    <para><emphasis role="bold"> <!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> childstruct
    </emphasis><emphasis role="bold"> [</emphasis><emphasis>,
    </emphasis><emphasis role="bold"><!-- DNT-Start -->COUNT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->COUNT<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> count </emphasis><emphasis
    role="bold">) | <!-- DNT-Start -->LENGTH<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->LENGTH<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> size </emphasis><emphasis
    role="bold">) ]</emphasis><emphasis role="bold"> [</emphasis><emphasis>,
    </emphasis><emphasis role="bold"><!-- DNT-Start -->CHOOSEN<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->CHOOSEN<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> maxrecs </emphasis><emphasis
    role="bold">) ] )</emphasis></para>

    <para>This form is used as a value type inside a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure to
    define child dataset records<indexterm>
        <primary>child dataset records</primary>
      </indexterm> in a non-normalized flat file. The form without <!-- DNT-Start -->COUNT<!-- DNT-End --> or
    <!-- DNT-Start -->LENGTH<!-- DNT-End --> is the simplest to use, and just means that the dataset the length
    and data are stored within myfield. The <!-- DNT-Start -->COUNT<!-- DNT-End --> form limits the number of
    elements to the <emphasis>count</emphasis> expression. The <!-- DNT-Start -->LENGTH<!-- DNT-End --> form
    specifies the <emphasis>size</emphasis> in another field instead of the
    count. This can only be used for dataset input.</para>

    <para>The following alternative syntaxes are also supported:</para>

    <para><emphasis> childstruct </emphasis><emphasis role="bold">fieldname
    [</emphasis><emphasis> </emphasis><!-- DNT-Start -->SELF<!-- DNT-End -->.<emphasis>count
    </emphasis><emphasis role="bold">]</emphasis><emphasis
    role="bold"></emphasis></para>

    <para><emphasis role="bold"> <!-- DNT-Start -->DATASET<!-- DNT-End --> newname :=
    fieldname</emphasis></para>

    <para><emphasis role="bold"> <!-- DNT-Start -->DATASET<!-- DNT-End --> fieldname (deprecated form -- will go
    away post-<!-- DNT-Start -->SR<!-- DNT-End -->9)</emphasis></para>

    <para>Any operation may be performed on child datasets in hthor and the
    Rapid Data Delivery Engine (Roxie), but only the following operations are
    supported in the Data Refinery (Thor):</para>

    <para>1) <!-- DNT-Start -->PROJECT<!-- DNT-End -->, <!-- DNT-Start -->CHOOSEN<!-- DNT-End -->, <!-- DNT-Start -->TABLE<!-- DNT-End --> (non-grouped), and filters on child
    tables.</para>

    <para>2) Aggregate operations are allowed on any of the above</para>

    <para>3) Several aggregates can be calculated at once by using</para>

    <!-- DNT-Start --><programlisting>          summary := TABLE(x.children,{ f1 := COUNT(GROUP),
                                        f2 := SUM(GROUP,x),
                                        f3 := MAX(GROUP,y)});
          summary.f1;</programlisting><!-- DNT-End -->

    <para>4) <!-- DNT-Start -->DATASET<!-- DNT-End -->[<emphasis>n</emphasis>] is supported to index the child
    elements</para>

    <para>5) <!-- DNT-Start -->SORT<!-- DNT-End -->(dataset, a, b)[1] is also supported to retrieve the best
    match.</para>

    <para>6) Concatenation<indexterm>
        <primary>Concatenation</primary>
      </indexterm> of datasets is supported.</para>

    <para>7) Temporary <!-- DNT-Start -->TABLEs<!-- DNT-End --> can be used in conjunction.</para>

    <para>8) Initialization of child datasets in temp <!-- DNT-Start -->TABLE<!-- DNT-End --> definitions allows
    [ ] to be used to initialize 0 elements.</para>

    <para>Note that,</para>

    <!-- DNT-Start --><programlisting>TABLE(ds, { ds.id, ds.children(age != 10) });</programlisting><!-- DNT-End -->

    <para>is not supported, because a dataset in a record definition means
    âexpand all the fields from the dataset in the output.â However adding an
    identifier creates a form that is supported:</para>

    <!-- DNT-Start --><programlisting>TABLE(ds, { ds.id, newChildren := ds.children(age != 10); });</programlisting><!-- DNT-End -->

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>ParentRec := {INTEGER1 NameID, STRING20 Name};
ParentTable := DATASET([{1,'Kevin'},{2,'Liz'},
                        {3,'Mr Nobody'},{4,'Anywhere'}], ParentRec);
ChildRec := {INTEGER1 NameID, STRING20 Addr};
ChildTable := DATASET([ {1,'10 Malt Lane'},{2,'10 Malt Lane'},
                        {2,'3 The cottages'},{4,'Here'},{4,'There'},
                        {4,'Near'},{4,'Far'}],ChildRec);
DenormedRec := RECORD
  INTEGER1 NameID;
  STRING20 Name;
  UNSIGNED1 NumRows;
  DATASET(ChildRec) Children;
//  ChildRec Children;   //alternative syntax
END;
 
DenormedRec ParentMove(ParentRec L) := TRANSFORM
  SELF.NumRows := 0;
  SELF.Children := [];
  SELF := L;
END;

ParentOnly := PROJECT(ParentTable, ParentMove(LEFT));
DenormedRec ChildMove(DenormedRec L,ChildRec R,INTEGER C):=TRANSFORM
  SELF.NumRows := C;
  SELF.Children := L.Children + R;
  SELF := L;
END;
DeNormedRecs := DENORMALIZE(ParentOnly, ChildTable,
                            LEFT.NameID = RIGHT.NameID,
                            ChildMove(LEFT,RIGHT,COUNTER<indexterm>
        <primary>COUNTER</primary>
      </indexterm>));
OUTPUT(DeNormedRecs,,'RTTEMP::TestChildDatasets');

// Using inline DATASET in a TRANSFORM to initialize child records
AkaRec := {STRING20 forename,STRING20 surname};
outputRec := RECORD
  UNSIGNED id;
  DATASET(AkaRec) children;
END;
 
inputRec := RECORD
  UNSIGNED id;
  STRING20 forename;
  STRING20 surname;
END;
 
inPeople := DATASET([
         {1,'Kevin','Halliday'},{1,'Kevin','Hall'},{1,'Gawain',''},
         {2,'Liz','Halliday'},{2,'Elizabeth','Halliday'},
         {2,'Elizabeth','MaidenName'},{3,'Lorraine','Chapman'},
         {4,'Richard','Chapman'},{4,'John','Doe'}], inputRec);
outputRec makeFatRecord(inputRec l) := TRANSFORM
  SELF.id := l.id;
  SELF.children := DATASET([{ l.forename, l.surname }], AkaRec);
END;

fatIn := PROJECT(inPeople, makeFatRecord(LEFT));
outputRec makeChildren(outputRec l, outputRec r) := TRANSFORM
  SELF.id := l.id;
  SELF.children := l.children + ROW({r.children[1].forename,
                                     r.children[1].surname},
                                     AkaRec);
END;

r := ROLLUP(fatIn, id, makeChildren(LEFT, RIGHT));</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="DATASET_as_a_Parameter_Type">
    <!-- DNT-Start --><title>DATASET as a Parameter Type</title><!-- DNT-End -->

    <para><emphasis role="bold">[<!-- DNT-Start -->GROUPED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->GROUPED<!-- DNT-End --></primary>
      </indexterm>] [<!-- DNT-Start -->LINKCOUNTED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->LINKCOUNTED<!-- DNT-End --></primary>
      </indexterm>] [<!-- DNT-Start -->STREAMED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->STREAMED<!-- DNT-End --></primary>
      </indexterm>] <!-- DNT-Start -->DATASET<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->DATASET<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> struct </emphasis><emphasis
    role="bold">)</emphasis></para>

    <para>This form is only used as a Value Type for passing
    parameters<indexterm>
        <primary>Passing a <!-- DNT-Start -->DATASET<!-- DNT-End --> parameter</primary>
      </indexterm>, specifying function return types, or defining a <!-- DNT-Start -->SET<!-- DNT-End --> <!-- DNT-Start -->OF<!-- DNT-End -->
    datasets. If <!-- DNT-Start -->GROUPED<!-- DNT-End --> is present, the passed parameter must have been
    grouped using the <!-- DNT-Start -->GROUP<!-- DNT-End --> function. The <!-- DNT-Start -->LINKCOUNTED<!-- DNT-End --> and <!-- DNT-Start -->STREAMED<!-- DNT-End --> keywords
    are primarily for use in <!-- DNT-Start -->BEGINC<!-- DNT-End -->++ functions or external C++ library
    functions.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>MyRec := {STRING1 Letter};
SomeFile := DATASET([{'A'},{'B'},{'C'},{'D'},{'E'}],MyRec);
         
//Passing a DATASET parameter
FilteredDS(DATASET(MyRec) ds) := ds(Letter NOT IN ['A','C','E']);
                  //passed dataset referenced as âdsâ in expression
          
OUTPUT(FilteredDS(SomeFile));

//*****************************************************************
// The following example demonstrates using DATASET as both a
// parameter type and a return type
rec_Person := RECORD
  STRING20 FirstName;
  STRING20 LastName;
END;

rec_Person_exp := RECORD(rec_Person)
  STRING20 NameOption;
END;

rec_Person_exp xfm_DisplayNames(rec_Person l, INTEGER w) :=
    TRANSFORM
  SELF.NameOption :=
           CHOOSE(w,
                  TRIM(l.FirstName) + ' ' + l.LastName,
                  TRIM(l.LastName) + ', ' + l.FirstName,
                  l.FirstName[1] + l.LastName[1],
                  l.LastName);
  SELF := l;
END;

DATASET(rec_Person_exp) prototype(DATASET(rec_Person) ds) :=
     DATASET( [], rec_Person_exp );

DATASET(rec_Person_exp) DisplayFullName(DATASET(rec_Person) ds) :=
     PROJECT(ds, xfm_DisplayNames(LEFT,1));

DATASET(rec_Person_exp) DisplayRevName(DATASET(rec_Person) ds) :=
     PROJECT(ds, xfm_DisplayNames(LEFT,2));

DATASET(rec_Person_exp) DisplayFirstName(DATASET(rec_Person) ds) :=
     PROJECT(ds, xfm_DisplayNames(LEFT,3));

DATASET(rec_Person_exp) DisplayLastName(DATASET(rec_Person) ds) :=
     PROJECT(ds, xfm_DisplayNames(LEFT,4));

DATASET(rec_Person_exp) PlayWithName(DATASET(rec_Person) ds_in,
                                     prototype PassedFunc,
                                     STRING1 SortOrder='A',
                                     UNSIGNED1 FieldToSort=1,
                                     UNSIGNED1 PrePostFlag=1) := FUNCTION
  FieldPre := CHOOSE(FieldToSort,ds_in.FirstName,ds_in.LastName);
  SortedDSPre(DATASET(rec_Person) ds) :=
      IF(SortOrder='A',
         SORT(ds,FieldPre),
         SORT(ds,-FieldPre));
  InDS := IF(PrePostFlag=1,SortedDSPre(ds_in),ds_in);
  
  PDS := PassedFunc(InDS); //call the passed function parameter
         
  FieldPost := CHOOSE(FieldToSort,
                      PDS.FirstName, 
                      PDS.LastName,
                      PDS.NameOption);
  SortedDSPost(DATASET(rec_Person_exp) ds) :=
        IF(SortOrder = 'A',
          SORT(ds,FieldPost),
          SORT(ds,-FieldPost));
      
  OutDS := IF(PrePostFlag=1,PDS,SortedDSPost(PDS));
  RETURN OutDS;
END;

    //define inline datasets to use.
ds_names1 := DATASET( [{'John','Smith'},{'Henry','Jackson'},
                       {'Harry','Potter'}], rec_Person );
ds_names2 := DATASET( [ {'George','Foreman'},
                        {'Sugar Ray','Robinson'},
                        {'Joe','Louis'}], rec_Person );
          

//get name you want by passing the appropriate function parameter:
s_Name1 := PlayWithName(ds_names1, DisplayFullName, 'A',1,1);
s_Name2 := PlayWithName(ds_names2, DisplayRevName, 'D',3,2);
a_Name := PlayWithName(ds_names1, DisplayFirstName,'A',1,1);
b_Name := PlayWithName(ds_names2, DisplayLastName, 'D',1,1);
OUTPUT(s_Name1);
OUTPUT(s_Name2);
OUTPUT(a_Name);
OUTPUT(b_Name);</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="DATASET_from_DICTIONARY">
    <!-- DNT-Start --><title>DATASET from DICTIONARY</title><!-- DNT-End -->

    <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> dict
    </emphasis><emphasis role="bold">)</emphasis></para>

    <para>This form re-defines the<emphasis> dict </emphasis> as a
    <!-- DNT-Start -->DATASET<!-- DNT-End --><indexterm>
        <primary>Treating <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> as a <!-- DNT-Start -->DATASET<!-- DNT-End --></primary>
      </indexterm>.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>rec := {STRING color,UNSIGNED1 code, STRING name};
ColorCodes := DATASET([{'Black' ,0 , 'Fred'},
                       {'Brown' ,1 , 'Sam'},
                       {'Red'   ,2 , 'Sue'},
                       {'White' ,3 , 'Jo'}], rec);

ColorCodesDCT := DICTIONARY(ColorCodes,{Color,Code});

ds := DATASET(ColorCodesDCT);
OUTPUT(ds);         </programlisting><!-- DNT-End -->

    <para>See Also: <link linkend="OUTPUT"><!-- DNT-Start -->OUTPUT<!-- DNT-End --></link>, <link
    linkend="RECORD_Structure"><!-- DNT-Start -->RECORD<!-- DNT-End --> Structure</link>, <link
    linkend="TABLE"><!-- DNT-Start -->TABLE<!-- DNT-End --></link>, <link linkend="ROW"><!-- DNT-Start -->ROW<!-- DNT-End --></link>, <link
    linkend="RECORDOF"><!-- DNT-Start -->RECORDOF<!-- DNT-End --></link>, <link
    linkend="TRANSFORM_Structure"><!-- DNT-Start -->TRANSFORM<!-- DNT-End --> Structure</link>, <link
    linkend="DICTIONARY"><!-- DNT-Start -->DICTIONARY<!-- DNT-End --></link></para>
  </sect2>

  <sect2 id="DATASET_from_TRANSFORM">
    <!-- DNT-Start --><title>DATASET from TRANSFORM</title><!-- DNT-End -->

    <para><emphasis role="bold"><!-- DNT-Start -->DATASET<!-- DNT-End -->(</emphasis><emphasis> count, transform
    </emphasis><emphasis role="bold"> [, <!-- DNT-Start -->DISTRIBUTED<!-- DNT-End --> | <!-- DNT-Start -->LOCAL<!-- DNT-End --> ]
    )</emphasis></para>

    <para>This form uses the<emphasis> transform </emphasis> to create the
    records. The result type of the <emphasis>transform</emphasis> function
    determines the structure. The integer <!-- DNT-Start -->COUNTER<!-- DNT-End --> can be used to number each
    iteration of the <emphasis>transform</emphasis> function.</para>

    <para><!-- DNT-Start -->LOCAL<!-- DNT-End --> executes separately and independently on each node.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>IMPORT STD;
msg(UNSIGNED c) := 'Rec ' + (STRING)c + ' on node ' + (STRING)(STD.system.Thorlib.Node()+1);

// DISTRIBUTED example
DS := DATASET(CLUSTERSIZE * 2,
              TRANSFORM({STRING line}, 
                        SELF.line := msg(COUNTER)), 
              DISTRIBUTED);
DS;
/* creates a result like this:
   Rec 1 on node 1
   Rec 2 on node 1
   Rec 3 on node 2
   Rec 4 on node 2
   Rec 5 on node 3
   Rec 6 on node 3 
*/

// LOCAL example

DS2 := DATASET(2,
              TRANSFORM({STRING line},
                        SELF.line := msg(COUNTER)),
              LOCAL);
DS2;

/* An alternative (and clearer) way
creates a result like this:
   Rec 1 on node 1
   Rec 2 on node 1
   Rec 1 on node 2
   Rec 2 on node 2
   Rec 1 on node 3
   Rec 2 on node 3
*/</programlisting><!-- DNT-End -->

    <para>See Also: <link linkend="RECORD_Structure"><!-- DNT-Start -->RECORD<!-- DNT-End --> Structure</link>,
    <link linkend="TRANSFORM_Structure"><!-- DNT-Start -->TRANSFORM<!-- DNT-End --> Structure</link></para>
  </sect2>
</sect1>
