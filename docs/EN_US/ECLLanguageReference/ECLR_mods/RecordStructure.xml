<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="RECORD_Structure" role="nobrk">
  <!-- DNT-Start --><title>RECORD Structure<indexterm>
      <primary>RECORD Structure</primary>
    </indexterm></title><!-- DNT-End -->

  <para><emphasis>attr</emphasis><emphasis role="bold"> := <!-- DNT-Start -->RECORD<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->RECORD<!-- DNT-End --></primary>
    </indexterm> [ ( </emphasis><emphasis>baserec</emphasis><emphasis
  role="bold"> ) ] [, <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->MAXLENGTH<!-- DNT-End --></primary>
    </indexterm>( </emphasis><emphasis>length</emphasis><emphasis role="bold">
  ) ] [, <!-- DNT-Start -->LOCALE<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->LOCALE<!-- DNT-End --></primary>
    </indexterm>( </emphasis><emphasis>locale</emphasis><emphasis role="bold">
  ) ]</emphasis><emphasis role="bold"> [, <!-- DNT-Start -->PACKED<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->PACKED<!-- DNT-End --></primary>
    </indexterm> ]</emphasis></para>

  <para><emphasis role="bold"> </emphasis><emphasis>fields ;</emphasis></para>

  <para><emphasis role="bold"> [ <!-- DNT-Start -->IFBLOCK<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->IFBLOCK<!-- DNT-End --></primary>
    </indexterm>( </emphasis><emphasis>condition</emphasis><emphasis
  role="bold"> )</emphasis></para>

  <para><emphasis> fields ;</emphasis></para>

  <para><emphasis role="bold"> <!-- DNT-Start -->END<!-- DNT-End -->; ]</emphasis></para>

  <para><emphasis role="bold"> [ =&gt;
  </emphasis><emphasis>payload</emphasis><emphasis role="bold">
  ]</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->END<!-- DNT-End -->;<indexterm>
      <primary><!-- DNT-Start -->RECORD<!-- DNT-End --> structure</primary>
    </indexterm></emphasis></para>

  <informaltable colsep="1" frame="all" rowsep="1">
    <tgroup cols="2">
      <colspec align="left" colwidth="122.40pt" />

      <colspec />

      <tbody>
        <row>
          <entry><!-- DNT-Start --><emphasis>attr</emphasis><!-- DNT-End --></entry>

          <entry>The name of the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure for later use in other
          definitions.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>baserec</emphasis><!-- DNT-End --></entry>

          <entry>Optional. The name of a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure from which to
          inherit all fields. Any <!-- DNT-Start -->RECORD<!-- DNT-End --> structure that inherits the
          <emphasis>baserec</emphasis>fields in this manner becomes compatible
          with any <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function defined to take a parameter of
          <emphasis>baserec</emphasis> type (the extra
          <emphasis>fields</emphasis> will, of course, be lost).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">MAXLENGTH</emphasis><!-- DNT-End --></entry>

          <entry>Optional. This option is used to create indexes that are
          backward compatible for platform versions prior to 3.0. Specifies
          the maximum number of characters allowed in the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure or
          field. <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --> on the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure overrides any <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --> on
          a field definition, which overrides any <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --> specified in the
          <!-- DNT-Start -->TYPE<!-- DNT-End --> structure<indexterm>
              <primary><!-- DNT-Start -->TYPE<!-- DNT-End --> structure</primary>
            </indexterm> if the <emphasis>datatype</emphasis> names an alien
          data type. This option defines the maximum size of variable-length
          records. If omitted, fixed size records use the minimum size
          required and variable length records produce a warning. The default
          maximum size of a record containing variable-length fields is 4096
          bytes (this may be overridden by using
          <emphasis>#<!-- DNT-Start -->OPTION<!-- DNT-End -->(maxLength,####)</emphasis> to change the default).
          The maximum record size should be set as conservatively as possible,
          and is better set on a per-field basis (see the <emphasis
          role="bold">Field Modifiers </emphasis>section below).</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>length</emphasis><!-- DNT-End --></entry>

          <entry>An integer constant specifying the maximum number of
          characters allowed.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">LOCALE</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies the Unicode <emphasis>locale</emphasis>
          for any <!-- DNT-Start -->UNICODE<!-- DNT-End --> fields.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>locale</emphasis><!-- DNT-End --></entry>

          <entry>A string constant containing a valid locale code, as
          specified in <!-- DNT-Start -->ISO<!-- DNT-End --> standards 639 and 3166.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">PACKED</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Specifies the order of the
          <emphasis>fields</emphasis> may be changed to improve efficiency
          (such as moving variable-length fields after the fixed-length
          fields)..</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>fields</emphasis><!-- DNT-End --></entry>

          <entry>Field declarations. See below for the appropriate
          syntaxes.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">IFBLOCK</emphasis><!-- DNT-End --></entry>

          <entry>Optional. A block of <emphasis>fields</emphasis> that receive
          âliveâ data only if the <emphasis>condition</emphasis> is met. The
          <!-- DNT-Start -->IFBLOCK<!-- DNT-End --> must be terminated by an <emphasis
          role="bold"><!-- DNT-Start -->END<!-- DNT-End --></emphasis>. This is used to define variable-length
          records. If the <emphasis>condition</emphasis> expression references
          <emphasis>fields</emphasis> in the <!-- DNT-Start -->RECORD<!-- DNT-End --> preceding the <!-- DNT-Start -->IFBLOCK<!-- DNT-End -->,
          those references must use <!-- DNT-Start -->SELF<!-- DNT-End -->. prepended to the fieldname to
          disambiguate the reference.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>condition</emphasis><!-- DNT-End --></entry>

          <entry>A logical expression that defines when the
          <emphasis>fields</emphasis> within the <!-- DNT-Start -->IFBLOCK<!-- DNT-End --> receive âliveâ data.
          If the expression is not true, the <emphasis>fields</emphasis>
          receive their declared default values. If there's no default value,
          the <emphasis>fields</emphasis> receive blanks or zeros.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">=&gt;</emphasis><!-- DNT-End --></entry>

          <entry>Optional. The delimiter between the list of key
          <emphasis>fields</emphasis> and the <emphasis>payload</emphasis>
          when the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure is used by the <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> declaration.
          Typically, this is an inline structure using curly braces ( { } )
          instead of <!-- DNT-Start -->RECORD<!-- DNT-End --> and <!-- DNT-Start -->END<!-- DNT-End -->.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>payload</emphasis><!-- DNT-End --></entry>

          <entry>The list of non-keyed <emphasis>fields</emphasis> in the
          <!-- DNT-Start -->DICTIONARY<!-- DNT-End -->.</entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>

  <para>Record layouts are definitions whose expression is a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure
  terminated by the <!-- DNT-Start -->END<!-- DNT-End --> keyword. The <emphasis>attr</emphasis> name creates a
  user-defined value type that can be used in built-in functions and <!-- DNT-Start -->TRANSFORM<!-- DNT-End -->
  function definitions. The delimiter between field definitions in a <!-- DNT-Start -->RECORD<!-- DNT-End -->
  structure can be either the semi-colon (;) or a comma (,).</para>

  <sect2 id="In-line_Record_Definitions">
    <!-- DNT-Start --><title>In-line Record Definitions</title><!-- DNT-End -->

    <para>Curly braces ({}) are lexical equivalents to the keywords <!-- DNT-Start -->RECORD<!-- DNT-End --> and
    <!-- DNT-Start -->END<!-- DNT-End --> that can be used anywhere <!-- DNT-Start -->RECORD<!-- DNT-End --> and <!-- DNT-Start -->END<!-- DNT-End --> are appropriate. Either form
    (<!-- DNT-Start -->RECORD<!-- DNT-End -->/<!-- DNT-Start -->END<!-- DNT-End --> or {}) can be used to create âon-the-flyâ record formats
    within those functions that require record structures (<!-- DNT-Start -->OUTPUT<!-- DNT-End -->, <!-- DNT-Start -->TABLE<!-- DNT-End -->,
    <!-- DNT-Start -->DATASET<!-- DNT-End --> etc.), instead of defining the record as a separate
    definition.</para>
  </sect2>

  <sect2 id="Field_Definitions">
    <!-- DNT-Start --><title>Field Definitions</title><!-- DNT-End -->

    <!-- DNT-Start --><para>All field declarations in a RECORD Structure must use one of the
    following syntaxes:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="50pt" />

        <colspec />

        <tbody>
          <row>
            <entry></entry>

            <entry><emphasis> datatype identifier <emphasis role="bold">[
            {</emphasis><emphasis>modifier</emphasis><emphasis role="bold">}
            ]</emphasis> </emphasis><emphasis role="bold">[
            :=</emphasis><emphasis> defaultvalue</emphasis><emphasis
            role="bold">] </emphasis><emphasis role="bold">
            ;</emphasis><emphasis> </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> identifier </emphasis><emphasis role="bold"> :=
            </emphasis><emphasis>defaultvalue</emphasis><emphasis role="bold">
            ;</emphasis><emphasis> </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> defaultvalue</emphasis><emphasis role="bold">
            ;</emphasis><emphasis role="bold">
            </emphasis><emphasis></emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> sourcefield</emphasis><emphasis role="bold">
            ;</emphasis><emphasis> </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> recstruct</emphasis><emphasis role="bold"> [
            </emphasis><emphasis>identifier </emphasis><emphasis role="bold">]
            ;</emphasis><emphasis></emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> sourcedataset</emphasis><emphasis role="bold">
            ;</emphasis><emphasis> </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis> childdataset</emphasis><emphasis role="bold">
            </emphasis><emphasis> identifier </emphasis><emphasis
            role="bold">[ { </emphasis><emphasis>modifier </emphasis><emphasis
            role="bold">} ];</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis>datatype</emphasis><!-- DNT-End --></entry>

            <entry>The value type of the data field. This may be a child
            dataset (see <!-- DNT-Start -->DATASET<!-- DNT-End -->). If omitted, the value type is the result
            type of the <emphasis>defaultvalue</emphasis> expression.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>identifier</emphasis><!-- DNT-End --></entry>

            <entry>The name of the field. If omitted, the
            <emphasis>defaultvalue</emphasis> expression defines a column with
            no name that may not be referenced in subsequent <!-- DNT-Start -->ECL<!-- DNT-End -->.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>defaultvalue</emphasis><!-- DNT-End --></entry>

            <entry>Optional. An expression defining the source of the data
            (for operations that require a data source, such as <!-- DNT-Start -->TABLE<!-- DNT-End --> and
            <!-- DNT-Start -->PARSE<!-- DNT-End -->). This may be a constant, expression, or definition
            providing the value.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>modifier</emphasis><!-- DNT-End --></entry>

            <entry>Optional. One of the keywords listed in the <emphasis
            role="bold">Field Modifiers</emphasis>section below.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>sourcefield</emphasis><!-- DNT-End --></entry>

            <entry>A previously defined data field, which implicitly provides
            the <emphasis>datatype</emphasis>,
            <emphasis>identifier</emphasis>, and
            <emphasis>defaultvalue</emphasis> for the new fieldâinherited from
            the <emphasis>sourcefield</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>recstruct</emphasis><!-- DNT-End --></entry>

            <entry>A previously defined <!-- DNT-Start -->RECORD<!-- DNT-End --> structure. See the <emphasis
            role="bold">Field Inheritance</emphasis>section below.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>sourcedataset</emphasis><!-- DNT-End --></entry>

            <entry>A previously defined <!-- DNT-Start -->DATASET<!-- DNT-End --> or derived recordset
            definition. See the <emphasis role="bold">Field
            Inheritance</emphasis>section below.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>childdataset</emphasis><!-- DNT-End --></entry>

            <entry>A child dataset declaration (see <!-- DNT-Start -->DATASET<!-- DNT-End --> and <!-- DNT-Start -->DICTIONARY<!-- DNT-End -->
            discussions), which implicitly defines all the fields of the child
            at their already defined <emphasis>datatype</emphasis>,
            <emphasis>identifier</emphasis>, and
            <emphasis>defaultvalue</emphasis> (if present in the child
            dataset's <!-- DNT-Start -->RECORD<!-- DNT-End --> structure).</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Field definitions must always define the
    <emphasis>datatype</emphasis> and <emphasis>identifier</emphasis> of each
    field, either implicitly or explicitly. If the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure will be
    used by <!-- DNT-Start -->TABLE<!-- DNT-End -->, <!-- DNT-Start -->PARSE<!-- DNT-End -->, <!-- DNT-Start -->ROW<!-- DNT-End -->, or any other function that creates an output
    recordset, then the <emphasis>defaultvalue</emphasis> must also be
    implicitly or explicitly defined for each field. In the case where a field
    is defined in terms of a field in a dataset already in scope, you may name
    the <emphasis>identifier</emphasis> with a name already in use in the
    dataset already in scope as long as you explicitly define the
    <emphasis>datatype</emphasis>.</para>
  </sect2>

  <sect2 id="Field_Inheritance">
    <!-- DNT-Start --><title>Field Inheritance</title><!-- DNT-End -->

    <para>Field definitions may be inherited from a previously defined <!-- DNT-Start -->RECORD<!-- DNT-End -->
    structure or <!-- DNT-Start -->DATASET<!-- DNT-End -->. When a <emphasis>recstruct</emphasis> (a <!-- DNT-Start -->RECORD<!-- DNT-End -->
    Structure) is specified from which to inherit the fields, the new fields
    are implicitly defined using the <emphasis>datatype</emphasis> and
    <emphasis>identifier</emphasis> of all the existing field definitions in
    the <emphasis>recstruct</emphasis>. When a <emphasis>sourcedataset
    </emphasis>(a previously defined <!-- DNT-Start -->DATASET<!-- DNT-End --> or recordset definition) is
    specified to inherit the fields, the new fields are implicitly defined
    using the <emphasis>datatype</emphasis>, <emphasis>identifier</emphasis>,
    and <emphasis>defaultvalue</emphasis> of all the fields (making it usable
    by operations that require a data source, such as <!-- DNT-Start -->TABLE<!-- DNT-End --> and <!-- DNT-Start -->PARSE<!-- DNT-End -->). Either
    of these forms may optionally have its own <emphasis>identifier</emphasis>
    to allow reference to the entire set of inherited fields as a single
    entity.</para>

    <para>You may also use logical operators<indexterm>
        <primary>logical operators</primary>
      </indexterm> (<!-- DNT-Start -->AND<!-- DNT-End -->, <!-- DNT-Start -->OR<!-- DNT-End -->, and <!-- DNT-Start -->NOT<!-- DNT-End -->) to include/exclude certain fields from
    the inheritance, as described here:</para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="3">
        <colspec align="left" colwidth="122.40pt" />

        <colspec colwidth="122" />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis>R1</emphasis> <emphasis role="bold">AND<indexterm>
                <primary>AND</primary>
              </indexterm></emphasis> <emphasis>R2</emphasis><!-- DNT-End --></entry>

            <entry>Intersection</entry>

            <entry>All fields declared in both <emphasis>R1</emphasis> and
            <emphasis>R2</emphasis></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>R1</emphasis> <emphasis
            role="bold">OR</emphasis><indexterm>
                <primary>OR</primary>
              </indexterm> <emphasis>R2</emphasis><!-- DNT-End --></entry>

            <entry>Union</entry>

            <entry>All fields declared in either <emphasis>R1</emphasis> or
            <emphasis>R2</emphasis></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>R1</emphasis> <emphasis role="bold">AND
            NOT<indexterm>
                <primary>AND NOT</primary>
              </indexterm></emphasis> <emphasis>R2</emphasis><!-- DNT-End --></entry>

            <entry>Difference</entry>

            <entry>All fields in <emphasis>R1</emphasis> that are not in
            <emphasis>R2</emphasis></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>R1</emphasis> <emphasis role="bold">AND
            NOT</emphasis> <emphasis>F1</emphasis><!-- DNT-End --></entry>

            <entry>Exception</entry>

            <entry>All fields in <emphasis>R1</emphasis> except the specified
            field (<emphasis>F1</emphasis>)</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>R1</emphasis> <emphasis role="bold">AND
            NOT</emphasis> <emphasis role="bold">[</emphasis><emphasis>F1,
            F2</emphasis><emphasis role="bold">]</emphasis><!-- DNT-End --></entry>

            <entry>Exception</entry>

            <entry>All fields in <emphasis>R1</emphasis> except those in
            listed in the brackets
            (<emphasis>F1</emphasis>and<emphasis>F2</emphasis>)</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>The minus sign (-) is a synonym for <!-- DNT-Start -->AND<!-- DNT-End --> <!-- DNT-Start -->NOT<!-- DNT-End -->, so R1-R2 is equivalent
    to R1 <!-- DNT-Start -->AND<!-- DNT-End --> <!-- DNT-Start -->NOT<!-- DNT-End --> R2.</para>

    <para>It is an error if the records contain the same field names whose
    value types don't match, or if you end up with no fields (such as: A-A).
    You must ensure that any <!-- DNT-Start -->MAXLENGTH<!-- DNT-End -->/<!-- DNT-Start -->MAXCOUNT<!-- DNT-End --> is specified correctly on each
    field in both <!-- DNT-Start -->RECORD<!-- DNT-End --> Structures.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <!-- DNT-Start --><programlisting>R1 := {STRING1 F1,STRING1 F2,STRING1 F3,STRING1 F4,STRING1 F5};
R2 := {STRING1 F4,STRING1 F5,STRING1 F6};
R3 := {R1 AND R2}; //Intersection - fields F4 and F5  only
R4 := {R1 OR R2}; //Union - all fields F1 - F6
R5 := {R1 AND NOT R2}; //Difference - fields F1 - F3
R6 := {R1 AND NOT F1}; //Exception - fields F2 - F5
R7 := {R1 AND NOT [F1,F2]}; //Exception - fields F3 - F5

//the following two RECORD structures are equivalent:
C := RECORD,MAXLENGTH(x)
  R1 OR R2;
END;
         
D := RECORD, MAXLENGTH(x)
  R1;
  R2 AND NOT R1;
END;</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="Field_Modifiers">
    <!-- DNT-Start --><title>Field Modifiers</title><!-- DNT-End -->

    <!-- DNT-Start --><para>The following list of field modifiers are available for use on field
    definitions:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="50pt" />

        <colspec />

        <tbody>
          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->MAXLENGTH<!-- DNT-End --></primary>
              </indexterm>( </emphasis><emphasis>length</emphasis><emphasis
            role="bold"> ) }</emphasis><emphasis role="bold">
            </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->MAXCOUNT<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->MAXCOUNT<!-- DNT-End --></primary>
              </indexterm>( </emphasis><emphasis>records</emphasis><emphasis
            role="bold"> ) }</emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->XPATH<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->XPATH<!-- DNT-End --></primary>
              </indexterm>(</emphasis><emphasis role="bold">
            </emphasis><emphasis
            role="bold">'</emphasis><emphasis>tag</emphasis><emphasis
            role="bold">' ) }</emphasis><emphasis role="bold">
            </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->XMLDEFAULT<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->XMLDEFAULT<!-- DNT-End --></primary>
              </indexterm>(</emphasis> <emphasis
            role="bold">'</emphasis><emphasis>value</emphasis><emphasis
            role="bold">' ) }</emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->DEFAULT<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->DEFAULT<!-- DNT-End --></primary>
              </indexterm>(</emphasis> <emphasis>value</emphasis><emphasis
            role="bold"> ) }</emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->VIRTUAL<!-- DNT-End --><indexterm>
                <primary>Virtual</primary>
              </indexterm><indexterm>
                <primary>Virtual fileposition</primary>
              </indexterm>(</emphasis><emphasis role="bold">
            </emphasis><emphasis role="bold">fileposition )
            }</emphasis><emphasis role="bold"> </emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->VIRTUAL<!-- DNT-End --><indexterm>
                <primary>Virtual localfileposition</primary>
              </indexterm>( localfileposition ) }</emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->VIRTUAL<!-- DNT-End --><indexterm>
                <primary>Virtual logicalfilename</primary>
              </indexterm>( logicalfilename ) }</emphasis></entry>
          </row>

          <row>
            <entry></entry>

            <entry><emphasis role="bold"> { <!-- DNT-Start -->BLOB<!-- DNT-End --><indexterm>
                <primary><!-- DNT-Start -->BLOB<!-- DNT-End --> in <!-- DNT-Start -->INDEX<!-- DNT-End --></primary>
              </indexterm> }</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="200pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{
            MAXLENGTH(</emphasis><emphasis>length</emphasis> <emphasis
            role="bold">) }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the maximum number of characters allowed in the
            field (see <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --> option above).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{
            MAXCOUNT(</emphasis><emphasis>records</emphasis> <emphasis
            role="bold">) }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the maximum number of
            <emphasis>records</emphasis> allowed in a child <!-- DNT-Start -->DATASET<!-- DNT-End --> field
            (similar to <!-- DNT-Start -->MAXLENGTH<!-- DNT-End --> above).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{
            XPATH(</emphasis>'<emphasis>tag</emphasis>'<emphasis role="bold">)
            }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <!-- DNT-Start -->XML<!-- DNT-End --> or <!-- DNT-Start -->JSON<!-- DNT-End --> <emphasis>tag</emphasis> that
            contains the data, in a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure that defines <!-- DNT-Start -->XML<!-- DNT-End --> or <!-- DNT-Start -->JSON<!-- DNT-End -->
            data. This overrides the default <emphasis>tag</emphasis> name
            (the lowercase field <emphasis>identifier</emphasis>). See the
            <emphasis role="bold"><!-- DNT-Start -->XPATH<!-- DNT-End --> Support</emphasis> section below for
            details.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{
            XMLDEFAULT(</emphasis>'<emphasis>value</emphasis>'<emphasis
            role="bold">) }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies a default <!-- DNT-Start -->XML<!-- DNT-End --> <emphasis>value</emphasis> for the
            field. The <emphasis>value</emphasis> must be constant.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{ DEFAULT(</emphasis><emphasis>
            value</emphasis> <emphasis role="bold">) }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies a default <emphasis>value</emphasis> for the
            field. The <emphasis>value</emphasis> must be constant. This
            <emphasis>value</emphasis> will be used: <para>1. When a
            <!-- DNT-Start -->DICTIONARY<!-- DNT-End --> lookup returns no match.</para><para>2. When an
            out-of-range record is fetched using ds[n] (as in ds[5] when ds
            contains only 4 records). </para><para>3. In the default records
            passed to <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> functions in non-<!-- DNT-Start -->INNER<!-- DNT-End --> <!-- DNT-Start -->JOINS<!-- DNT-End --> where there is no
            corresponding row. </para><para>4. When defaulting field values in
            a <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> using <!-- DNT-Start -->SELF<!-- DNT-End --> = [ ].</para></entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><para><emphasis role="bold">{ VIRTUAL( fileposition )
            }</emphasis></para><!-- DNT-End --></entry>

            <entry>Specifies the field is a <!-- DNT-Start -->VIRTUAL<!-- DNT-End --> field containing the
            relative byte position of the record within the entire file (the
            record pointer). This must be an <!-- DNT-Start -->UNSIGNED<!-- DNT-End -->8 field and must be the
            last field, because it only truly exists when the file is loaded
            into memory from disk (hence, the âvirtualâ).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{ VIRTUAL( localfileposition )
            }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the local byte position within a part of the
            distributed file on a single node: the first bit is set, the next
            15 bits specify the part number, and the last 48 bits specify the
            relative byte position within the part. This must be an <!-- DNT-Start -->UNSIGNED<!-- DNT-End -->8
            field and must be the last field, because it only truly exists
            when the file is loaded into memory from disk (hence, the
            âvirtualâ).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{ VIRTUAL( logicalfilename )
            }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the logical file name of the distributed file.
            This must be a <!-- DNT-Start -->STRING<!-- DNT-End --> field. If reading from a superfile, the
            value is the current logical file within the superfile.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">{ BLOB }</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the field is stored separately from the leaf node
            entry in the <!-- DNT-Start -->INDEX<!-- DNT-End -->. This is applicable specifically to fields in
            the payload of an <!-- DNT-Start -->INDEX<!-- DNT-End --> to allow more than 32K of data per index
            entry. The <!-- DNT-Start -->BLOB<!-- DNT-End --> data is stored within the index file, but not with
            the rest of the record. Accessing the <!-- DNT-Start -->BLOB<!-- DNT-End --> data requires an
            additional seek.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </sect2>

  <sect2 id="XPATH_Support">
    <!-- DNT-Start --><title>XPATH Support</title><!-- DNT-End -->

    <para><!-- DNT-Start -->XPATH<!-- DNT-End --> support<indexterm>
        <primary><!-- DNT-Start -->XPATH<!-- DNT-End --> support</primary>
      </indexterm> is a limited subset of the full <!-- DNT-Start -->XPATH<!-- DNT-End --> specification,
    basically expressed as:</para>

    <para><emphasis role="bold">node[qualifier] / node[qualifier]
    ...</emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec align="left" colwidth="122.40pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis>node </emphasis><!-- DNT-End --></entry>

            <entry>Can contain wildcards.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>qualifier </emphasis><!-- DNT-End --></entry>

            <entry>Can be a node or attribute, or a simple single expression
            of equality, inequality, or numeric or alphanumeric comparisons,
            or node index values. No functions or inline arithmetic, etc. are
            supported. String comparison is indicated when the right hand side
            of the expression is quoted.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>These operators are valid for comparisons:</para>

    <!-- DNT-Start --><programlisting>&lt;, &lt;=, &gt;, &gt;=, =, !=</programlisting><!-- DNT-End -->

    <para>An example of a supported xpath:</para>

    <!-- DNT-Start --><programlisting>/a/*/c*/*d/e[@attr]/f[child]/g[@attr="x"]/h[child&gt;="5"]/i[@x!="2"]/j</programlisting><!-- DNT-End -->

    <para>You can emulate <!-- DNT-Start -->AND<!-- DNT-End --> conditions like this:</para>

    <!-- DNT-Start --><programlisting>/a/b[@x="1"][@y="2"]</programlisting><!-- DNT-End -->

    <para>Also, there is a non-standard <!-- DNT-Start -->XPATH<!-- DNT-End --> convention for extracting the
    text of a match using empty angle brackets (&lt;&gt;):</para>

    <!-- DNT-Start --><programlisting>R := RECORD
STRING blah{xpath('a/b&lt;&gt;')};
//contains all of b, including any child definitions and values
END;</programlisting><!-- DNT-End -->

    <para>An <!-- DNT-Start -->XPATH<!-- DNT-End --> for a value cannot be ambiguous. If the element occurs
    multiple times, you must use the ordinal operation (for example,
    /foo[1]/bar) to explicit select the first occurrence.</para>

    <para>For <!-- DNT-Start -->XML<!-- DNT-End --> or <!-- DNT-Start -->JSON<!-- DNT-End --> <!-- DNT-Start -->DATASETs<!-- DNT-End --> reading and processing results of the
    <!-- DNT-Start -->SOAPCALL<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SOAPCALL<!-- DNT-End --></primary>
      </indexterm> function, the following <!-- DNT-Start -->XPATH<!-- DNT-End --> syntax is specifically
    supported:</para>

    <para>1) For simple scalar value fields, if there is an <!-- DNT-Start -->XPATH<!-- DNT-End --> specified
    then it is used, otherwise the lower case <emphasis>identifier</emphasis>
    of the field is used.</para>

    <!-- DNT-Start --><programlisting>STRING name;                  //matches: &lt;name&gt;Kevin&lt;/name&gt;
STRING Fname{xpath('Fname')}; //matches: &lt;Fname&gt;Kevin&lt;/Fname&gt;</programlisting><!-- DNT-End -->

    <para>2) For a field whose type is a <!-- DNT-Start -->RECORD<!-- DNT-End --> structure, the specified <!-- DNT-Start -->XPATH<!-- DNT-End -->
    is prefixed to all the fields it contains, otherwise the lower case
    <emphasis>identifier</emphasis> of the field followed by '/' is prefixed
    onto the fields it contains. Note that an <!-- DNT-Start -->XPATH<!-- DNT-End --> of '' (empty single
    quotes) will prefix nothing.</para>

    <!-- DNT-Start --><programlisting>NameRec := RECORD
  STRING Fname{xpath('Fname')}; //matches: &lt;Fname&gt;Kevin&lt;/Fname&gt;
  STRING Mname{xpath('Mname')}; //matches: &lt;Mname&gt;Alfonso&lt;/Mname&gt;
  STRING Lname{xpath('Lname')}; //matches: &lt;Lname&gt;Jones&lt;/Lname&gt;
END;
          
PersonRec := RECORD
  STRING Uid{xpath('Person[@UID]')};
  NameRec Name{xpath('Name')};
    /*matches: &lt;Name&gt;
              &lt;Fname&gt;Kevin&lt;/Fname&gt;
              &lt;Mname&gt;Alfonso&lt;/Mname&gt;
              &lt;Lname&gt;Jones&lt;/Lname&gt;
              &lt;/Name&gt; */
END;</programlisting><!-- DNT-End -->

    <para>3) For a child <!-- DNT-Start -->DATASET<!-- DNT-End --> field, the specified <!-- DNT-Start -->XPATH<!-- DNT-End --> can have one of
    two formats: "Container/Repeated" or "/Repeated." Each "/Repeated" tag
    within the optional Container is iterated to provide the values. If no
    <!-- DNT-Start -->XPATH<!-- DNT-End --> is specified, then the default value for the Container is the lower
    case field name, and the default value for Repeated is "Row." For example,
    this demonstrates "Container/Repeated":</para>

    <!-- DNT-Start --><programlisting>DATASET(PeopleNames) People{xpath('people/name'])};
          /*matches: &lt;people&gt;
                        &lt;name&gt;Gavin&lt;/name&gt;
                        &lt;name&gt;Ricardo&lt;/name&gt;
                    &lt;/people&gt; */</programlisting><!-- DNT-End -->

    <para>This demonstrates "/Repeated":</para>

    <!-- DNT-Start --><programlisting>DATASET(Names) Names{xpath('/name'])};
          /*matches: &lt;name&gt;Gavin&lt;/name&gt;
                     &lt;name&gt;Ricardo&lt;/name&gt; */</programlisting><!-- DNT-End -->

    <para>"Container" and "Repeated" may also contain xpath filters, like
    this:</para>

    <!-- DNT-Start --><programlisting>DATASET(doctorRec) doctors{xpath('person[@job=\'doctor\']')};
          /*matches: &lt;person job='doctor'&gt;
                       &lt;FName&gt;Kevin&lt;/FName&gt;
                       &lt;LName&gt;Richards&lt;/LName&gt;
                     &lt;/person&gt; */</programlisting><!-- DNT-End -->

    <para>4) For a <!-- DNT-Start -->SET<!-- DNT-End --> <!-- DNT-Start -->OF<!-- DNT-End --> <emphasis>type</emphasis> field, an xpath on a set
    field can have one of three formats: "Repeated", "Container/Repeated" or
    "Container/Repeated/@attr". They are processed in a similar way to
    datasets, except for the following. If Container is specified, then the
    <!-- DNT-Start -->XML<!-- DNT-End --> reading checks for a tag "Container/All", and if present the set
    contains all possible values. The third form allows you to read <!-- DNT-Start -->XML<!-- DNT-End -->
    attribute values.</para>

    <!-- DNT-Start --><programlisting>SET OF STRING people;
    //matches: &lt;people&gt;&lt;All/&gt;&lt;/people&gt;
    //or: &lt;people&gt;&lt;Item&gt;Kevin&lt;/Item&gt;&lt;Item&gt;Richard&lt;/Item&gt;&lt;/people&gt;
         
SET OF STRING Npeople{xpath('Name')};
    //matches: &lt;Name&gt;Kevin&lt;/Name&gt;&lt;Name&gt;Richard&lt;/Name&gt;
SET OF STRING Xpeople{xpath('/Name/@id')};
    //matches: &lt;Name id='Kevin'/&gt;&lt;Name id='Richard'/&gt;</programlisting><!-- DNT-End -->

    <para>For writing <!-- DNT-Start -->XML<!-- DNT-End --> or <!-- DNT-Start -->JSON<!-- DNT-End --> files using <!-- DNT-Start -->OUTPUT<!-- DNT-End -->, the rules are similar
    with the following exceptions:</para>

    <itemizedlist>
      <listitem>
        <para>For scalar fields, simple tag names and <!-- DNT-Start -->XML<!-- DNT-End -->/<!-- DNT-Start -->JSON<!-- DNT-End --> attributes are
        supported.</para>
      </listitem>

      <listitem>
        <para>For <!-- DNT-Start -->SET<!-- DNT-End --> fields, &lt;All&gt; will only be generated if the
        container name is specified.</para>
      </listitem>

      <listitem>
        <para>xpath filters are not supported.</para>
      </listitem>

      <listitem>
        <para>The "Container/Repeated/@attr" form for a <!-- DNT-Start -->SET<!-- DNT-End --> is not
        supported.</para>
      </listitem>
    </itemizedlist>

    <para><emphasis role="bold">Example:</emphasis></para>

    <para>For <!-- DNT-Start -->DATASET<!-- DNT-End --> or the result type of a <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function, you need
    only specify the value type and name of each field in the layout:</para>

    <!-- DNT-Start --><programlisting>R1 := RECORD
  UNSIGNED1 F1; //only value type and name required
  UNSIGNED4 F2;
  STRING100 F3;
END;
          
D1 := DATASET('RTTEMP::SomeFile',R1,THOR);

      
</programlisting><!-- DNT-End -->

    <para>For "vertical slice" <!-- DNT-Start -->TABLE<!-- DNT-End -->, you need to specify the value type,
    name, and data source for each field in the layout:</para>

    <!-- DNT-Start --><programlisting>R2 := RECORD
  UNSIGNED1 F1 := D1.F1; //value type, name, data source all explicit
  D1.F2; //value type, name, data source all implicit
END;

T1 := TABLE(D1,R2);</programlisting><!-- DNT-End -->

    <para>For "crosstab report" <!-- DNT-Start -->TABLE<!-- DNT-End -->:</para>

    <!-- DNT-Start --><programlisting>R3 := RECORD
  D1.F1;            //"group by" fields must come first 
  UNSIGNED4 GrpCount := COUNT(GROUP); 
                   //value type, column name, and aggregate
  GrpSum := SUM(GROUP,D1.F2); //no value type -- defaults to INTEGER
  MAX(GROUP,D1.F2); //no column name in output
END;

T2 := TABLE(D1,R3,F1);
</programlisting><!-- DNT-End -->

    <para></para>

    <!-- DNT-Start --><programlisting>Form1 := RECORD
    Person.per_last_name; //field name is per_last_name - size
                         //is as declared in the person dataset
    STRING25 LocalID := Person.per_first_name;
                        //the name of this field is LocalID and it
                        //gets its data from Person.per_first_name
    INTEGER8 COUNT(Trades); //this field is unnamed in the output file
    BOOLEAN HasBogey := FALSE; 
                        //HasBogey defaults to false
    REAL4    Valu8024;
          //value from the Valu8024 definition
END;
Form2 := RECORD
     Trades; //include all fields from the Trades dataset at their
            // already-defined names, types and sizes
     UNSIGNED8 fpos {VIRTUAL(fileposition)};
           //contains the relative byte position within the file
END;

Form3 := {Trades,UNSIGNED8 local_fpos {VIRTUAL(localfileposition)}};
          //use of {} instead of RECORD/END
          //âTradesâ includes all fields from the dataset at their
          // already-defined names, types and sizes
          //local_fpos is the relative byte position in each part

Form4 := RECORD, MAXLENGTH(10000)
     STRING VarStringName1{MAXLENGTH(5000)};
          //this field is variable size to a 5000 byte maximum
 
     STRING VarStringName2{MAXLENGTH(4000)};
          //this field is variable size to a 4000 byte maximum

     IFBLOCK(MyCondition = TRUE) //following fields receive values
          //only if MyCondition = TRUE

     BOOLEAN HasLife := TRUE;
          //defaults to true unless MyCondition = FALSE

     INTEGER8 COUNT(Inquiries); 
          //this field is zero if MyCondition = FALSE, even
          //if there are inquiries to count

      END;
END;
</programlisting><!-- DNT-End -->

    <para>in-line record structures, demonstrating same field name use</para>

    <!-- DNT-Start --><programlisting>ds := DATASET('d', { STRING s; }, THOR);
t := TABLE(ds, { STRING60 s := ds.s; });
    // new âsâ field is OK with value type explicitly defined
</programlisting><!-- DNT-End -->

    <para>âChild datasetâ <!-- DNT-Start -->RECORD<!-- DNT-End --> structures</para>

    <!-- DNT-Start --><programlisting>ChildRec := RECORD
    UNSIGNED4 person_id;
    STRING20 per_surname;
    STRING20 per_forename;
END;
ParentRecord := RECORD
    UNSIGNED8 id;
    STRING20 address;
    STRING20 CSZ;
    STRING10 postcode;
    UNSIGNED2 numKids;
    DATASET(ChildRec) children{MAXCOUNT(100)};
END;
</programlisting><!-- DNT-End -->

    <para>an example using {<!-- DNT-Start -->XPATH<!-- DNT-End -->('tag')}</para>

    <!-- DNT-Start --><programlisting>R := record
     STRING10 fname;
     STRING12 lname;
     SET OF STRING1 MySet{XPATH('Set/Element')}; //define set tags
END;
B := DATASET([{'Fred','Bell',['A','B']},
            {'George','Blanda',['C','D']},
            {'Sam','',['E','F'] } ], R);
         
OUTPUT(B,,'~RTTEST::test.xml', XML);

/* this example produces XML output that looks like this:
&lt;Dataset&gt;
&lt;Row&gt;&lt;fname&gt;Fred &lt;/fname&gt;&lt;lname&gt;Bell&lt;/lname&gt;
 &lt;Set&gt;&lt;Element&gt;A&lt;/Element&gt;&lt;Element&gt;B&lt;/Element&gt;&lt;/Set&gt;&lt;/Row&gt;
&lt;Row&gt;&lt;fname&gt;George&lt;/fname&gt;&lt;lname&gt;Blanda &lt;/lname&gt;
 &lt;Set&gt;&lt;Element&gt;C&lt;/Element&gt;&lt;Element&gt;D&lt;/Element&gt;&lt;/Set&gt;&lt;/Row&gt;
&lt;Row&gt;&lt;fname&gt;Sam &lt;/fname&gt;&lt;lname&gt; &lt;/lname&gt;
&lt;Set&gt;&lt;Element&gt;E&lt;/Element&gt;&lt;Element&gt;F&lt;/Element&gt;&lt;/Set&gt;&lt;/Row&gt;
&lt;/Dataset&gt;
*/
</programlisting><!-- DNT-End -->

    <para>another <!-- DNT-Start -->XML<!-- DNT-End --> example with a 1-field child dataset</para>

    <!-- DNT-Start --><programlisting>cr := RECORD,MAXLENGTH(1024)
  STRING phoneEx{XPATH('')};
END;
r := RECORD,MAXLENGTH(4096)
  STRING id{XPATH('COMP-ID')};
  STRING phone{XPATH('PHONE-NUMBER')};
  DATASET(cr) Fred{XPATH('PHONE-NUMBER-EXP')};
END;
         
DS := DATASET([{'1002','1352,9493',['1352','9493']},
            {'1003','4846,4582,0779',['4846','4582','0779']}],r);

OUTPUT(ds,,'~RTTEST::XMLtest2',
      XML('RECORD',
          HEADING('&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;RECORDS&gt;',
                  '&lt;/RECORDS&gt;')));
 
/* this example produces XML output that looks like  this:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;RECORDS&gt;
      &lt;RECORD&gt;
         &lt;COMP-ID&gt;1002&lt;/COMP-ID&gt;
          &lt;PHONE-NUMBER&gt;1352,9493&lt;/PHONE-NUMBER&gt;
          &lt;PHONE-NUMBER-EXP&gt;1352&lt;/PHONE-NUMBER-EXP&gt;
          &lt;PHONE-NUMBER-EXP&gt;9493&lt;/PHONE-NUMBER-EXP&gt;
       &lt;/RECORD&gt;
       &lt;RECORD&gt;
         &lt;COMP-ID&gt;1003&lt;/COMP-ID&gt;
          &lt;PHONE-NUMBER&gt;4846,4582,0779&lt;/PHONE-NUMBER&gt;
          &lt;PHONE-NUMBER-EXP&gt;4846&lt;/PHONE-NUMBER-EXP&gt;
          &lt;PHONE-NUMBER-EXP&gt;4582&lt;/PHONE-NUMBER-EXP&gt;
          &lt;PHONE-NUMBER-EXP&gt;0779&lt;/PHONE-NUMBER-EXP&gt;
       &lt;/RECORD&gt;
     &lt;/RECORDS&gt;
 */</programlisting><!-- DNT-End -->

    <para><!-- DNT-Start -->XPATH<!-- DNT-End --> can also be used to define a <!-- DNT-Start -->JSON<!-- DNT-End --> file</para>

    <!-- DNT-Start --><programlisting>/* a JSON  file called "MyBooks.json" contains this data:
[
  {
    "id" : "978-0641723445",
    "name" : "The Lightning Thief",
    "author" : "Rick Riordan"
  }
,
  {
    "id" : "978-1423103349",
    "name" : "The Sea of Monsters",
    "author" : "Rick Riordan"
  }
]
*/

BookRec := RECORD
  STRING ID {XPATH('id')}; //data from id tag -- renames field to uppercase
  STRING title {XPATH('name')}; //data from name tag, renaming the field
  STRING author; //data from author tag, tag name is lowercase and matches field name  
END;

books := DATASET('~jd::mybooks.json',BookRec,JSON('/'));
OUTPUT(books);</programlisting><!-- DNT-End -->

    <para>See Also: <link linkend="DATASET"><!-- DNT-Start -->DATASET<!-- DNT-End --></link>, <link
    linkend="DICTIONARY"><!-- DNT-Start -->DICTIONARY<!-- DNT-End --></link>, <link
    linkend="INDEX_record_structure"><!-- DNT-Start -->INDEX<!-- DNT-End --></link>, <link
    linkend="OUTPUT"><!-- DNT-Start -->OUTPUT<!-- DNT-End --></link>, <link linkend="TABLE"><!-- DNT-Start -->TABLE<!-- DNT-End --></link>, <link
    linkend="TRANSFORM_Structure"><!-- DNT-Start -->TRANSFORM<!-- DNT-End --> Structure</link>, <link
    linkend="TYPE_Structure"><!-- DNT-Start -->TYPE<!-- DNT-End --> Structure</link>, <link
    linkend="SOAPCALL"><!-- DNT-Start -->SOAPCALL<!-- DNT-End --></link></para>
  </sect2>
</sect1>
