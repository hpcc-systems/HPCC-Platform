<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="_OPTION">
  <title>#OPTION</title>

  <para><emphasis role="bold">#OPTION<indexterm>
      <primary>#OPTION</primary>
    </indexterm>( </emphasis><emphasis> option, value </emphasis><emphasis
  role="bold">);</emphasis></para>

  <para><informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="75.80pt"/>

        <colspec/>

        <tbody>
          <row>
            <entry><emphasis>option</emphasis></entry>

            <entry>A case sensitive string constant containing the name of the
            option to set.</entry>
          </row>

          <row>
            <entry><emphasis>value</emphasis></entry>

            <entry>The value to set the option to. This may be any type of
            value, dependent on what the option expects to be.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable></para>

  <para>The <emphasis role="bold">#OPTION </emphasis>statement is typically a
  compiler directive giving hints to the code generator as to how best to
  generate the executable code for a workunit. This statement may be used
  outside an XML scope and does not require a previous call to the LOADXML
  function to instantiate an XML scope.</para>

  <sect2 id="Definition_of_Terms">
    <title>Definition of Terms</title>

    <para>These definitions are "internal-only" terms used in the
    <emphasis>option</emphasis> definitions that follow.</para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="2">
          <colspec colwidth="78.10pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>DFA</emphasis></entry>

              <entry>Deterministic Finite-state Automaton.</entry>
            </row>

            <row>
              <entry><emphasis>Fold</emphasis></entry>

              <entry>To turn a complex expression into a simpler equivalent
              one. For example, the expression "1+1" can be replaced with "2"
              without altering the result.</entry>
            </row>

            <row>
              <entry><emphasis>Spill</emphasis></entry>

              <entry>Writing intermediate result sets to disk so that memory
              is available for subsequent steps.</entry>
            </row>

            <row>
              <entry><emphasis>Funnel</emphasis></entry>

              <entry>The + (append file) operator between datasets can be
              visualized as pouring all the records into a funnel and getting
              a single stream of records out of the bottom; hence the term
              "funnel."</entry>
            </row>

            <row>
              <entry><emphasis>TopN</emphasis></entry>

              <entry>An internally generated activity used in place of
              CHOOSEN(SORT(xx), n) where n is small, as it can be computed
              much more efficiently than sorting the entire record set then
              discarding all but the first n.</entry>
            </row>

            <row>
              <entry><emphasis>Activity</emphasis></entry>

              <entry>An ECL operator that takes one or more datasets as
              inputs.</entry>
            </row>

            <row>
              <entry><emphasis>Graph</emphasis></entry>

              <entry>All the Activities in a query.</entry>
            </row>

            <row>
              <entry><emphasis>Subgraph</emphasis></entry>

              <entry>A collection of Activities that can all be active at the
              same time in Thor.</entry>
            </row>

            <row>
              <entry><emphasis>Peephole</emphasis></entry>

              <entry>A method of code optimization that looks at a small
              amount of the unoptimized code at a time, in order to combine
              operations into more efficient ones.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>
  </sect2>

  <sect2 id="OPTION_Available_Options">
    <title>Available options</title>

    <para><emphasis role="bold">The following options are generally useful:
    </emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="3">
          <colspec colwidth="178.45pt"/>

          <colspec colwidth="65.60pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>maxRunTime</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Sets the maximum number of seconds a job runs before it
              times out</entry>
            </row>

            <row>
              <entry><emphasis>freezePersists</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, does not calculate/recalculate PERSISTed</entry>
            </row>

            <row>
              <entry><emphasis>expirePersists</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, PERSISTs expire after the specified period. This
              is set in the Sasha configuration setting (PersistExpiryDefault)
              or using #option ('defaultPersistExpiry', n) where n is the
              number of days.</entry>
            </row>

            <row>
              <entry><emphasis>defaultPersistExpiry</emphasis></entry>

              <entry>Default: none</entry>

              <entry>If set, PERSISTs expire after the number of days
              specified (overriding the Sasha PersistExpiryDefault
              setting).</entry>
            </row>

            <row>
              <entry><emphasis>multiplePersistInstances</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, multiple PERSISTs are the default.</entry>
            </row>

            <row>
              <entry><emphasis>defaultNumPersistInstances</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specifies the default number of PERSISTs. A value of -1
              specifies that all copies should be kept until they expire or
              manually deleted.</entry>
            </row>

            <row>
              <entry><emphasis>check</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, check for potential overflows of
              records.</entry>
            </row>

            <row>
              <entry><emphasis>expandRepeatAnyAsDfa</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, expand ANY* in a DFA.</entry>
            </row>

            <row>
              <entry><emphasis>forceFakeThor</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, force code to use hthor.</entry>
            </row>

            <row>
              <entry><emphasis>forceGenerate</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, force .SO to be generated even if it's not worth
              it</entry>
            </row>

            <row>
              <entry><emphasis>globalFold</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, perform a global constant fold before
              generating.</entry>
            </row>

            <row>
              <entry><emphasis>globalOptimize</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, perform a global optimize.</entry>
            </row>

            <row>
              <entry><emphasis>groupAllDistribute</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, GROUP,ALL generates a DISTRIBUTE instead of a
              global SORT.</entry>
            </row>

            <row>
              <entry><emphasis>maximizeLexer</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, maximize the amount of work done in the
              lexer.</entry>
            </row>

            <row>
              <entry><emphasis>maxLength</emphasis></entry>

              <entry>Default: 4096</entry>

              <entry>Specify maximum length of a record.</entry>
            </row>

            <row>
              <entry><emphasis>minimizeSpillSize</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, if a spill is filtered/deduped etc when read,
              reduce spill file size by splitting, filtering and then
              writing.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeGraph</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, optimize expressions in a graph before
              generation</entry>
            </row>

            <row>
              <entry><emphasis>orderDiskFunnel</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, if all inputs to a funnel are disk reads, pull
              in</entry>
            </row>

            <row>
              <entry><emphasis>parseDfaComplexity</emphasis></entry>

              <entry>Default: 2000</entry>

              <entry>Maximum complexity of expression to convert to a
              DFA.</entry>
            </row>

            <row>
              <entry><emphasis>pickBestEngine</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, use hthor if it is more efficient than
              Thor</entry>
            </row>

            <row>
              <entry><emphasis>diskReadsAreSimple</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, modifies the behavior of the pickBestEngine
              option so disk read operations are regarded the same as index
              read operations when deciding whether Thor is needed. The
              benefit is that simple jobs can run on hthor reading/filtering
              data remotely using dafilesrv.</entry>
            </row>

            <row>
              <entry><emphasis>targetClusterType</emphasis></entry>

              <entry>hthor|Thor|roxie</entry>

              <entry>What supercomputer type are we generating code
              for?</entry>
            </row>

            <row>
              <entry><emphasis>topnLimit</emphasis></entry>

              <entry>Default: 10000</entry>

              <entry>Maximum number of records to do topN on.</entry>
            </row>

            <row>
              <entry><emphasis>outputLimit</emphasis></entry>

              <entry>Default: 10</entry>

              <entry>Sets maximum size (in Mb) of result stored in
              workunit.</entry>
            </row>

            <row>
              <entry><emphasis>sortIndexPayload</emphasis></entry>

              <entry>Default: true</entry>

              <entry>Specifies sorting (or not) payload fields</entry>
            </row>

            <row>
              <entry><emphasis>workflow</emphasis></entry>

              <entry>Default: true</entry>

              <entry>Specifies enabling/disabling workflow services.</entry>
            </row>

            <row>
              <entry><emphasis>foldStored</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Specifies that all the stored variables are replaced with
              their default values, or values overridden by #stored. This can
              significantly reduce the size of the graph generated.</entry>
            </row>

            <row>
              <entry><emphasis>skipFileFormatCrcCheck</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Specifies that the CRC check on indices produces a
              warning and not an error.</entry>
            </row>

            <row>
              <entry><emphasis>allowedClusters</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specifies the comma-delimited list of cluster names (as a
              string constant) where the workunit may execute. This allows the
              job to be switched between clusters, manually or automatically,
              if the workunit is blocked on its assigned cluster and another
              valid cluster is available for use.</entry>
            </row>

            <row>
              <entry><emphasis>AllowAutoQueueSwitch</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, specifies that the workunit is automatically
              re-assigned to execute on another available cluster listed in
              allowedClusters when blocked on its assigned cluster.</entry>
            </row>

            <row>
              <entry><emphasis>performWorkflowCse</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, specifies that the code generator automatically
              detects opportunities for Common Sub-expression Elimination that
              may be "buried" within multiple PERSISTed attributes. If false,
              notification of these opportunities are displayed to the
              programmer as suggestions for the use of the INDEPENDENT
              Workflow Service.</entry>
            </row>

            <row>
              <entry><emphasis>defaultSkewError</emphasis></entry>

              <entry>Default: none</entry>

              <entry>A value between 0.0 and 1.0 that determines the amount of
              skew needed to generate a skew error. This value is ignored if
              the ECL has provided a SKEW attribute.</entry>
            </row>

            <row>
              <entry><emphasis>defaultSkewWarning</emphasis></entry>

              <entry>Default: none</entry>

              <entry>A value between 0.0 and 1.0 that determines the amount of
              skew needed to generate a skew warning. If set higher than
              defaultSkewError, then the value is ignored.</entry>
            </row>

            <row>
              <entry><emphasis>overrideSkewError</emphasis></entry>

              <entry>Default: none</entry>

              <entry>If set to a value between 0.0 and 1.0, it overrides any
              ECL SKEW(nn) attribute values in the current job.</entry>
            </row>

            <row>
              <entry><emphasis>defaultSkewThreshold</emphasis></entry>

              <entry>Default: 1GB</entry>

              <entry>The size of the dataset (in bytes) local to a single node
              needed before Skew errors/warnings are generated if no
              THRESHOLD(nn) was supplied in ECL.</entry>
            </row>

            <row>
              <entry><emphasis>overrideSkewThreshold</emphasis></entry>

              <entry>Default: none</entry>

              <entry>The size of the dataset (in bytes) local to a single node
              needed before Skew errors/warnings are generated. Overrides any
              ECL THRESHOLD(nn) attribute values in the current job.</entry>
            </row>

            <row>
              <entry><emphasis>applyInstantEclTransformations</emphasis></entry>

              <entry>Default false</entry>

              <entry>Limit non-file outputs with a CHOOSEN</entry>
            </row>

            <row>
              <entry><emphasis>applyInstantEclTransformationsLimit</emphasis></entry>

              <entry>Default 100</entry>

              <entry>Number of records to limit to</entry>
            </row>

            <row>
              <entry><emphasis>divideByZero</emphasis></entry>

              <entry>Default zero</entry>

              <entry>'zero' evaluates to 0, the default behavior. 'fail'
              causes the job to fail and report a division by zero error.
              'nan' (only currently supported for real numbers) creates a
              quiet NaN, which will propagate through any real expressions it
              is used in. You can use NOT ISVALID(x) to test if the value is a
              NaN. Integer and decimal division by zero continue to return
              0.</entry>
            </row>

            <row>
              <entry><emphasis>outputLimitMb</emphasis></entry>

              <entry>Default 10 [MB]</entry>

              <entry>Limit of output to a workunit in MB.</entry>
            </row>

            <row>
              <entry><emphasis>hthorMemoryLimit</emphasis></entry>

              <entry>Default 300 [MB]</entry>

              <entry>Override memory usage limit set in ECL Agent's
              defaultMemoryLimitMB configuration option (for hThor
              only).</entry>
            </row>

            <row>
              <entry><emphasis>maxCsvRowSizeMb</emphasis></entry>

              <entry>Default 10 [MB]</entry>

              <entry>Upper limit of a CSV line read in MB.</entry>
            </row>

            <row>
              <entry><emphasis>validateFileType</emphasis></entry>

              <entry>Default true</entry>

              <entry>If false, the engines use the definition in the ECL
              workunit and ignore the file type from the logical file meta
              data. If true, this check is always ignored if the ECL is
              reading a CSV or a fixed record width flat file. Also when true,
              if the ECL is reading XML or JSON, and there is a mismatch, it
              issues a warning not an error.</entry>
            </row>

            <row>
              <entry><emphasis>compressInternalSpills</emphasis></entry>

              <entry>Default true</entry>

              <entry>Compress internal spills. (e.g., spills created by
              lookahead or sort gathering).</entry>
            </row>

            <row>
              <entry><emphasis>hdCompressorType</emphasis></entry>

              <entry>Default 'FLZ'</entry>

              <entry>Distribute compressor to use.</entry>
            </row>

            <row>
              <entry><emphasis>hdCompressorOptions</emphasis></entry>

              <entry>Default ''</entry>

              <entry>Distribute compressor options (e.g., AES key)</entry>
            </row>

            <row>
              <entry><emphasis>splitterSpill</emphasis></entry>

              <entry>Default -1</entry>

              <entry>Integer value to indicate whether to force splitters to
              spill or not. [1 = force spill | 0 = force in memory | -1 =
              adhere to helper setting ]</entry>
            </row>

            <row>
              <entry><emphasis>loopMaxEmpty</emphasis></entry>

              <entry>Default 1000</entry>

              <entry>Max # of iterations that LOOP can cycle through without
              results before reporting an error</entry>
            </row>

            <row>
              <entry><emphasis>smallSortThreshold</emphasis></entry>

              <entry>Default 0 (disabled)</entry>

              <entry>If estimated size is below this threshold in bytes, a
              minisort approach should be used.</entry>
            </row>

            <row>
              <entry><emphasis>sort_max_deviance</emphasis></entry>

              <entry>Default 10 [MB]</entry>

              <entry>Max (byte) variance allowed during sort
              partitioning</entry>
            </row>

            <row>
              <entry><emphasis>joinHelperThreads</emphasis></entry>

              <entry>Default = same as number of cores</entry>

              <entry>Number of threads to use in threaded variety of join
              helper</entry>
            </row>

            <row>
              <entry><emphasis>bindCores</emphasis></entry>

              <entry>Default = 0</entry>

              <entry>For Roxie queries. If non-zero, binds the query to only
              use the specified number of cores. This overrides the value set
              for coresPerQuery in Roxie configuration. <indexterm>
                  <primary>Roxie processor affinity</primary>
                </indexterm><indexterm>
                  <primary>Roxie CPU pinning</primary>
                </indexterm><indexterm>
                  <primary>CPU pinning</primary>
                </indexterm><indexterm>
                  <primary>processor affinity</primary>
                </indexterm></entry>
            </row>

            <row>
              <entry><emphasis>translateDFSlayouts</emphasis></entry>

              <entry>Default = 0</entry>

              <entry>Specifies that file layouts should be looked up at
              compile time. See <emphasis>File Layout Resolution at Compile
              Time</emphasis> in the <emphasis>Programmer's Guide</emphasis>
              for more details.</entry>
            </row>

            <row>
              <entry><emphasis>timeLimit</emphasis></entry>

              <entry/>

              <entry>For Roxie queries. Maximum run time (in ms) for a
              query.</entry>
            </row>

            <row>
              <entry><emphasis>generateGlobalId</emphasis></entry>

              <entry>Default = false</entry>

              <entry>For Roxie queries. When true, generates a unique GlobalId
              if one is not provided.</entry>
            </row>

            <row>
              <entry><emphasis>analyzeWorkunit</emphasis></entry>

              <entry/>

              <entry>Overrides the setting in ECL Agent to analyze workunits
              after ECL queries are executed (Thor only). This allows a
              workunit to be further analyzed to identify and display any
              potential issues. These possible issues display in ECL Watch's
              "Warnings &amp; Errors" area. The global setting defaults to
              TRUE, but can be changed using Configuration Manager.</entry>
            </row>

            <row>
              <entry><emphasis>maxCost</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Overrides the <emphasis>limit</emphasis> setting in
              Thor's configuration. If the <emphasis>maxCost</emphasis>
              threshold is reached, the job guillotine is enforced and the job
              is halted. This does not override the
              <emphasis>hardlimit</emphasis> setting. This is only valid for
              Thor jobs.</entry>
            </row>

            <row>
              <entry><emphasis>writeInlineContent</emphasis></entry>

              <entry/>

              <entry>If true, writing a field with XPATH('Name/&lt;&gt;')
              outputs the string without XML/JSON encoding the content. This
              allows you to insert arbitrary XML/JSON into the output. There
              are 3 forms: <emphasis role="bold">'&lt;&gt;'</emphasis> writes
              the content without a root tag, reading reads all content of
              parent.<emphasis role="bold"> 'Name&lt;&gt;'</emphasis> writes
              the content without a tag, reading reads the content of the tag
              . <emphasis role="bold">'Name/&lt;&gt;' </emphasis>writes the
              content inside, reading reads the content of the tag.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para><emphasis role="bold">The following options are all about generating
    Logical graphs in a workunit. </emphasis></para>

    <para>Logical graphs<indexterm>
        <primary>Logical graphs</primary>
      </indexterm> are stored in the workunit and viewed in ECL Watch. They
    include information about which attribute/line number/column the symbols
    are defined in. Exported attributes are represented by
    &lt;module&gt;.&lt;attribute&gt; in the header of the activity.
    Non-exported (local) attributes are represented as
    &lt;module&gt;.&lt;exported-attribute&gt;::&lt;non-exported-name&gt;</para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="3">
          <colspec colwidth="178.45pt"/>

          <colspec colwidth="65.60pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>generateLogicalGraph</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, generates a Logical graph in addition to all the
              workunit graphs.</entry>
            </row>

            <row>
              <entry><emphasis>generateLogicalGraphOnly</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, generates only the Logical graph for the
              workunit.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphExpandPersist</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, generates expands PERSISTed attributes.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphExpandStored</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, generates expands STORED attributes.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphIncludeName</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, generates attribute names in the header of the
              activity boxes.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphIncludeModule</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, generates module.attribute names in the header
              of the activity boxes.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphDisplayJavadoc</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, generates the Javadoc-style comments embedded in
              the ECL in place of the standard text that would be generated
              (see http://java.sun.com/j2se/javadoc/writingdoccomments/).
              Javadoc-style comments on RECORD structures or scalar attributes
              will not generate, as they have no graph Activity box directly
              associated.</entry>
            </row>

            <row>
              <entry><emphasis>logicalGraphDisplayJavadocParameters</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, generates information about parameters in any
              Javadoc-style comments.</entry>
            </row>

            <row>
              <entry><emphasis>filteredReadSpillThreshold</emphasis></entry>

              <entry>Default: 2</entry>

              <entry>Filtered disk reads are spilled if will be duplicated
              more than N times.</entry>
            </row>

            <row>
              <entry><emphasis>foldConstantCast</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, (cast)value is folded at generate time.</entry>
            </row>

            <row>
              <entry><emphasis>foldFilter</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, filters are constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>foldAssign</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, TRANSFORMs are constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>foldSQL</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, SQL is constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeDiskRead</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, include project and filter in the transform for
              a disk read.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeSQL</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, optimize SQL.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeThorCounts</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, convert COUNT(diskfile) into optimized
              version.</entry>
            </row>

            <row>
              <entry><emphasis>peephole</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, peephole optimize memcpy/memsets, etc.</entry>
            </row>

            <row>
              <entry><emphasis>spotCSE</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, look for common sub-expressions in
              TRANSFORMs/filters.</entry>
            </row>

            <row>
              <entry><emphasis>noteRecordSizeInGraph</emphasis></entry>

              <entry>Default: true</entry>

              <entry>Add estimates of record sizes to the graph</entry>
            </row>

            <row>
              <entry><emphasis>showActivitySizeInGraph</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Show estimates of generated C++ size in the graph</entry>
            </row>

            <row>
              <entry><emphasis>showMetaInGraph</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Add distribution/sort orders to the graph</entry>
            </row>

            <row>
              <entry><emphasis>showRecordCountInGraph</emphasis></entry>

              <entry>Default: true</entry>

              <entry>Show estimates of record counts in the graph</entry>
            </row>
          </tbody>
        </tgroup>

        <tgroup cols="1">
          <colspec colwidth="441.90pt"/>

          <tbody>
            <row>
              <entry><emphasis/></entry>
            </row>
          </tbody>
        </tgroup>

        <tgroup cols="3">
          <colspec colwidth="178.45pt"/>

          <colspec colwidth="65.60pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>spotTopN</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, convert CHOOSEN(SORT()) into a topN
              activity.</entry>
            </row>

            <row>
              <entry><emphasis>spotLocalMerge</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, if local JOIN and both sides are sorted,
              generate a light-weight merge.</entry>
            </row>

            <row>
              <entry><emphasis>countIndex</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, optimize COUNT(index) into optimized version
              (also requires optimizeThorCounts).</entry>
            </row>

            <row>
              <entry><emphasis>allowThroughSpill</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, allow through spills.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeBoolReturn</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, improve code when returning BOOLEAN from a
              function.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeSubString</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, don't allocate memory when doing a
              substring.</entry>
            </row>

            <row>
              <entry><emphasis>thorKeys</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, allow INDEX operations in Thor.</entry>
            </row>

            <row>
              <entry><emphasis>regexVersion</emphasis></entry>

              <entry>Default: 0</entry>

              <entry>If set to 1, specifies use of the previous regular
              expression implementation, which may be faster but also may
              exceed stack limits.</entry>
            </row>

            <row>
              <entry><emphasis>compileOptions</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specify override compiler options (such as /Zm1000 to
              double the compiler heap size to workaround a heap overflow
              error).</entry>
            </row>

            <row>
              <entry><emphasis>linkOptions</emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specify override linker options.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeProjects</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If false, disables automatic field
              projection/distribution optimization.</entry>
            </row>

            <row>
              <entry><emphasis>notifyOptimizedProjects</emphasis></entry>

              <entry>Default: 0</entry>

              <entry>If set to 1, reports optimizations to named attributes.
              If set to 2, reports all optimizations.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeProjectsPreservePersists</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, disables automatic field projection/distribution
              optimization around reading PERSISTed files. If a PERSISTed file
              is read on a different size cluster than it was created on,
              optimizing the projected fields can mean that the
              distribution/sort order cannot be recreated.</entry>
            </row>

            <row>
              <entry><emphasis>aggressiveOptimizeProjects</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, enables attempted minimization of network
              traffic for sorts/distributes. This option doesn't usually
              result in significant benefits, but may do so in some specific
              cases.</entry>
            </row>

            <row>
              <entry><emphasis>percolateConstants</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If false, disables attempted aggressive constant value
              optimizations.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para><emphasis role="bold">The following </emphasis><emphasis
    role="bold">options</emphasis><emphasis role="bold"> are useful for
    debugging: </emphasis></para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="3">
          <colspec colwidth="178.45pt"/>

          <colspec colwidth="65.60pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>debugNlp</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, output debug information about the NLP
              processing to the .cpp file.</entry>
            </row>

            <row>
              <entry><emphasis>resourceMaxMemory</emphasis></entry>

              <entry>Default: 400M</entry>

              <entry>Maximum amount of memory a subgraph can use.</entry>
            </row>

            <row>
              <entry><emphasis>resourceMaxSockets</emphasis></entry>

              <entry>Default: 2000</entry>

              <entry>Maximum number of sockets a subgraph can use.</entry>
            </row>

            <row>
              <entry><emphasis>resourceMaxActivities</emphasis></entry>

              <entry>Default: 200</entry>

              <entry>Maximum number of activities a subgraph can
              contain.</entry>
            </row>

            <row>
              <entry><emphasis>unlimitedResources</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, assume lots of resources when resourcing the
              graphs.</entry>
            </row>

            <row>
              <entry><emphasis>traceRowXML</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, turns on tracing in ECL Watch graphs. This
              should only be used with small datasets for debugging
              purposes.</entry>
            </row>

            <row>
              <entry><emphasis>_Probe</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, display all result rows from intermediate result
              sets in the graph in ECL Watch when used in conjunction with the
              traceRowXML option. This should only be used with small datasets
              for debugging purposes.</entry>
            </row>

            <row>
              <entry><emphasis>debugQuery</emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, compile query using debug settings.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeLevel</emphasis></entry>

              <entry>Default: 3 for roxie, else 0</entry>

              <entry>Set the C++ compiler optimization level (optimizations
              can cause the compiler to take a lot longer).</entry>
            </row>

            <row>
              <entry><emphasis>checkAsserts</emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, enables ASSERT checking.</entry>
            </row>

            <row>
              <entry><emphasis>soapTraceLevel</emphasis></entry>

              <entry>Default: 1</entry>

              <entry>The level of detail in reporting SOAPCALL or HTTPCALL
              information (set to 0 for none, 1 for normal, 2 - 8 for more
              detail)</entry>
            </row>

            <row>
              <entry><emphasis>traceEnabled</emphasis></entry>

              <entry>Default: FALSE</entry>

              <entry>Enables tracing to log files when TRACE actions are
              present. See <link linkend="TRACE">TRACE</link>.</entry>
            </row>

            <row>
              <entry><emphasis>traceLimit</emphasis></entry>

              <entry>Default: 10</entry>

              <entry>Overrides the the default KEEP setting for a TRACE
              statement to indicate how many TRACE statement to write to log
              file. See <link linkend="TRACE">TRACE</link>.</entry>
            </row>

            <row>
              <entry><emphasis>maxlogdetail</emphasis></entry>

              <entry/>

              <entry>Overrides the the default logging level for a single
              workunit. This allows logging levels to be set to a low level by
              default, but allow jobs to be resubmitted with a higher logging
              level for investigation.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para><emphasis role="bold">The following </emphasis><emphasis
    role="bold">options</emphasis><emphasis role="bold"> are for advanced code
    generation use:</emphasis></para>

    <para>These <emphasis>options</emphasis> should be left alone unless you
    REALLY know what you are doing. Typically they are used internally by our
    developers to enable/disable features that are still in development.
    Occasionally the technical support staff will suggest that you change one
    of these settings to work around a problem that you encounter, but
    otherwise the default settings are recommended in all cases.</para>

    <para><informaltable colsep="1" frame="all" rowsep="1">
        <tgroup cols="3">
          <colspec colwidth="178.45pt"/>

          <colspec colwidth="65.60pt"/>

          <colspec/>

          <tbody>
            <row>
              <entry><emphasis>filteredReadSpillThreshold</emphasis></entry>

              <entry>Default: 2</entry>

              <entry>Filtered disk reads are spilled if will be duplicated
              more than N times.</entry>
            </row>

            <row>
              <entry><emphasis>foldConstantCast </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, (cast)value is folded at generate time.</entry>
            </row>

            <row>
              <entry><emphasis>foldFilter </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, filters are constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>foldAssign </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, TRANSFORMs are constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>foldSQL </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, SQL is constant folded.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeDiskRead </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, include project and filter in the transform for
              a disk read.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeSQL </emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, optimize SQL.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeThorCounts </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, convert COUNT(diskfile) into optimized
              version.</entry>
            </row>

            <row>
              <entry><emphasis>peephole </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, peephole optimize memcpy/memsets, etc.</entry>
            </row>

            <row>
              <entry><emphasis>spotCSE </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, look for common sub-expressions in
              TRANSFORMs/filters.</entry>
            </row>

            <row>
              <entry><emphasis>spotTopN </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, convert CHOOSEN(SORT()) into a topN
              activity.</entry>
            </row>

            <row>
              <entry><emphasis>spotLocalMerge </emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, if local JOIN and both sides are sorted,
              generate a light-weight merge.</entry>
            </row>

            <row>
              <entry><emphasis>countIndex </emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, optimize COUNT(index) into optimized version
              (also requires optimizeThorCounts).</entry>
            </row>

            <row>
              <entry><emphasis>allowThroughSpill </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, allow through spills.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeBoolReturn </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, improve code when returning BOOLEAN from a
              function.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeSubString </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, don't allocate memory when doing a
              substring.</entry>
            </row>

            <row>
              <entry><emphasis>thorKeys </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If true, allow INDEX operations in thor.</entry>
            </row>

            <row>
              <entry><emphasis>regexVersion </emphasis></entry>

              <entry>Default: 0</entry>

              <entry>If set to 1, specifies use of the previous regular
              expression implementation, which may be faster but also may
              exceed stack limits.</entry>
            </row>

            <row>
              <entry><emphasis>compileOptions </emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specify override compiler options (such as /Zm1000 to
              double the compiler heap size to workaround a heap overflow
              error).</entry>
            </row>

            <row>
              <entry><emphasis>linkOptions </emphasis></entry>

              <entry>Default: none</entry>

              <entry>Specify override linker options.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeProjects </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If false, disables automatic field
              projection/distribution optimization.</entry>
            </row>

            <row>
              <entry><emphasis>notifyOptimizedProjects </emphasis></entry>

              <entry>Default: 0</entry>

              <entry>If set to 1, reports optimizations to named attributes.
              If set to 2, reports all optimizations.</entry>
            </row>

            <row>
              <entry><emphasis>optimizeProjectsPreservePersists
              </emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, disables automatic field projection/distribution
              optimization around reading PERSISTed files. If a PERSISTed file
              is read on a different size cluster than it was created on,
              optimizing the projected fields can mean that the
              distribution/sort order cannot be recreated.</entry>
            </row>

            <row>
              <entry><emphasis>aggressiveOptimizeProjects </emphasis></entry>

              <entry>Default: false</entry>

              <entry>If true, enables attempted minimization of network
              traffic for sorts/distributes. This option doesn't usually
              result in significant benefits, but may do so in some specific
              cases.</entry>
            </row>

            <row>
              <entry><emphasis>percolateConstants </emphasis></entry>

              <entry>Default: true</entry>

              <entry>If false, disables attempted aggressive constant value
              optimizations.</entry>
            </row>

            <row>
              <entry><emphasis>exportDependencies</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Generate information about inter-definition
              dependencies</entry>
            </row>

            <row>
              <entry><emphasis>maxCompileThreads</emphasis></entry>

              <entry>Default 4 for eclccserver and 1 for eclcc</entry>

              <entry>Number of compiler instances to compile the C++</entry>
            </row>

            <row>
              <entry><emphasis>reportCppWarnings</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Report warnings from C++ compilation</entry>
            </row>

            <row>
              <entry><emphasis>saveCppTempFiles</emphasis></entry>

              <entry>Default: false</entry>

              <entry>Retain the generated C++ files</entry>
            </row>

            <row>
              <entry><emphasis>spanMultipleCpp</emphasis></entry>

              <entry>Default: true</entry>

              <entry>Generate a work unit in multiple C++ files</entry>
            </row>

            <row>
              <entry><emphasis>activitiesPerCpp</emphasis></entry>

              <entry>Default 500 for Linux or 800 for Windows</entry>

              <entry>Number of activities in each C++ file (requires
              spanMultipleCpp)</entry>
            </row>

            <row>
              <entry><emphasis>obfuscateOutput</emphasis></entry>

              <entry>Default false</entry>

              <entry>If true, details are removed from the generated workunit,
              including ECL code, estimates of record size, and number of
              records.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para><emphasis role="bold">The following </emphasis><emphasis
    role="bold">options</emphasis><emphasis role="bold"> are for the workunit
    analyzer:</emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="3">
        <colspec colwidth="178.45pt"/>

        <colspec colwidth="78.60pt"/>

        <colspec/>

        <tbody>
          <row>
            <entry><emphasis>analyzeWorkunit</emphasis></entry>

            <entry>Default: true</entry>

            <entry>If set to FALSE, disables analysis of the workunit</entry>
          </row>

          <row>
            <entry><emphasis>analyzer_minInterestingTime</emphasis></entry>

            <entry>Default: 1000</entry>

            <entry>Analyze activities that exceed this minimum time to execute
            (milliseconds)</entry>
          </row>

          <row>
            <entry><emphasis>analyzer_minInterestingCost </emphasis></entry>

            <entry>Default: 30000</entry>

            <entry>Report issues where the time penalty exceeds this value
            (milliseconds)</entry>
          </row>

          <row>
            <entry><emphasis>analyzer_skewThreshold </emphasis></entry>

            <entry>Default: 20</entry>

            <entry>Report skew related issues that exceed this
            threshold</entry>
          </row>

          <row>
            <entry><emphasis>analyzer_minRowsPerNode </emphasis></entry>

            <entry>Default: 1000</entry>

            <entry>Ignore activities that have this average number of rows per
            node</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Examples:</para>

    <para><programlisting lang="ECL_Runnable">#OPTION('traceRowXml', TRUE);
#OPTION('_Probe', TRUE);

my_rec := RECORD
  STRING20 lname;
  STRING20 fname;
  STRING2 age;
END;
  
d := DATASET([{ 'PORTLY', 'STUART' , '39'},
              { 'PORTLY', 'STACIE' , '36'},
              { 'PORTLY', 'DARA' , ' 1'},
              { 'PORTLY', 'GARRETT', ' 4'}], my_rec);
  
OUTPUT(d(d.age &gt; ' 1'), {lname, fname, age} );
</programlisting></para>

    <para/>

    <para><programlisting lang="ECL" role="notrunnable">//************************************
//This example demonstrates Logical Graphs and
// Javadoc-style comment blocks
#OPTION('generateLogicalGraphOnly',TRUE);
#OPTION('logicalGraphDisplayJavadocParameters',TRUE);
/**
 * Defines a record that contains information about a person
*/
namesRecord := RECORD
  string20    surname;
  string10    forename;
  integer2    age := 25;
END;
  
/**
Defines a table that can be used to read the information from the file
and then do something with it.
*/
namesTable := DATASET('x',namesRecord,FLAT);
  
  
/**
 Allows the name table to be filtered.
 @param ages        The ages that are allowed to be processed.
 @param badForename Forname to avoid.
 @return the filtered dataset.
*/
namesTable filtered(SET OF INTEGER2 ages, STRING badForename) :=
                    namesTable(age in ages, forename != badForename);
OUTPUT(filtered([10,20,33], ''));
</programlisting></para>
  </sect2>
</sect1>
