<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="JOIN">
  <!-- DNT-Start --><title>JOIN</title><!-- DNT-End -->

  <para><emphasis role="bold"><!-- DNT-Start -->JOIN<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->JOIN<!-- DNT-End --></primary>
    </indexterm><indexterm>
      <primary><!-- DNT-Start -->JOIN<!-- DNT-End --> function</primary>
    </indexterm>(</emphasis><emphasis>leftrecset, rightrecset, joincondition
  </emphasis><emphasis role="bold">[</emphasis><emphasis>,
  transform</emphasis><emphasis role="bold">] [</emphasis><emphasis>,
  jointype</emphasis><emphasis role="bold">] [</emphasis><emphasis>,
  joinflags</emphasis><emphasis role="bold">] )</emphasis></para>

  <para><emphasis role="bold"><!-- DNT-Start -->JOIN<!-- DNT-End -->(</emphasis><emphasis>setofdatasets,
  joincondition, transform</emphasis>,<emphasis role="bold"> <!-- DNT-Start -->SORTED<!-- DNT-End --><indexterm>
      <primary><!-- DNT-Start -->SORTED<!-- DNT-End --></primary>
    </indexterm>( </emphasis><emphasis>fields</emphasis><emphasis
  role="bold">) [</emphasis><emphasis>, jointype</emphasis><emphasis
  role="bold">] )</emphasis></para>

  <informaltable colsep="1" frame="all" rowsep="1">
    <tgroup cols="2">
      <colspec colwidth="82.00pt" />

      <colspec />

      <tbody>
        <row>
          <entry><!-- DNT-Start --><emphasis>leftrecset</emphasis><!-- DNT-End --></entry>

          <entry>The left set of records to process.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>rightrecset</emphasis><!-- DNT-End --></entry>

          <entry>The right set of records to process. This may be an
          <!-- DNT-Start -->INDEX<!-- DNT-End -->.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>joincondition</emphasis><!-- DNT-End --></entry>

          <entry>An expression specifying how to match records in the
          <emphasis>leftrecset</emphasis> and <emphasis>rightrecset</emphasis>
          or <emphasis>setofdatasets</emphasis> (see Matching Logic
          discussions below). In the expression, the keyword <!-- DNT-Start -->LEFT<!-- DNT-End --> is the
          dataset qualifier for fields in the <emphasis>leftrecset</emphasis>
          and the keyword <!-- DNT-Start -->RIGHT<!-- DNT-End --> is the dataset qualifier for fields in the
          <emphasis>rightrecset</emphasis>.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>transform</emphasis><!-- DNT-End --></entry>

          <entry>Optional. The <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function to call for each pair of
          records to process. If omitted, <!-- DNT-Start -->JOIN<!-- DNT-End --> returns all fields from both
          the <emphasis>leftrecset</emphasis> and
          <emphasis>rightrecset</emphasis>, with the second of any duplicate
          named fields removed.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>jointype</emphasis><!-- DNT-End --></entry>

          <entry>Optional. An inner join if omitted, else one of the listed
          types in the <!-- DNT-Start -->JOIN<!-- DNT-End --> Types section below.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>joinflags</emphasis><!-- DNT-End --></entry>

          <entry>Optional. Any option (see the <!-- DNT-Start -->JOIN<!-- DNT-End --> <!-- DNT-Start -->Options<!-- DNT-End --> section below) to
          specify exactly how the <!-- DNT-Start -->JOIN<!-- DNT-End --> operation executes.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>setofdatasets</emphasis><!-- DNT-End --></entry>

          <entry>The <!-- DNT-Start -->SET<!-- DNT-End --> of recordsets to process ([idx1,idx2,idx3]),
          typically <!-- DNT-Start -->INDEXes<!-- DNT-End -->, which all must have the same format.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis role="bold">SORTED</emphasis><!-- DNT-End --></entry>

          <entry>Specifies the sort order of records in the input
          <emphasis>setofdatasets</emphasis> and also the output sort order of
          the result set.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start --><emphasis>fields</emphasis><!-- DNT-End --></entry>

          <entry>A comma-delimited list of fields in the
          <emphasis>setofdatasets</emphasis>, which must be a subset of the
          input sort order. These fields must all be used in the
          <emphasis>joincondition</emphasis> as they define the order in which
          the fields are <!-- DNT-Start -->STEPPED<!-- DNT-End -->.</entry>
        </row>

        <row>
          <entry><!-- DNT-Start -->Return:<!-- DNT-End --></entry>

          <entry><!-- DNT-Start -->JOIN<!-- DNT-End --> returns a record set.</entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>

  <para>The <emphasis role="bold"><!-- DNT-Start -->JOIN<!-- DNT-End --> </emphasis>function produces a result
  set based on the intersection of two or more datasets or indexes (as
  determined by the <emphasis>joincondition</emphasis>).</para>

  <sect2 id="JOIN_Two_Datasets">
    <!-- DNT-Start --><title>JOIN Two Datasets</title><!-- DNT-End -->

    <para><emphasis role="bold"><!-- DNT-Start -->JOIN<!-- DNT-End -->(</emphasis><emphasis>leftrecset,
    rightrecset, joincondition </emphasis><emphasis
    role="bold">[</emphasis><emphasis>, transform</emphasis><emphasis
    role="bold">] [</emphasis><emphasis>, jointype</emphasis><emphasis
    role="bold">] [</emphasis><emphasis>, joinflags</emphasis><emphasis
    role="bold">] )</emphasis></para>

    <para><emphasis role="bold">The first form of <!-- DNT-Start -->JOIN<!-- DNT-End --> processes through all
    pairs of records in the </emphasis><emphasis>leftrecset </emphasis>and
    <emphasis>rightrecset</emphasis> and evaluates the <emphasis>condition
    </emphasis>to find matching records. If the <emphasis>condition</emphasis>
    and <emphasis>jointype</emphasis> specify the pair of records qualifies to
    be processed, the <emphasis>transform</emphasis> function executes,
    generating the result.</para>

    <para><!-- DNT-Start -->JOIN<!-- DNT-End --> dynamically sorts/distributes the
    <emphasis>leftrecset</emphasis> and <emphasis>rightrecset</emphasis> as
    needed to perform its operation based on the
    <emphasis>condition</emphasis> specified, therefore <emphasis
    role="bold">the output record set is not guaranteed to be in the same
    order as the input record sets</emphasis>. If <!-- DNT-Start -->JOIN<!-- DNT-End --> does do a dynamic sort
    of its input record sets, that new sort order cannot be relied upon to
    exist past the execution of the <!-- DNT-Start -->JOIN<!-- DNT-End -->. This principle also applies to any
    GROUPing--the records are automatically "un-grouped" as needed except under
    the following circumstances:</para>

    <para>* For <!-- DNT-Start -->LOOKUP<!-- DNT-End --> and <!-- DNT-Start -->ALL<!-- DNT-End --> joins, the GROUPing and sort order of the
    <emphasis>leftrecset</emphasis> are preserved.</para>

    <para>* For <!-- DNT-Start -->KEYED<!-- DNT-End --> joins the GROUPing (but not the sort order) of the
    <emphasis>leftrecset</emphasis> is preserved.</para>
  </sect2>

  <sect2 id="Matching_Logic">
    <!-- DNT-Start --><title>Matching Logic - JOIN</title><!-- DNT-End -->

    <!-- DNT-Start --><para>The record matching <emphasis>joincondition</emphasis> is processed
    internally as two parts:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="82pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start -->"equality" (hard match)<!-- DNT-End --></entry>

            <entry>All the simple "LEFT.field = RIGHT.field" logic that
            defines matching records. For <!-- DNT-Start -->JOINs<!-- DNT-End --> that use keys, all these must
            be fields in the key to qualify for inclusion in this part. If
            there is no "equality" part to the
            <emphasis>joincondition</emphasis> logic, then you get a "JOIN too
            complex" error.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->"non-equality" (soft match)<!-- DNT-End --></entry>

            <entry>All other matching criteria in the
            <emphasis>joincondition</emphasis> logic, such as "LEFT.field &gt;
            RIGHT.field" expressions or any <!-- DNT-Start -->OR<!-- DNT-End --> logic that may be involved with
            the final determination of which <emphasis>leftrecset</emphasis>
            and <emphasis>rightrecset</emphasis> records actually
            match.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>This internal logic split allows the <!-- DNT-Start -->JOIN<!-- DNT-End --> code to be optimized for
    maximum efficiency--first the "equality" logic is evaluated to provide an
    interim result that is then evaluated against any "non-equality" in the
    matching <emphasis>joincondition<indexterm>
        <primary>joincondition</primary>
      </indexterm></emphasis>.</para>
  </sect2>

  <sect2 id="JoinOptions">
    <!-- DNT-Start --><title>Options</title><!-- DNT-End -->

    <para>The following <emphasis>joinflags</emphasis><indexterm>
        <primary>joinflags</primary>
      </indexterm> options may be specified to determine exactly how the <!-- DNT-Start -->JOIN<!-- DNT-End -->
    executes.</para>

    <para><emphasis role="bold">[</emphasis>,<emphasis role="bold"> <!-- DNT-Start -->PARTITION<!-- DNT-End -->
    <!-- DNT-Start -->LEFT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --></primary>
      </indexterm> | <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->RIGHT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->RIGHT<!-- DNT-End --></primary>
      </indexterm> | [<!-- DNT-Start -->MANY<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->MANY<!-- DNT-End --></primary>
      </indexterm>] <!-- DNT-Start -->LOOKUP<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->LOOKUP<!-- DNT-End --></primary>
      </indexterm> [ <!-- DNT-Start -->FEW<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->FEW<!-- DNT-End --></primary>
      </indexterm>] ] | <!-- DNT-Start -->GROUPED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->GROUPED<!-- DNT-End --></primary>
      </indexterm> | <!-- DNT-Start -->ALL<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ALL<!-- DNT-End --></primary>
      </indexterm> |</emphasis><emphasis role="bold"> <!-- DNT-Start -->NOSORT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->NOSORT<!-- DNT-End --></primary>
      </indexterm> [ ( </emphasis><emphasis>which</emphasis><emphasis
    role="bold"> ) ] | <!-- DNT-Start -->KEYED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->KEYED<!-- DNT-End --></primary>
      </indexterm> [ (</emphasis><emphasis>index</emphasis><emphasis
    role="bold">) [, <!-- DNT-Start -->UNORDERED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->UNORDERED<!-- DNT-End --></primary>
      </indexterm> ] ] | <!-- DNT-Start -->LOCAL<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->LOCAL<!-- DNT-End --></primary>
      </indexterm> | <!-- DNT-Start -->HASH<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->HASH<!-- DNT-End --></primary>
      </indexterm> ]]</emphasis><emphasis role="bold"></emphasis><?linebreak ?><emphasis
    role="bold">[</emphasis>,<emphasis role="bold"> <!-- DNT-Start -->KEEP<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->KEEP<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis>n</emphasis><emphasis role="bold">) ]
    [</emphasis><emphasis>, </emphasis><emphasis role="bold"><!-- DNT-Start -->ATMOST<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->ATMOST<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> </emphasis><emphasis
    role="bold">[</emphasis><emphasis> condition, </emphasis><emphasis
    role="bold">]</emphasis><emphasis> n </emphasis><emphasis role="bold">) ]
    [</emphasis><emphasis>, </emphasis><emphasis role="bold"><!-- DNT-Start -->LIMIT<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->LIMIT<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis> value </emphasis><emphasis
    role="bold">[, <!-- DNT-Start -->SKIP<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SKIP<!-- DNT-End --></primary>
      </indexterm></emphasis> | <emphasis> transform </emphasis> | <emphasis
    role="bold"> <!-- DNT-Start -->FAIL<!-- DNT-End --> ]) ] </emphasis><emphasis
    role="bold">[</emphasis>,<emphasis role="bold"> <!-- DNT-Start -->SKEW<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SKEW<!-- DNT-End --></primary>
      </indexterm>(</emphasis><emphasis>limit </emphasis><emphasis
    role="bold">[</emphasis><emphasis>, target</emphasis><emphasis
    role="bold">] ) [, <!-- DNT-Start -->THRESHOLD<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->THRESHOLD<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>size</emphasis><emphasis role="bold">
    ) ] ] [, <!-- DNT-Start -->SMART<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SMART<!-- DNT-End --></primary>
      </indexterm> ]</emphasis> <emphasis role="bold">[, <!-- DNT-Start -->UNORDERED<!-- DNT-End --> |
    <!-- DNT-Start -->ORDERED<!-- DNT-End -->(</emphasis> <emphasis>bool </emphasis><emphasis role="bold">) ] [,
    <!-- DNT-Start -->STABLE<!-- DNT-End --> | <!-- DNT-Start -->UNSTABLE<!-- DNT-End --> ] [, <!-- DNT-Start -->PARALLEL<!-- DNT-End --> [ (</emphasis> <emphasis>numthreads
    </emphasis><emphasis role="bold">) ] ] [, <!-- DNT-Start -->ALGORITHM<!-- DNT-End -->(</emphasis>
    <emphasis>name </emphasis><emphasis role="bold">) ]</emphasis></para>

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="92.05pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">PARTITION LEFT |
            RIGHT</emphasis><!-- DNT-End --></entry>

            <entry>Specifies which recordset provides the partition points
            that determine how the records are sorted and distributed amongst
            the supercomputer nodes. <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->RIGHT<!-- DNT-End --> specifies the
            <emphasis>rightrecset</emphasis> while <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --> specifies
            the <emphasis>leftrecset</emphasis>. If omitted, <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --> is
            the default.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">[MANY] LOOKUP</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>rightrecset</emphasis> is a
            relatively small file of lookup records that can be fully copied
            to every node. If <!-- DNT-Start -->MANY<!-- DNT-End --> is not present, the
            <emphasis>rightrecset</emphasis> records bear a Many to 0/1
            relationship with the records in the
            <emphasis>leftrecset</emphasis> (for each record in the
            <emphasis>leftrecset</emphasis> there is at most 1 record in the
            <emphasis>rightrecset</emphasis>). If <!-- DNT-Start -->MANY<!-- DNT-End --> is present, the
            <emphasis>rightrecset</emphasis> records bear a Many to 0/Many
            relationship with the records in the
            <emphasis>leftrecset</emphasis>. This option allows the optimizer
            to avoid unnecessary sorting of the
            <emphasis>leftrecset</emphasis>. Valid only for inner, <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End -->,
            or <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End --> <emphasis>jointypes</emphasis>. The <!-- DNT-Start -->ATMOST<!-- DNT-End -->, <!-- DNT-Start -->LIMIT<!-- DNT-End -->,
            and <!-- DNT-Start -->KEEP<!-- DNT-End --> options are supported in conjunction with <!-- DNT-Start -->MANY<!-- DNT-End -->
            <!-- DNT-Start -->LOOKUP<!-- DNT-End -->.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">SMART</emphasis><!-- DNT-End --></entry>

            <entry>Specifies to use an in-memory lookup when possible, but use
            a distributed join if the right dataset is large.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">FEW</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <!-- DNT-Start -->LOOKUP<!-- DNT-End --> <emphasis>rightrecset</emphasis> has
            few records, so little memory is used, allowing multiple lookup
            joins to be included in the same Thor subgraph.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">GROUPED</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the same action as <!-- DNT-Start -->MANY<!-- DNT-End --> <!-- DNT-Start -->LOOKUP<!-- DNT-End --> but preserves
            grouping. Primarily used in the rapid Data Delivery Engine. Valid
            only for inner, <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End -->, or <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End -->
            <emphasis>jointypes</emphasis>. The <!-- DNT-Start -->ATMOST<!-- DNT-End -->, <!-- DNT-Start -->LIMIT<!-- DNT-End -->, and <!-- DNT-Start -->KEEP<!-- DNT-End -->
            options are supported in conjunction with <!-- DNT-Start -->GROUPED<!-- DNT-End -->.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ALL</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the <emphasis>rightrecset</emphasis> is a small
            file that can be fully copied to every node, which allows the
            compiler to ignore the lack of any "equality" portion to the
            condition, eliminating the "join too complex" error that the
            condition would normally produce. If an "equality" portion is
            present, the <!-- DNT-Start -->JOIN<!-- DNT-End --> is internally executed as a <!-- DNT-Start -->MANY<!-- DNT-End --> <!-- DNT-Start -->LOOKUP<!-- DNT-End -->. The
            <!-- DNT-Start -->KEEP<!-- DNT-End --> option is supported in conjunction with this option.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">NOSORT</emphasis><!-- DNT-End --></entry>

            <entry>Performs the <!-- DNT-Start -->JOIN<!-- DNT-End --> without dynamically sorting the tables.
            This implies that the <emphasis>leftrecset</emphasis> and/or
            <emphasis>rightrecset</emphasis> must have been previously sorted
            and partitioned based on the fields specified in the
            <emphasis>joincondition</emphasis> so that records can be easily
            matched.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>which</emphasis><!-- DNT-End --></entry>

            <entry>Optional. The keywords <!-- DNT-Start -->LEFT<!-- DNT-End --> or <!-- DNT-Start -->RIGHT<!-- DNT-End --> to indicate the
            <emphasis>leftrecset</emphasis> or
            <emphasis>rightrecset</emphasis> has been previously sorted. If
            omitted, <!-- DNT-Start -->NOSORT<!-- DNT-End --> assumes both the <emphasis>leftrecset</emphasis>
            and <emphasis>rightrecset</emphasis> have been previously
            sorted.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">KEYED</emphasis><!-- DNT-End --></entry>

            <entry>Specifies using indexed access into the
            <emphasis>rightrecset</emphasis> (see <!-- DNT-Start -->INDEX<!-- DNT-End -->).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>index</emphasis><!-- DNT-End --></entry>

            <entry>Optional. The name of an <!-- DNT-Start -->INDEX<!-- DNT-End --> into the
            <emphasis>rightrecset</emphasis> for a full-keyed <!-- DNT-Start -->JOIN<!-- DNT-End --> (see
            below). If omitted, indicates the <emphasis>rightrecset</emphasis>
            will always be an <!-- DNT-Start -->INDEX<!-- DNT-End --> (useful when the
            <emphasis>rightrecset</emphasis> is passed in as a parameter to a
            function).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">UNORDERED</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the <!-- DNT-Start -->KEYED<!-- DNT-End --> <!-- DNT-Start -->JOIN<!-- DNT-End --> operation does not
            preserve the sort order of the
            <emphasis>leftrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">LOCAL</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the operation is performed on each supercomputer
            node independently, without requiring interaction with all other
            nodes to acquire data; the operation maintains the distribution of
            any previous <!-- DNT-Start -->DISTRIBUTE<!-- DNT-End -->.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">HASH</emphasis><!-- DNT-End --></entry>

            <entry>Specifies an implicit <!-- DNT-Start -->DISTRIBUTE<!-- DNT-End --> of the
            <emphasis>leftrecset</emphasis> and
            <emphasis>rightrecset</emphasis> across the supercomputer nodes
            based on the <emphasis>joincondition</emphasis> so each node can
            do its job with local data.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">KEEP(n)</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the maximum number of matching records (n) to
            generate into the result set. If omitted, all matches are kept.
            This is useful where there may be many matching pairs and you need
            to limit the number in the result set. <!-- DNT-Start -->KEEP<!-- DNT-End --> is not supported for
            <!-- DNT-Start -->RIGHT<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End -->, <!-- DNT-Start -->RIGHT<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End -->, <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End -->, or <!-- DNT-Start -->FULL<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End -->
            <emphasis>jointypes</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ATMOST</emphasis><!-- DNT-End --></entry>

            <entry>Specifies a maximum number of matching records which, if
            exceeded, eliminates all those matches from the result set. This
            is useful for situations where you need to eliminate all "too many
            matches" record pairs from the result set. <!-- DNT-Start -->ATMOST<!-- DNT-End --> is not supported
            on <!-- DNT-Start -->RIGHT<!-- DNT-End --> <!-- DNT-Start -->ONLY<!-- DNT-End --> or <!-- DNT-Start -->RIGHT<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End --> <emphasis>jointypes</emphasis>. There
            are two forms: <!-- DNT-Start -->ATMOST<!-- DNT-End -->(condition, n) -- maximum is computed only for
            the condition. <!-- DNT-Start -->ATMOST<!-- DNT-End -->(n) -- maximum is computed for the entire
            <emphasis>joincondition</emphasis>, unless <!-- DNT-Start -->KEYED<!-- DNT-End --> is used in the
            <emphasis>joincondition</emphasis>, in which case only the <!-- DNT-Start -->KEYED<!-- DNT-End -->
            expressions are used. When <!-- DNT-Start -->ATMOST<!-- DNT-End --> is specified (and the <!-- DNT-Start -->JOIN<!-- DNT-End --> is
            not full or half-keyed), the <emphasis>joincondition</emphasis>
            and condition may include string field comparisons that use string
            indexing with an asterisk as the upper bound, as in this example:
            J1 := <!-- DNT-Start -->JOIN<!-- DNT-End -->(dsL,dsR, <!-- DNT-Start -->LEFT<!-- DNT-End -->.name[1..*]=<!-- DNT-Start -->RIGHT<!-- DNT-End -->.name[3..*] <!-- DNT-Start -->AND<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End -->.val
            &lt; <!-- DNT-Start -->RIGHT<!-- DNT-End -->.val, T(<!-- DNT-Start -->LEFT<!-- DNT-End -->,<!-- DNT-Start -->RIGHT<!-- DNT-End -->),
            <!-- DNT-Start -->ATMOST<!-- DNT-End -->(<!-- DNT-Start -->LEFT<!-- DNT-End -->.name[1..*]=<!-- DNT-Start -->RIGHT<!-- DNT-End -->.name[3..*],3)); The asterisk
            indicates matching as many characters as necessary to reduce the
            number of candidate matches to below the <!-- DNT-Start -->ATMOST<!-- DNT-End --> number
            (n).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>condition</emphasis><!-- DNT-End --></entry>

            <entry>A portion of the <emphasis>joincondition</emphasis>
            expression.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>n</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the maximum number of matches allowed.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">LIMIT</emphasis><!-- DNT-End --></entry>

            <entry>Specifies a maximum number of matching records which, if
            exceeded, either fails the job, or eliminates all those matches
            from the result set. This is useful for situations where you need
            to eliminate all "too many matches" record pairs from the result
            set. Typically used for <!-- DNT-Start -->KEYED<!-- DNT-End --> and "half-keyed" joins (see below),
            <!-- DNT-Start -->LIMIT<!-- DNT-End --> differs from <!-- DNT-Start -->ATMOST<!-- DNT-End --> primarily by its affect on a <!-- DNT-Start -->LEFT<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End -->
            join, in which a <emphasis>leftrecset</emphasis> record with too
            many matching records would be treated as a non-match by <!-- DNT-Start -->ATMOST<!-- DNT-End -->
            (the <emphasis>leftrecset</emphasis> record would be in the output
            with no matching <emphasis>rightrecset</emphasis> records),
            whereas <!-- DNT-Start -->LIMIT<!-- DNT-End --> would either fail the job entirely, or <!-- DNT-Start -->SKIP<!-- DNT-End --> the
            record (eliminating the <emphasis>leftrecset</emphasis> record
            entirely from the output). If omitted, the default is
            <!-- DNT-Start -->LIMIT<!-- DNT-End -->(10000). The <!-- DNT-Start -->LIMIT<!-- DNT-End --> is applied to the set of records that meet
            the the hard match ("equality") portion of the
            <emphasis>joincondition</emphasis> but before the soft match
            ("non-equality") portion of the <emphasis>joincondition</emphasis>
            is evaluated.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>value</emphasis><!-- DNT-End --></entry>

            <entry>The maximum number of matches allowed; <!-- DNT-Start -->LIMIT<!-- DNT-End -->(0) is
            unlimited.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">SKIP</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies eliminating the matching records that
            exceed the maximum value of the <!-- DNT-Start -->LIMIT<!-- DNT-End --> result instead of failing
            the job.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>transform</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies outputting a single record produced by
            the <emphasis>transform</emphasis> instead of failing the workunit
            (similar to the <!-- DNT-Start -->ONFAIL<!-- DNT-End --> option of the <!-- DNT-Start -->LIMIT<!-- DNT-End --> function).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">FAIL</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies using the <link
            linkend="FAIL"><!-- DNT-Start -->FAIL<!-- DNT-End --></link> action to configure the error message
            when the job fails.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">SKEW</emphasis><!-- DNT-End --></entry>

            <entry>Indicates that you know the data for this join will not be
            spread evenly across nodes (will be skewed after both files have
            been distributed based on the join <emphasis>condition</emphasis>)
            and you choose to override the default by specifying your own
            limit value to allow the job to continue despite the skewing. Only
            valid on non-keyed joins (the <!-- DNT-Start -->KEYED<!-- DNT-End --> option is not present and the
            <emphasis>rightrecset</emphasis> is not an <!-- DNT-Start -->INDEX<!-- DNT-End -->).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>limit</emphasis><!-- DNT-End --></entry>

            <entry>A value between zero (0) and one (1.0 = 100%) indicating
            the maximum percentage of skew to allow before the job fails (the
            default is 0.1 = 10%).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>target</emphasis><!-- DNT-End --></entry>

            <entry>Optional. A value between zero (0) and one (1.0 = 100%)
            indicating the desired maximum percentage of skew to allow (the
            default is 0.1 = 10%).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">THRESHOLD</emphasis><!-- DNT-End --></entry>

            <entry>Indicates the minimum size for a single part of either the
            <emphasis>leftrecset</emphasis> or
            <emphasis>rightrecset</emphasis> before the <!-- DNT-Start -->SKEW<!-- DNT-End --> limit is
            enforced. Only valid on non-keyed joins (the <!-- DNT-Start -->KEYED<!-- DNT-End --> option is not
            present and the <emphasis>rightrecset</emphasis> is not an
            <!-- DNT-Start -->INDEX<!-- DNT-End -->).</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>size</emphasis><!-- DNT-End --></entry>

            <entry>An integer value indicating the minimum number of bytes for
            a single part.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">UNORDERED</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the output record order is not
            significant.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ORDERED</emphasis><!-- DNT-End --></entry>

            <entry>Specifies the significance of the output record
            order.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>bool</emphasis><!-- DNT-End --></entry>

            <entry>When False, specifies the output record order is not
            significant. When True, specifies the default output record
            order.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">STABLE</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the input record order is
            significant.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">UNSTABLE</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Specifies the input record order is not
            significant.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">PARALLEL</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Try to evaluate this activity in
            parallel.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>numthreads</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Try to evaluate this activity using
            <emphasis>numthreads</emphasis> threads.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis role="bold">ALGORITHM</emphasis><!-- DNT-End --></entry>

            <entry>Optional. Override the algorithm used for this
            activity.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start --><emphasis>name</emphasis><!-- DNT-End --></entry>

            <entry>The algorithm to use for this activity. Must be from the
            list of supported algorithms for the <!-- DNT-Start -->SORT<!-- DNT-End --> function's <!-- DNT-Start -->STABLE<!-- DNT-End --> and
            <!-- DNT-Start -->UNSTABLE<!-- DNT-End --> options.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>The following options are mutually exclusive and may only be used to
    the exclusion of the others in this list: <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --> | <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->RIGHT<!-- DNT-End -->
    | [<!-- DNT-Start -->MANY<!-- DNT-End -->] <!-- DNT-Start -->LOOKUP<!-- DNT-End --> | <!-- DNT-Start -->GROUPED<!-- DNT-End --> | <!-- DNT-Start -->ALL<!-- DNT-End --> | <!-- DNT-Start -->NOSORT<!-- DNT-End --> | <!-- DNT-Start -->HASH<!-- DNT-End --></para>

    <para>In addition to this list, the <!-- DNT-Start -->KEYED<!-- DNT-End --> and <!-- DNT-Start -->LOCAL<!-- DNT-End --> options are also
    mutually exclusive with the options listed above, but not to each other.
    When both <!-- DNT-Start -->KEYED<!-- DNT-End --> and <!-- DNT-Start -->LOCAL<!-- DNT-End --> options are specified, only the <!-- DNT-Start -->INDEX<!-- DNT-End --> part(s) on
    each node are accessed by that node.</para>

    <para>Typically, the <emphasis>leftrecset</emphasis> should be larger than
    the <emphasis>rightrecset</emphasis> to prevent skewing problems (because
    <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --> is the default behavior). If the <!-- DNT-Start -->LOOKUP<!-- DNT-End --> or <!-- DNT-Start -->ALL<!-- DNT-End --> options are
    specified, the <emphasis>rightrecset</emphasis> <emphasis
    role="underline">must</emphasis> be small enough to be loaded into memory
    on every node, and the operation is then implicitly <!-- DNT-Start -->LOCAL<!-- DNT-End -->. The <!-- DNT-Start -->ALL<!-- DNT-End --> option
    is impractical if the <emphasis>rightrecset</emphasis> is larger than a
    few thousand records (due to the number of comparisons required). The size
    of the <emphasis>rightrecset</emphasis> is irrelevant in the case of
    "half-keyed" and "full-keyed" <!-- DNT-Start -->JOINs<!-- DNT-End --> (see the Keyed Join discussion
    below).</para>

    <para>Use <!-- DNT-Start -->SMART<!-- DNT-End --> when the right side dataset is likely to be small enough
    to fit in memory, but is not guaranteed to fit.</para>

    <para>If you get an error similar to this: </para>

    <para><programlisting>"error: 1301: Pool memory exhausted:<indexterm>
          <primary>memory exhausted</primary>
        </indexterm><indexterm>
          <primary>Pool memory exhausted</primary>
        </indexterm>..."</programlisting></para>

    <para>this means the <emphasis>rightrecset</emphasis> is too large and a
    <!-- DNT-Start -->LOOKUP<!-- DNT-End --> <!-- DNT-Start -->JOIN<!-- DNT-End --> should not be used. A <!-- DNT-Start -->SMART<!-- DNT-End --> <!-- DNT-Start -->JOIN<!-- DNT-End --> may be a good option in this
    case. </para>
  </sect2>

  <sect2 id="Keyed_Joins">
    <!-- DNT-Start --><title>Keyed Join<indexterm>
        <primary>Keyed JOIN</primary>
      </indexterm>s</title><!-- DNT-End -->

    <para>A "full-keyed" <!-- DNT-Start -->JOIN<!-- DNT-End --> uses the <!-- DNT-Start -->KEYED<!-- DNT-End --> option and the
    <emphasis>joincondition</emphasis> must be based on key fields in the
    <emphasis>index</emphasis>. The join is actually done between the
    <emphasis>leftrecset</emphasis> and the <emphasis>index </emphasis>into
    the <emphasis>rightrecset--</emphasis>the <emphasis>index </emphasis>needs
    the dataset's record pointer (virtual(fileposition)) field to properly
    fetch records from the <emphasis>rightrecset</emphasis>. The typical <!-- DNT-Start -->KEYED<!-- DNT-End -->
    join passes only the <emphasis>rightrecset </emphasis>to the
    <!-- DNT-Start -->TRANSFORM<!-- DNT-End -->.</para>

    <para>If the <emphasis>rightrecset</emphasis> is an <!-- DNT-Start -->INDEX<!-- DNT-End -->, the operation
    is a "half-keyed" <!-- DNT-Start -->JOIN<!-- DNT-End -->. Usually, the <!-- DNT-Start -->INDEX<!-- DNT-End --> in a "half-keyed" <!-- DNT-Start -->JOIN<!-- DNT-End --> contains
    "payload" fields, which frequently eliminates the need to read the base
    dataset. If this is the case, the "payload" <!-- DNT-Start -->INDEX<!-- DNT-End --> does not need to have
    the dataset's record pointer (virtual(fileposition)) field declared. For a
    "half-keyed" <!-- DNT-Start -->JOIN<!-- DNT-End --> the <emphasis>joincondition</emphasis> may use the <!-- DNT-Start -->KEYED<!-- DNT-End -->
    and <!-- DNT-Start -->WILD<!-- DNT-End --> keywords that are available for use in <!-- DNT-Start -->INDEX<!-- DNT-End --> filters,
    only.</para>

    <para>For both types of keyed join, any GROUPing of the base record sets
    is left untouched. See <!-- DNT-Start -->KEYED<!-- DNT-End --> and <!-- DNT-Start -->WILD<!-- DNT-End --> for a discussion of <!-- DNT-Start -->INDEX<!-- DNT-End -->
    filtering.</para>
  </sect2>

  <sect2 id="Join_Logic">
    <!-- DNT-Start --><title>Join Logic</title><!-- DNT-End -->

    <para>The <!-- DNT-Start -->JOIN<!-- DNT-End --> operation follows this logic:</para>

    <para><emphasis role="bold">1. Record distribution/sorting to get match
    candidates on the same nodes.</emphasis></para>

    <para>The <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End -->, <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->RIGHT<!-- DNT-End -->, <!-- DNT-Start -->LOOKUP<!-- DNT-End -->, <!-- DNT-Start -->ALL<!-- DNT-End -->, <!-- DNT-Start -->NOSORT<!-- DNT-End -->, <!-- DNT-Start -->KEYED<!-- DNT-End -->,
    <!-- DNT-Start -->HASH<!-- DNT-End -->, and <!-- DNT-Start -->LOCAL<!-- DNT-End --> options indicate how this happens. These options are
    mutually exclusive; only one may be specified, and <!-- DNT-Start -->PARTITION<!-- DNT-End --> <!-- DNT-Start -->LEFT<!-- DNT-End --> is the
    default. <!-- DNT-Start -->SKEW<!-- DNT-End --> and <!-- DNT-Start -->THRESHOLD<!-- DNT-End --> may modify the requested behaviour. <!-- DNT-Start -->LOOKUP<!-- DNT-End -->
    also has the additional effect of deduping the
    <emphasis>rightrecset</emphasis> by the
    <emphasis>joincondition</emphasis>.</para>

    <para><emphasis role="bold">2. Record matching.</emphasis></para>

    <para>The <emphasis>joincondition</emphasis>, <!-- DNT-Start -->LIMIT<!-- DNT-End -->, and <!-- DNT-Start -->ATMOST<!-- DNT-End --> determine
    how this is done.</para>

    <para><emphasis role="bold">3. Determine what matches to pass to
    </emphasis><emphasis role="bold">transform</emphasis><emphasis
    role="bold">.</emphasis></para>

    <para>The <emphasis>jointype</emphasis> determines this.</para>

    <para><emphasis role="bold">4. Generate output records through the
    <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function.</emphasis></para>

    <para>The implicit or explicit <emphasis>transform</emphasis> parameter
    determines this.</para>

    <para><emphasis role="bold">5. Filter output records with
    <!-- DNT-Start -->SKIP<!-- DNT-End -->.</emphasis></para>

    <para>If the <emphasis>transform</emphasis> for a record pair results in a
    <!-- DNT-Start -->SKIP<!-- DNT-End -->, then the output record is not counted towards any <!-- DNT-Start -->KEEP<!-- DNT-End --> option
    totals.</para>

    <para><emphasis role="bold">6. Limit output records with
    <!-- DNT-Start -->KEEP<!-- DNT-End -->.</emphasis></para>

    <para>Any output records for a given <emphasis>leftrecset</emphasis>
    record over and above the permitted <!-- DNT-Start -->KEEP<!-- DNT-End --> value are discarded. In a <!-- DNT-Start -->FULL<!-- DNT-End -->
    <!-- DNT-Start -->OUTER<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->JOINS<!-- DNT-End --> <!-- DNT-Start -->FULL<!-- DNT-End --> <!-- DNT-Start -->OUTER<!-- DNT-End --></primary>
      </indexterm> join, <emphasis>rightrecset</emphasis> records that match
    no record are treated as if they all matched different default
    <emphasis>leftrecset</emphasis> records (that is, the <!-- DNT-Start -->KEEP<!-- DNT-End --> counter is
    reset for each one).</para>
  </sect2>

  <sect2 id="TRANSFORM_Function_Requirements_Join">
    <!-- DNT-Start --><title>TRANSFORM Function Requirements - JOIN</title><!-- DNT-End -->

    <para>The <emphasis>transform</emphasis> function<indexterm>
        <primary>transform function</primary>
      </indexterm> must take at least one or two parameters: a <!-- DNT-Start -->LEFT<!-- DNT-End --> record
    formatted like the <emphasis>leftrecset</emphasis>, and/or a <!-- DNT-Start -->RIGHT<!-- DNT-End --> record
    formatted like the <emphasis>rightrecset</emphasis> (which may be of
    different formats). The format of the resulting record set need not be the
    same as either of the inputs.</para>
  </sect2>

  <sect2 id="Join_Types">
    <!-- DNT-Start --><title>Join Types: Two Datasets</title><!-- DNT-End -->

    <!-- DNT-Start --><para>The following <emphasis>jointypes</emphasis> produce the following
    types of results, based on the records matching produced by the
    <emphasis>joincondition</emphasis>:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="82.00pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start -->inner (default)<!-- DNT-End --></entry>

            <entry>Only those records that exist in both the
            <emphasis>leftrecset</emphasis> and
            <emphasis>rightrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->LEFT OUTER<indexterm>
                <primary>LEFT OUTER</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>At least one record for every record in the
            <emphasis>leftrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->RIGHT OUTER<indexterm>
                <primary>RIGHT OUTER</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>At least one record for every record in the
            <emphasis>rightrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->FULL OUTER<indexterm>
                <primary>FULL OUTER</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>At least one record for every record in the
            <emphasis>leftrecset</emphasis> and
            <emphasis>rightrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->LEFT ONLY<indexterm>
                <primary>LEFT ONLY</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>One record for each <emphasis>leftrecset</emphasis> record
            with no match in the <emphasis>rightrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->RIGHT ONLY<indexterm>
                <primary>RIGHT ONLY</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>One record for each <emphasis>rightrecset </emphasis>record
            with no match in the <emphasis>leftrecset</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->FULL ONLY<indexterm>
                <primary>FULL ONLY</primary>
              </indexterm><!-- DNT-End --></entry>

            <entry>One record for each <emphasis>leftrecset</emphasis> and
            <emphasis>rightrecset</emphasis> record with no match in the
            opposite record set.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Example:</para>

    <!-- DNT-Start --><programlisting>outrec := RECORD
  people.id;
  people.firstname;
  people.lastname;
END;

RT_folk := JOIN(people(firstname[1] = 'R'),
                people(lastname[1] = 'T'),
                LEFT.id=RIGHT.id,
                TRANSFORM(outrec,SELF := LEFT));
OUTPUT(RT_folk);

//*********************** Half KEYED JOIN example:
peopleRecord := RECORD
  INTEGER8 id;
  STRING20 addr;
END;
peopleDataset := DATASET([{3000,'LONDON'},{3500,'SMITH'},
                          {30,'TAYLOR'}], peopleRecord);
PtblRec doHalfJoin(peopleRecord l) := TRANSFORM
  SELF := l;
END;
FilledRecs3 := JOIN(peopleDataset, SequenceKey,
                    LEFT.id=RIGHT.sequence,doHalfJoin(LEFT));
FilledRecs4 := JOIN(peopleDataset, AlphaKey,
                    LEFT.addr=RIGHT.Lname,doHalfJoin(LEFT));

//******************* Full KEYED JOIN example:
PtblRec := RECORD
  INTEGER8 seq;
  STRING2  State;
  STRING20 City;
  STRING25 Lname;
  STRING15 Fname;
END;
PtblRec Xform(person L, INTEGER C) := TRANSFORM
  SELF.seq      := C;
  SELF.State    := L.per_st;
  SELF.City     := L.per_full_city;
  SELF.Lname    := L.per_last_name;
  SELF.Fname    := L.per_first_name;
END;
Proj := PROJECT(Person(per_last_name[1]=per_first_name[1]),
                Xform(LEFT,COUNTER<indexterm>
        <primary>COUNTER</primary>
      </indexterm>));
PtblOut := OUTPUT(Proj,,'~RTTEMP::TestKeyedJoin',OVERWRITE);

Ptbl := DATASET('RTTEMP::TestKeyedJoin',
                {PtblRec,UNSIGNED8 __fpos {virtual(fileposition)}},
                FLAT);
AlphaKey := INDEX(Ptbl,{lname,fname,__fpos},
                  '~RTTEMPkey::lname.fname');
SeqKey := INDEX(Ptbl,{seq,__fpos},'~RTTEMPkey::sequence');

Bld1 := BUILD(AlphaKey ,OVERWRITE);
Bld2 := BUILD(SeqKey,OVERWRITE);
peopleRecord := RECORD
  INTEGER8 id;
  STRING20 addr;
END;
peopleDataset := DATASET([{3000,'LONDON'},{3500,'SMITH'},
                          {30,'TAYLOR'}], peopleRecord);
joinedRecord := RECORD
  PtblRec;
  peopleRecord;
END;
joinedRecord doJoin(peopleRecord l, Ptbl r) := TRANSFORM
 SELF := l;
 SELF := r;
END;

FilledRecs1 := JOIN(peopleDataset, Ptbl,LEFT.id=RIGHT.seq,
                    doJoin(LEFT,RIGHT), KEYED(SeqKey));
FilledRecs2 := JOIN(peopleDataset, Ptbl,LEFT.addr=RIGHT.Lname,
                    doJoin(LEFT,RIGHT), KEYED(AlphaKey));
SEQUENTIAL(PtblOut,Bld1,Bld2,OUTPUT(FilledRecs1),OUTPUT(FilledRecs2))
</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="JOIN_Set_of_Datasets">
    <!-- DNT-Start --><title>JOIN Set of Datasets</title><!-- DNT-End -->

    <para><emphasis role="bold"><!-- DNT-Start -->JOIN<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->JOIN<!-- DNT-End --></primary>
      </indexterm><indexterm>
        <primary><!-- DNT-Start -->JOIN<!-- DNT-End --> Set</primary>
      </indexterm>(</emphasis><emphasis>setofdatasets, joincondition,
    transform</emphasis>,<emphasis role="bold"> <!-- DNT-Start -->SORTED<!-- DNT-End --><indexterm>
        <primary><!-- DNT-Start -->SORTED<!-- DNT-End --></primary>
      </indexterm>( </emphasis><emphasis>fields</emphasis><emphasis
    role="bold">) [</emphasis><emphasis>, jointype</emphasis><emphasis
    role="bold">] </emphasis><emphasis role="bold">[, <!-- DNT-Start -->UNORDERED<!-- DNT-End --> |
    <!-- DNT-Start -->ORDERED<!-- DNT-End -->(</emphasis> <emphasis>bool </emphasis><emphasis role="bold">) ] [,
    <!-- DNT-Start -->STABLE<!-- DNT-End --> | <!-- DNT-Start -->UNSTABLE<!-- DNT-End --> ] [, <!-- DNT-Start -->PARALLEL<!-- DNT-End --> [ (</emphasis> <emphasis>numthreads
    </emphasis><emphasis role="bold">) ] ] [, <!-- DNT-Start -->ALGORITHM<!-- DNT-End -->(</emphasis>
    <emphasis>name </emphasis><emphasis role="bold">) ] )</emphasis></para>

    <para><emphasis role="bold"><emphasis>The second form of <!-- DNT-Start -->JOIN<!-- DNT-End --> is similar
    to the <!-- DNT-Start -->MERGEJOIN<!-- DNT-End --> function<indexterm>
        <primary><!-- DNT-Start -->MERGEJOIN<!-- DNT-End --> function</primary>
      </indexterm><indexterm>
        <primary><!-- DNT-Start -->JOIN<!-- DNT-End --> function</primary>
      </indexterm> in that it takes a <!-- DNT-Start -->SET<!-- DNT-End --> <!-- DNT-Start -->OF<!-- DNT-End --> <!-- DNT-Start -->DATASETs<!-- DNT-End --> as its first parameter.
    This allows the possibility of joining more than two datasets in a single
    operation.</emphasis></emphasis></para>
  </sect2>

  <sect2 id="Matching_Logic_joincondition">
    <!-- DNT-Start --><title>Record Matching Logic</title><!-- DNT-End -->

    <para>The record matching <emphasis>joincondition</emphasis> may contain
    two parts: a <!-- DNT-Start -->STEPPED<!-- DNT-End --> condition that may optionally be <!-- DNT-Start -->ANDed<!-- DNT-End --> with
    non-<!-- DNT-Start -->STEPPED<!-- DNT-End --> conditions. The <!-- DNT-Start -->STEPPED<!-- DNT-End --> expression contains leading equality
    expressions of the <emphasis>fields</emphasis> from the <!-- DNT-Start -->SORTED<!-- DNT-End --> option
    (trailing components may be range comparisons if the range values are
    independent of the <!-- DNT-Start -->LEFT<!-- DNT-End --> and <!-- DNT-Start -->RIGHT<!-- DNT-End --> rows), <!-- DNT-Start -->ANDed<!-- DNT-End --> together, using <!-- DNT-Start -->LEFT<!-- DNT-End --> and
    <!-- DNT-Start -->RIGHT<!-- DNT-End --> as dataset qualifiers. If not present, the <!-- DNT-Start -->STEPPED<!-- DNT-End --> condition is
    deduced from the <emphasis>fields</emphasis> specified by the <!-- DNT-Start -->SORTED<!-- DNT-End -->
    option.</para>

    <para>The order of the datasets within the
    <emphasis>setofdatasets</emphasis> can be significant to the way the
    <emphasis>joincondition</emphasis> is evaluated. The
    <emphasis>joincondition</emphasis> is duplicated between adjacent pairs of
    datasets, which means that this <emphasis>joincondition</emphasis>:</para>

    <!-- DNT-Start --><programlisting>       LEFT.field = RIGHT.field</programlisting><!-- DNT-End -->

    <para>when applied against a <emphasis>setofdatasets </emphasis>containing
    three datasets, is logically equivalent to:</para>

    <!-- DNT-Start --><programlisting>       ds1.field = ds2.field AND ds2.field = ds3.field</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="TRANSFORM_Function_Requirements_parameters">
    <!-- DNT-Start --><title>TRANSFORM Function Requirements - JOIN setofdatasets<indexterm>
        <primary>JOIN setofdatasets</primary>
      </indexterm></title><!-- DNT-End -->

    <!-- DNT-Start --><para>The <emphasis>transform</emphasis> function must take at least one
    parameter which must take either of two forms:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="87.10pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start -->LEFT<!-- DNT-End --></entry>

            <entry>formatted like any of the
            <emphasis>setofdatasets</emphasis>. This indicates the first
            dataset in the <emphasis>setofdatasets</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->ROWS(LEFT)<!-- DNT-End --></entry>

            <entry>formatted like any of the
            <emphasis>setofdatasets</emphasis>. This indicates a record set
            made up of all records from any dataset in the
            <emphasis>setofdatasets</emphasis> that match the
            <emphasis>joincondition</emphasis>--this may not include all the
            datasets in the <emphasis>setofdatasets</emphasis>, depending on
            which <emphasis>jointype</emphasis> is specified.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>The format of the resulting output record set must be the same as
    the input datasets.</para>
  </sect2>

  <sect2 id="Join_Types_joincondition">
    <!-- DNT-Start --><title>Join Types: setofdatasets</title><!-- DNT-End -->

    <!-- DNT-Start --><para>The following <emphasis>jointypes</emphasis> produce the following
    types of results, based on the records matching produced by the
    <emphasis>joincondition</emphasis>:</para><!-- DNT-End -->

    <informaltable colsep="1" frame="all" rowsep="1">
      <tgroup cols="2">
        <colspec colwidth="94.80pt" />

        <colspec />

        <tbody>
          <row>
            <entry><!-- DNT-Start -->INNER<!-- DNT-End --></entry>

            <entry>This is the default if no <emphasis>jointype</emphasis> is
            specified. Only those records that exist in all datasets in the
            <emphasis>setofdatasets</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->LEFT OUTER<!-- DNT-End --></entry>

            <entry>At least one record for every record in the first dataset
            in the <emphasis>setofdatasets</emphasis>.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->LEFT ONLY<!-- DNT-End --></entry>

            <entry>One record for every record in the first dataset in the
            <emphasis>setofdatasets</emphasis> for which there is no match in
            any of the subsequent datasets.</entry>
          </row>

          <row>
            <entry><!-- DNT-Start -->MOFN(min [,max])<!-- DNT-End --></entry>

            <entry>One record for every record with matching records in min
            number of adjacent datasets within the
            <emphasis>setofdatasets</emphasis>. If max is specified, the
            record is not included if max number of dataset matches are
            exceeded.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Example:</para>

    <!-- DNT-Start --><programlisting>Rec := RECORD,MAXLENGTH(4096)
  STRING1  Letter;
  UNSIGNED1    DS;
  UNSIGNED1    Matches   := 0;
  UNSIGNED1    LastMatch := 0;
  SET OF UNSIGNED1 MatchDSs  := [];
END;

ds1 := DATASET([{'A',1},{'B',1},{'C',1},{'D',1},{'E',1}],Rec);
ds2 := DATASET([{'A',2},{'B',2},{'H',2},{'I',2},{'J',2}],Rec);
ds3 := DATASET([{'B',3},{'C',3},{'M',3},{'N',3},{'O',3}],Rec);
ds4 := DATASET([{'A',4},{'B',4},{'R',4},{'S',4},{'T',4}],Rec);
ds5 := DATASET([{'B',5},{'V',5},{'W',5},{'X',5},{'Y',5}],Rec);
SetDS := [ds1,ds2,ds3,ds4,ds5];

Rec XF(Rec L,DATASET(Rec) Matches) := TRANSFORM
  SELF.Matches   := COUNT(Matches);
  SELF.LastMatch := MAX(Matches,DS);
  SELF.MatchDSs  := SET(Matches,DS);
  SELF := L;
END;
j1 := JOIN(SetDS,
           STEPPED(LEFT.Letter=RIGHT.Letter),
           XF(LEFT,ROWS(LEFT)),SORTED(Letter));
j2 := JOIN(SetDS,
           STEPPED(LEFT.Letter=RIGHT.Letter),
           XF(LEFT,ROWS(LEFT)),SORTED(Letter),LEFT OUTER);
j3 := JOIN(SetDS,
           STEPPED(LEFT.Letter=RIGHT.Letter),  
           XF(LEFT,ROWS(LEFT)),SORTED(Letter),LEFT ONLY);
j4 := JOIN(SetDS,
           STEPPED(LEFT.Letter=RIGHT.Letter),
           XF(LEFT,ROWS(LEFT)),SORTED(Letter),MOFN(3));
j5 := JOIN(SetDS,
           STEPPED(LEFT.Letter=RIGHT.Letter),
           XF(LEFT,ROWS(LEFT)),SORTED(Letter),MOFN(3,4));

OUTPUT(j1);
OUTPUT(j2);
OUTPUT(j3);
OUTPUT(j4);
OUTPUT(j5);
</programlisting><!-- DNT-End -->

    <para>See Also: <link linkend="TRANSFORM_Structure"><!-- DNT-Start -->TRANSFORM<!-- DNT-End -->
    Structure</link>, <link linkend="RECORD_Structure"><!-- DNT-Start -->RECORD<!-- DNT-End -->
    Structure</link>, <link linkend="SKIP"><!-- DNT-Start -->SKIP<!-- DNT-End --></link>, <link
    linkend="STEPPED"><!-- DNT-Start -->STEPPED<!-- DNT-End --></link>, <link
    linkend="KEYED-WILD"><!-- DNT-Start -->KEYED<!-- DNT-End -->/<!-- DNT-Start -->WILD<!-- DNT-End --></link>, <link
    linkend="MERGEJOIN"><!-- DNT-Start -->MERGEJOIN<!-- DNT-End --></link></para>
  </sect2>
</sect1>
