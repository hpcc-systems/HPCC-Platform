<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en_US" xml:base="../">
  <bookinfo>
    <title>HPCC JDBC Driver</title>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/redswooshWithLogo3.jpg" />
      </imageobject>
    </mediaobject>

    <author>
      <surname>Boca Raton Documentation Team</surname>
    </author>

    <legalnotice>
      <para>We welcome your comments and feedback about this document via
      email to <email>docfeedback@hpccsystems.com</email></para>

      <para>Please include <emphasis role="bold">Documentation
      Feedback</emphasis> in the subject line and reference the document name,
      page numbers, and current Version Number in the text of the
      message.</para>

      <para>LexisNexis and the Knowledge Burst logo are registered trademarks
      of Reed Elsevier Properties Inc., used under license.</para>

      <para>HPCC Systems<superscript>®</superscript> is a registered trademark
      of LexisNexis Risk Data Management Inc.</para>

      <para>Other products, logos, and services may be trademarks or
      registered trademarks of their respective companies.</para>

      <para>All names and example data used in this manual are fictitious. Any
      similarity to actual persons, living or dead, is purely
      coincidental.</para>

      <para>
        <!--Release Information is used for running footers only. The ID attribute in version.xml is FooterInfo
Date is used as the dateline/version number in the title page. The ID attribute in version.xml is DateVer-->

        <!--
Copyright is used for the copyright line on title page. The ID attribute is CopyRight-->
      </para>
    </legalnotice>

    <xi:include href="common/Version.xml"
                xpointer="xpointer(//*[@id='FooterInfo'])"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <xi:include href="common/Version.xml"
                xpointer="xpointer(//*[@id='DateVer'])"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <corpname>HPCC Systems<superscript>®</superscript></corpname>

    <xi:include href="common/Version.xml"
                xpointer="xpointer(//*[@id='Copyright'])"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <mediaobject role="logo">
      <imageobject>
        <imagedata fileref="images/LN_Rightjustified.jpg" />
      </imageobject>
    </mediaobject>
  </bookinfo>

  <chapter>
    <title>Introduction</title>

    <para>Java Database Connectivity (<emphasis role="bold">JDBC</emphasis>)
    is a standard Java API that enables Java applications or client tools that
    support JDBC to access data from a<emphasis> presumably
    </emphasis>SQL-compliant data source via the SQL language.</para>

    <para><emphasis role="bold">JDBC</emphasis> makes it possible to write a
    single database application that can run on different platforms and
    interact with different database management systems.</para>

    <para>Currently there are JDBC Drivers available for interaction with many
    popular data sources; now the HPCC platform is available as a data
    source.</para>

    <para>The HPCC JDBC Driver exposes HPCC logical files as RDB
    tables.</para>

    <para><itemizedlist mark="bullet">
        <listitem>
          <para>HPCC Logical File &lt;-&gt; RDB Table</para>
        </listitem>

        <listitem>
          <para>HPCC Record Definition Fields &lt;-&gt; RDB Table
          Columns</para>
        </listitem>

        <listitem>
          <para>HPCC Published query &lt;-&gt; RDB Stored Procedure</para>
        </listitem>

        <listitem>
          <para>Provides access to HPCC system data and RDB metadata</para>
        </listitem>

        <listitem>
          <para>Supports subset of SQL syntax</para>
        </listitem>

        <listitem>
          <para>Read-only operations supported</para>
        </listitem>

        <listitem>
          <para>Non-transactional</para>
        </listitem>

        <listitem>
          <para>Provides means for utilizing HPCC index files for faster
          reads.</para>
        </listitem>
      </itemizedlist><figure>
        <title>An example SQL Client interface connected to an HPCC Platform
        with the JDBC driver</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/jdbc01.jpg" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </chapter>

  <chapter>
    <title>Installation</title>

    <para>The HPCC JDBC driver is distributed in a self-contained JAVA jar
    file.</para>

    <para>Follow the instructions for your SQL client for installation.</para>

    <para>To utilize your HPCC platform, use the configuration settings in the
    next section. The manner in which you define these settings is dependent
    on your SQL client.</para>

    <para>The driver's full class path is:</para>

    <para><emphasis
    role="bold">org.hpccsystems.jdbcdriver.HPCCDriver</emphasis></para>

    <variablelist>
      <varlistentry>
        <term>Note:</term>

        <listitem>
          <para>WsSQL must be installed on the target HPCC Platform to utilize
          a JDBC connection. See <ulink
          url="???">http://hpccsystems.com/permlink/wssql</ulink> for
          details.</para>

          <para></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </chapter>

  <chapter>
    <title>Configuration</title>

    <para>The HPCC JDBC driver supports the following configuration
    attributes:</para>

    <para><informaltable align="left" colsep="1" frame="all" rowsep="1">
        <tgroup cols="4">
          <colspec colwidth="120pt" />

          <colspec colwidth="3*" />

          <colspec colwidth="1*" />

          <colspec colwidth="35pt" />

          <thead>
            <row>
              <entry>Property</entry>

              <entry>Description</entry>

              <entry>Default Value</entry>

              <entry>Req.</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>ServerAddress</entry>

              <entry>Target HPCC ESP Address (used to contact WsSQL).</entry>

              <entry>“localhost”</entry>

              <entry>Yes</entry>
            </row>

            <row>
              <entry>WsSQLPort:</entry>

              <entry>WsSQL port (WsSQL is a web service which must be
              installed with the HPCC platform. It typically runs on port
              8015).</entry>

              <entry>8015</entry>

              <entry>Yes</entry>
            </row>

            <row>
              <entry>WsECLWatchAddress</entry>

              <entry>Target HPCC WsECLWatch address</entry>

              <entry>ServerAddress Value</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>WsECLWatchPort</entry>

              <entry>Target HPCC WsECLWatch port</entry>

              <entry>8010</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>username</entry>

              <entry>User name on Target HPCC, if needed</entry>

              <entry>“”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>password</entry>

              <entry>Password on Target HPCC, if needed</entry>

              <entry>“”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>PageSize</entry>

              <entry>Max Number of HPCC files or HPCC published queries
              reported as result of GetTables, or GetProcs</entry>

              <entry>100</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>ConnectTimeoutMilli</entry>

              <entry align="left">Timeout value to establish connection to
              HPCC (in milliseconds)</entry>

              <entry>1000</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>ReadTimeoutMilli</entry>

              <entry align="left">HPCC Connection <emphasis
              role="bold">read</emphasis> timeout value (in
              milliseconds)</entry>

              <entry>1500</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>EclResultLimit</entry>

              <entry>Max result records returned (use ALL to return all
              records)</entry>

              <entry>100</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>LazyLoad</entry>

              <entry>Fetch HPCC file and query metadata on-demand (not at
              connect time)</entry>

              <entry>“true”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TargetCluster</entry>

              <entry>ECLDirect target cluster</entry>

              <entry>“hthor”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>QuerySet</entry>

              <entry>Target published query (stored procedure)
              QuerySet</entry>

              <entry>“hthor”</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TraceToFile</entry>

              <entry align="left">When true, tracing is directed to file
              <emphasis role="bold">./HPCCJDBC.log</emphasis>, otherwise trace
              is sent to standard output (stdout)</entry>

              <entry>"false"</entry>

              <entry>No</entry>
            </row>

            <row>
              <entry>TraceLevel</entry>

              <entry align="left">Trace Logging level, as defined in
              java.util.logging.level. Valid values: ALL, SEVERE, WARNING,
              INFO, FINEST, OFF</entry>

              <entry>INFO</entry>

              <entry>No</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>These configuration settings are used when creating an HPCC JDBC
    connection.</para>

    <para>They can be passed to the JDBC driver using the JDBC connection URL
    or as part of the connection properties object. When passed through the
    connection URL, the values must be URL-encoded.</para>

    <para>The connection URL syntax is as follows:</para>

    <programlisting>jdbc:hpcc[;urlencodedkey=urlencodedvalue]*</programlisting>

    <variablelist>
      <varlistentry>
        <term>Note:</term>

        <listitem>
          <para>The <emphasis role="bluebold">jdbc:hpcc</emphasis> prefix is
          required.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </chapter>

  <chapter>
    <title>Using HPCC as a JDBC data source</title>

    <para>Once connected, the HPCC JDBC driver will process submitted SQL
    statements and generate dynamic ECL code. The code is submitted to and
    executed by your HPCC Platform. The resultset is returned to your
    application or SQL client.</para>

    <para><variablelist>
        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>The HPCC JDBC driver <emphasis role="bold">only supports
            files which contain the record definition in the logical file’s
            metadata.</emphasis> Sprayed files do not contain this metadata.
            This metadata exists on any file or index which is written to the
            HPCC Distributed File System. Sprayed data files typically undergo
            some processing and an OUTPUT of the transformed data to disk
            before use, so this should not interfere with the driver's
            usefulness.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <para></para>

    <para>In addition, you can utilize indexes on the HPCC in one of two
    ways:</para>

    <orderedlist numeration="arabic">
      <listitem>
        <para>Provide SQL hints to tell driver to use a specific index for
        your query.</para>

        <para>For example:</para>

        <programlisting>USEINDEX(TutorialPersonByZipIndex)</programlisting>
      </listitem>

      <listitem>
        <para>Specify the related indexes in the HPCC logical file
        description.</para>
      </listitem>
    </orderedlist>

    <sect1 role="nobrk">
      <title>Index Annotations</title>

      <para>The JDBC driver attempts to perform index based reads whenever
      possible. However, in order to take advantage of index reads, the target
      HPCC files need to be annotated with the pertinent index file names.
      This is accomplished by adding the following key/value entry on the
      file’s description using ECL Watch.</para>

      <para>From a logical file’s details page, enter the information in the
      Description entry box, then press the <emphasis role="bold">Save
      Description</emphasis> button.</para>

      <para>This information is used by the driver to decide if an index fetch
      is possible for a query on the base file.</para>

      <sect2>
        <title><emphasis role="bold">On source file:</emphasis></title>

        <para><emphasis role="bold">XDBC:RelIndexes=
        [</emphasis><emphasis><emphasis
        role="bold"><emphasis>fullLogicalFilename1</emphasis></emphasis></emphasis><emphasis
        role="bold">;<emphasis>
        fullLogicalFilename2</emphasis></emphasis><emphasis
        role="bold">]</emphasis></para>

        <para></para>

        <para>Example:</para>

        <programlisting>XDBC:RelIndexes=[tutorial::yn::peoplebyzipindex;
                 tutorial::yn::peoplebyzipindex2;
                 tutorial::yn::peoplebyzipindex3]</programlisting>

        <para>In this example, the source file has three indexes
        available.</para>

        <para></para>
      </sect2>

      <sect2>
        <title><emphasis role="bold">On the index file:</emphasis></title>

        <para><emphasis
        role="bold">XDBC:PosField=[</emphasis><emphasis>indexPositionFieldName</emphasis><emphasis
        role="bold">]</emphasis></para>

        <para></para>

        <para>Example:</para>

        <programlisting>XDBC:PosField=[fpos]</programlisting>

        <para>The FilePosition field (fpos) can have any name, so it must be
        specified in the metadata so the driver knows which field is the
        fileposition.</para>

        <para>Simply enter the information in the description entry box, then
        press the <emphasis role="bold">Save Description</emphasis>
        button.</para>

        <para><emphasis role="bold">Note:</emphasis> You should enter this
        information BEFORE publishing any query using the data file or
        indexes. Published queries lock the file and would prevent editing the
        metadata.</para>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Supported SQL</title>

    <sect1 role="nobrk">
      <title>CALL</title>

      <para><emphasis role="bold">Call
      </emphasis><emphasis>queryname</emphasis><emphasis role="bold">
      ([</emphasis><emphasis>param list</emphasis><emphasis
      role="bold">])</emphasis></para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="113.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>queryName</entry>

                <entry>The published query name or alias</entry>
              </row>

              <row>
                <entry>paramList</entry>

                <entry>The parameters exposed by the published query
                (comma-separated)</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Call executes a published ECL query as if it were a stored
      procedure.</para>

      <para>Example:</para>

      <programlisting>Call SearchPeopleByZipService (‘33024’)</programlisting>

      <para></para>
    </sect1>

    <sect1>
      <title>SELECT</title>

      <para><emphasis role="bold">select [</emphasis>distinct<emphasis
      role="bold">]</emphasis> <emphasis>colummList</emphasis> <emphasis
      role="bold">from</emphasis> <emphasis>tableList </emphasis><emphasis>
      </emphasis><emphasis role="bold">[</emphasis>USE
      INDEX<emphasis>(indexFileName</emphasis> | 0
      <emphasis>)</emphasis><emphasis role="bold">]</emphasis></para>

      <para><emphasis role="bold">[where</emphasis>
      <emphasis>logicalExpression</emphasis><emphasis role="bold">]</emphasis>
      <emphasis role="bold">[group by</emphasis>
      <emphasis>columnList<superscript>1</superscript></emphasis><emphasis
      role="bold">]</emphasis> <emphasis role="bold">[having</emphasis>
      <emphasis>logicalExpression<superscript>2</superscript></emphasis><emphasis
      role="bold">]</emphasis></para>

      <para><emphasis role="bold">[order by</emphasis>
      <emphasis>columnList<superscript>1</superscript> </emphasis>[asc |
      desc]<emphasis> </emphasis>] <emphasis
      role="bold">[LIMIT</emphasis><emphasis> limitNumber</emphasis><emphasis
      role="bold">]</emphasis></para>

      <variablelist>
        <varlistentry>
          <term>NOTE:</term>

          <listitem>
            <para>Identifiers can be unquoted or within double quotes, literal
            string values must be single quoted.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="123.45pt" />

            <colspec />

            <tbody>
              <row>
                <entry><emphasis>columnList</emphasis></entry>

                <entry>columnreference1[,columnreference2,columnreference3,...,columnreference<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The column(s) to return (comma-separated list). In
                addition, these aggregate functions are supported : COUNT,
                SUM, MIN, MAX, and AVG. These work in a similar manner as
                their ECL counterparts.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>columnreference</entry>

                <entry>[tablename.]columnname[ [AS] alias ]</entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>distinct</emphasis></entry>

                <entry>[distinct] col1, col2,...
                col<emphasis>n</emphasis></entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry>The result set will only contain distinct (unique)
                values.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>tableList</emphasis></entry>

                <entry>tableref1[,tableref2,tableref3,...,tableref<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>One or more tables, separated by commas.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">NOTE: </emphasis>A table list
                with multiple tables creates an (one or more) implicit inner
                join using the where clause logical expression as the join
                condition which must contain an equality condition.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>tableref</entry>

                <entry>tableName[ [AS] alias ]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The Name of the table as referenced, optionally
                defining its alias.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>alias</emphasis></entry>

                <entry>The alias used to refer to the corresponding table or
                field reference.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>logicalExpression</emphasis></entry>

                <entry>Logical expression based on standard SQL filtering
                syntax. Compound operators such as NOT IN or IS NULL must be
                in ALL CAPS or all lower case and can have one and only one
                space between the words. (NOT IN, not in, IS NULL, is null,
                etc.)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>BOOLEAN Only supports <emphasis>True</emphasis> or
                <emphasis>False</emphasis>, do not use Y, N, 0, or 1.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Valid
                operators:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>= Equal (e.g., age=33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;&gt; Not equal (e.g., age &lt;&gt;33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt; Greater than (e.g., age &gt;55)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt; Less than (e.g., age &lt; 18)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt;= Greater than or equal (e.g., age &gt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;= Less than or equal (e.g., age &lt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IN(value1,value2,...,value<emphasis>n</emphasis>) where
                values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>NOT IN(value1,value2,...,value<emphasis>n</emphasis>)
                where values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IS NULL</entry>
              </row>

              <row>
                <entry><emphasis>limitNumber</emphasis></entry>

                <entry>The number of rows to return. This overrides the
                driver's configuration attribute (EclResultLimit ) but cannot
                be set to ALL.</entry>
              </row>

              <row>
                <entry></entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>1</superscript>Aliasing not
                supported</entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>2</superscript>Can only contain references
                to aggregate functions<superscript> </superscript>if used with
                <emphasis>having</emphasis> clause.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Aggregate functions can only be expressed in
                logicalExpressions by using <emphasis>Group by </emphasis>and
                <emphasis>having</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Examples:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList where Sum(F1 &gt; 100) /* is
                NOT SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList Group byF1 Haveing Sum (F1 &gt;
                100) /* IS SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <programlisting>Select fname, lname, state from TutorialPerson where 
   state=’FL’ OR (lname='Smith' and fname='Joe') 
//returns data that looks like this:
John Doe FL 
Jim Smith FL 
Jane Row FL
Joe Smith CA

Select fname, lname, state from TutorialPerson where state=’FL’ AND lname &lt;&gt; ‘Smith’
//returns data that looks like this:
John Doe FL 
Jane Row FL </programlisting>

      <para>The driver supports SQL index hints, which gives the SQL user the
      option to specify the most appropriate HPCC index for the current SQL
      query. This also allows you to disable the use of an index.</para>

      <para><emphasis role="bold">select
      </emphasis><emphasis>columnList</emphasis> <emphasis role="bold"> from
      </emphasis><emphasis>tableName </emphasis><emphasis role="bold">USE
      INDEX(</emphasis><emphasis>hpcc::index::file::name</emphasis><emphasis
      role="bold">) where </emphasis><emphasis>logicalExprssions
      </emphasis></para>

      <para><emphasis role="bold">USE INDEX(0) </emphasis>forces the system to
      avoid seeking an index for the current query.</para>

      <para>Example:</para>

      <programlisting>Select fname, lname, zip, state from TutorialPerson 
USEINDEX(TutorialPersonByZipIndex)where zip=’33024’

//returns data that looks like this:
John Doe FL 33024
Jim Smith FL 33024
Jane Row FL 33024
</programlisting>

      <para></para>
    </sect1>

    <sect1>
      <title>SELECT JOIN</title>

      <para><emphasis role="bold">select
      </emphasis><emphasis>colummList</emphasis> <emphasis
      role="bold">from</emphasis> <emphasis>tableName <emphasis
      role="bold">[</emphasis></emphasis><emphasis
      role="bold">as</emphasis><emphasis> alias<emphasis
      role="bold">]</emphasis></emphasis><emphasis role="bold">
      </emphasis></para>

      <para><emphasis role="bold">[</emphasis>&lt;outer | inner &gt; <emphasis
      role="bold">JOIN </emphasis><emphasis>join TableName
      </emphasis><emphasis role="bold">[ as
      </emphasis><emphasis>alias</emphasis><emphasis role="bold">] on
      </emphasis><emphasis>joinCondition</emphasis><emphasis
      role="bold">]</emphasis></para>

      <para>[USE INDEX<emphasis>(</emphasis>indexFileName | 0
      <emphasis>)</emphasis>]</para>

      <para>[<emphasis role="bold">where</emphasis>
      <emphasis>logicalExpression] </emphasis>[<emphasis role="bold">group
      by</emphasis> <emphasis>fieldName</emphasis>]</para>

      <para>[<emphasis role="bold">order by</emphasis> <emphasis>columnNames
      </emphasis>[asc | desc]<emphasis> </emphasis>] [<emphasis
      role="bold">LIMIT</emphasis><emphasis> limitNumber</emphasis>]</para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="123.45pt" />

            <colspec />

            <tbody>
              <row>
                <entry><emphasis>columnList</emphasis></entry>

                <entry>columnreference1[,columnreference2,columnreference3,...,columnreference<emphasis>n</emphasis>]</entry>
              </row>

              <row>
                <entry></entry>

                <entry>The column(s) to return (comma-separated list). In
                addition, these aggregate functions are supported : COUNT,
                SUM, MIN, MAX, and AVG. These work in a similar manner as
                their ECL counterparts.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry>columnreference</entry>

                <entry>[tablename.]columnname[ [AS] alias ]</entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>distinct</emphasis></entry>

                <entry>[distinct] col1, col2,...
                col<emphasis>n</emphasis></entry>
              </row>

              <row>
                <entry><emphasis></emphasis></entry>

                <entry>The result set will only contain distinct (unique)
                values.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>alias</emphasis></entry>

                <entry>The alias used to refer to the corresponding table or
                field reference.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis role="bold">outer | inner</emphasis></entry>

                <entry>The type of JOIN to use.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>joinTableName</emphasis></entry>

                <entry>The JOIN file to use.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>joinCondition</emphasis></entry>

                <entry>Specifies the relationship between columns in the
                joined tables using logical expression.</entry>
              </row>

              <row>
                <entry></entry>

                <entry></entry>
              </row>

              <row>
                <entry><emphasis>logicalExpression</emphasis></entry>

                <entry>Logical expression based on standard SQL filtering
                syntax. Compound operators such as NOT IN or IS NULL must be
                in ALL CAPS or all lower case and can have one and only one
                space between the words. (NOT IN, not in, IS NULL, is null,
                etc.)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>BOOLEAN Only supports <emphasis>True</emphasis> or
                <emphasis>False</emphasis>, do not use Y, N, 0, or 1.</entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Valid
                operators:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>= Equal (e.g., age=33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;&gt; Not equal (e.g., age &lt;&gt;33)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt; Greater than (e.g., age &gt;55)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt; Less than (e.g., age &lt; 18)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&gt;= Greater than or equal (e.g., age &gt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>&lt;= Less than or equal (e.g., age &lt;=21)</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IN(value1,value2,...,value<emphasis>n</emphasis>) where
                values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>NOT IN(value1,value2,...,value<emphasis>n</emphasis>)
                where values are comma separated homogeneous types.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>IS NULL</entry>
              </row>

              <row>
                <entry><emphasis>limitNumber</emphasis></entry>

                <entry>Optional. The number of rows to return. This overrides
                the driver's configuration attribute (<emphasis
                role="code">EclResultLimit </emphasis>) but cannot be set to
                ALL.</entry>
              </row>

              <row>
                <entry></entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>1</superscript>Aliasing not
                supported</entry>
              </row>

              <row>
                <entry></entry>

                <entry><superscript>2</superscript>Can only contain references
                to aggregate functions<superscript> </superscript>if used with
                <emphasis>having</emphasis> clause.</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Aggregate functions can only be expressed in
                logicalExpressions by using <emphasis>Group by </emphasis>and
                <emphasis>having</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry><emphasis role="bold">Examples:</emphasis></entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList where Sum(F1 &gt; 100) /* is
                NOT SUPPORTED */</entry>
              </row>

              <row>
                <entry></entry>

                <entry>Select * from tableList Group byF1 Having Sum (F1 &gt;
                100) /* IS SUPPORTED */</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <para><programlisting>Select t1.personname, t2.address 
       from persontable as t1 inner join addresstable as t2 
       on (t1.personid = t2.personid AND
           (t1.firstname = 'jim' AND
            t1.lastname  = 'smith' )) </programlisting></para>

      <para></para>

      <para>The JDBC driver does not convert parameter list or column list
      values to string literals.</para>

      <para>String values should be single quote encapsulated. Field
      identifier can be left unquoted or double quoted.</para>

      <para>For example, the table <emphasis role="bold">persons</emphasis>
      has columns Firstname(String) and Zip (numeric)</para>

      <para><programlisting>Select Firstname from persons where Firstname = ‘Jim’ and zip &gt; 33445    /* works  */ 

Select Firstname from persons where Firstname = ‘Jim’ and "zip" &gt; 33445    /* also works  */ 

Select Firstname from persons where Firstname = Jim and zip &gt; 33445     /* doesn’t work */

Select Firstname from persons where Firstname = ‘Jim’ and zip &gt; ‘33445’   /* doesn’t work */</programlisting></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Supported Aggregate Functions</title>

      <para><emphasis
      role="bold">COUNT</emphasis>([DISTINCT]<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">DISTINCT</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">SUM</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">MIN</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">MAX</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para><emphasis
      role="bold">AVG</emphasis>(<emphasis>columnName</emphasis>)</para>

      <para>These aggregate functions are supported. They behave as their ECL
      counterparts. See the <emphasis role="bold">ECL Language
      Reference</emphasis> for details.</para>

      <para><informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="119.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>COUNT</entry>

                <entry>Counts the occurrences of columnName in the result,
                always an integer.</entry>
              </row>

              <row>
                <entry>DISTINCT</entry>

                <entry>Returns only distinct values of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>SUM</entry>

                <entry>Returns the sum of the values of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>MIN</entry>

                <entry>Returns the minimum value for of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>MAX</entry>

                <entry>Returns the minimum value for of columnName in the
                result, output type is dependent on input type.</entry>
              </row>

              <row>
                <entry>AVG</entry>

                <entry>Returns the average of the values of columnName in the
                result, always a real number.</entry>
              </row>

              <row>
                <entry>columnName</entry>

                <entry>The column to aggregate.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>Example:</para>

      <para><programlisting>Select fname, lname, state, COUNT(zip) from TutorialPerson where zip=’33024’</programlisting></para>

      <sect2>
        <title>Supported String Modifiers</title>

        <para><emphasis
        role="bold">UPPER</emphasis>(<emphasis>columnName</emphasis>)</para>

        <para><emphasis
        role="bold">LOWER</emphasis>(<emphasis>columnName</emphasis>)</para>

        <para></para>

        <informaltable colsep="0" frame="none" rowsep="0">
          <tgroup cols="2">
            <colspec colwidth="119.65pt" />

            <colspec />

            <tbody>
              <row>
                <entry>UPPER</entry>

                <entry>Returns with all lower case characters converted to
                upper case.</entry>
              </row>

              <row>
                <entry>LOWER</entry>

                <entry>Returns with all upper case characters converted to
                lower case.</entry>
              </row>

              <row>
                <entry>columnName</entry>

                <entry>The column to aggregate</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Java Example</title>

    <para><programlisting>/* Obtain instance of JDBC Driver */
Driver jdbcdriver = DriverManager.getDriver("jdbc:hpcc");
        
/* Establish Connection */
       
HPCCConnection connection = null;
 try
 {
        
/*populate JAVA properties object with pertinent connection options */
   Properties connprops = new Properties();
   connprops.put("ServerAddress", "192.168.124.128");

/*or create JDBC connection url string with pertinent connection options*/
/* the connection values must be URL-encoded */
   String jdbcurl = "jdbc:hpcc;ServerAddress=HTTP%3A%2F%2F192.168.124.128";

/*provide all necessary connection properties either by URL, or props object */
    connection = (HPCCConnection) driver.connect(jdbcurl, connprops);
  }
 
   catch (Exception e) { System.out.println("Error");}
/* create HPCCStatement object for single use SQL query execution */

   HPCCStatement stmt = (HPCCStatement) connection.createStatement();

/* Create your SQL query */
   String mysql = "select * from tablename as mytab limit 10";

/* Execute your SQL query */
   HPCCResultSet res1 = (HPCCResultSet) stmt.executeQuery(mysql);

/*Do something with your results */
   printOutResultSet(res1);

/* Or create a prepared statement for multiple execution and parameterization */
   String myprepsql = "select * from persons_table persons where zip= ? limit 100";
   HPCCPreparedStatement prepstmt =
(HPCCPreparedStatement)createPrepStatement(connection, myprepsql);

/* provide parameter values and execute */
   for (int i = 33445; i &lt; 33448; i++)
   {
    prepstmt.clearParameters();
    prepstmt.setString(1, "'" + Integer.toString(i, 10) + "'");
    HPCCResultSet qrs = (HPCCResultSet) ((HPCCPreparedStatement) prepstmt).executeQuery();

/*Do something with your results */
    printOutResultSet(qrs);
   }


</programlisting>More code samples are available from:</para>

    <para><ulink
    url="https://github.com/hpcc-systems/hpcc-jdbc/tree/master/src/test/java/org/hpccsystems/jdbcdriver/tests">https://github.com/hpcc-systems/hpcc-jdbc/tree/master/src/test/java/org/hpccsystems/jdbcdriver/tests</ulink></para>
  </chapter>
</book>
