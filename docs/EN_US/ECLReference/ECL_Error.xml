<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
 <bookinfo>
     <title>ECL Error Reference</title>
 </bookinfo>
<chapter id="ECL_ERRORS">
  <title>ECL ERRORS</title>

  <sect1 id="ECL_ERROR_CODES">
    <title>ECL ERROR CODES</title>

    <para>This Chapter features ECL Error Codes</para>
  </sect1>

  <sect1 id="_1">
    <title>1</title>

    <indexterm>
      <primary>1</primary>
    </indexterm>

    <para>no resulting expression tree</para>
  </sect1>

  <sect1 id="_2">
    <title>2</title>

    <indexterm>
      <primary>2</primary>
    </indexterm>

    <para>"there is an expression tree, but should not be executed"</para>
  </sect1>

  <sect1 id="_3">
    <title>3</title>

    <indexterm>
      <primary>3</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1001">
    <title>1001</title>

    <indexterm>
      <primary>1001</primary>
    </indexterm>

    <para><emphasis role="bold">Error in macro expansion (see error
    follows)</emphasis></para>

    <para>This warning indicates there is an error in the macro expansion.
    Since the compiler will issue an error in the macro, this warning is used
    only for informational purposes; it gives the position where the macro is
    called to help the user trace down the problem.</para>

    <para>Solution: Resolve the error that follows this warning first.
    Example:</para>

    <programlisting>      01: f(x) := MACRO
      02: x+3;
      03: ENDMACRO;
      04:
      05: EXPORT aaa := f(4);
</programlisting>

    <para>In line 1-3, a value macro f is defined. This is a value macro
    because it has no Attribute defini- tions. That means the macro body must
    be legal to appear wherever a value expression may appear. Clearly, the
    semicolon at the end of line 2 is extraneous, so this warning saying that
    there is an error in the macro expansion at line 5 appears, and an error
    following this warning says the error is in line 2 of the macro.</para>
  </sect1>

  <sect1 id="_1004">
    <title>1004</title>

    <indexterm>
      <primary>1004</primary>
    </indexterm>

    <para><emphasis role="bold">LOCAL specified on dataset that is not
    Distributed</emphasis></para>

    <para>In a SORT or JOIN function, LOCAL can be specified to indicate that
    the sort or join should be performed while maintaining the distribution of
    a previously distributed dataset. A dataset is consided to be distributed
    if:</para>

    <para>• it has been explicitly distributed as the result of the DISTRIBUTE
    function</para>

    <para>• it is defined as already distributed by the DISTRIBUTED
    function</para>

    <para>Solution: Use DISTRIBUTE or DISTRIBUTED to distribute the dataset,
    or remove the LO- CAL option.</para>

    <para>Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’,{STRING1 f1}, FLAT);
      02: distibuted_aaa := DISTRIBUTE(aaa, RANDOM());
      03: distibuted_aaax := DISTRIBUTED(aaa, RANDOM());
      04:
      05: OUTPUT(SORT(aaa, f1, LOCAL));
      06: OUTPUT(SORT(distibuted_aaa, f1, LOCAL));
      07: OUTPUT(SORT(distibuted_aaax, f1, LOCAL));
</programlisting>

    <para>There are 3 datasets defined (in lines 1, 2, 3). We use the LOCAL
    option to sort them (in lines 5,</para>

    <para>6, 7). The first one is not distributed, therefore we get this
    warning in the SORT on line 5. The</para>

    <para>second is the result of the DISTRIBUTE function, and the third is
    specified as already DIS-</para>

    <para>TRIBUTED. Therefore, lines 6 and 7 compile without warning or
    error.</para>
  </sect1>

  <sect1 id="_1005">
    <title>1005</title>

    <indexterm>
      <primary>1005</primary>
    </indexterm>

    <para><emphasis role="bold">Input is explicitly Distribited but Local not
    specified</emphasis></para>

    <para>In a SORT or JOIN function, the dataset(s) involved is(are)
    distributed, but LOCAL is not</para>

    <para>explicitly specified. See Warning C1004 for information on
    distributed.</para>

    <para>Solution: Add the LOCAL option, or make sure the dataset is not
    distributed. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’,{STRING1 fa; }, FLAT);
      02: distibuted_aaa := DISTRIBUTE(aaa, RANDOM());
      03: distibuted_aaax := DISTRIBUTED(aaa, RANDOM());
      04:
      05: OUTPUT(SORT(distibuted_aaa, fa));
      06: OUTPUT(SORT(distibuted_aaax, fa));
</programlisting>

    <para>On lines 5 and 6, distributed_aaa and distributed_aaax are
    distributed, but no LOCAL option is specified in the SORT. Adding ,LOCAL
    to the SORT in lines 5 and 6 will fix this problem.</para>
  </sect1>

  <sect1 id="_1006">
    <title>1006</title>

    <indexterm>
      <primary>1006</primary>
    </indexterm>

    <para><emphasis role="bold">CASE does not have any
    condition</emphasis></para>

    <para>No condition is given for the CASE statement. This makes the CASE
    statement unnecessary under the normal situation. This is allowed for easy
    use for some special circumstances, like automatic code generation using
    ECL template language.</para>

    <para>Solution: Make sure this is what you wanted. Example:</para>

    <programlisting>      INTEGER i := 10;
      INTEGER j := CASE(i, 3);
      for other reasons.</programlisting>
  </sect1>

  <sect1 id="_1007">
    <title>1007</title>

    <indexterm>
      <primary>1007</primary>
    </indexterm>

    <para>Module occurs twice in scope</para>
  </sect1>

  <sect1 id="_1010">
    <title>1010</title>

    <indexterm>
      <primary>1010</primary>
    </indexterm>

    <para><emphasis role="bold">Unsupported language feature</emphasis></para>

    <para>The language feature for which this warning appears is not supported
    yet. However, the parser can recognize this feature. This means either it
    is under development, or is deliberately left out</para>

    <para>Solution: Make sure your QueryBuilder program is the latest version.
    The feature may be sup- ported already in a newer version than the one
    your are using. Otherwise, find a workaround solution for you
    problem.</para>

    <para>Example:</para>

    <programlisting>
      01: aaa := DATASET(‘aaa’, {STRING1 fa; }, FLAT);
      02: a1 := aaa(fa = ‘a’);
      03: a2 := aaa(fa = ‘b’);
      04: OUTPUT(a1-a2);
  </programlisting>

    <para>We get this error on line 4 if the dataset difference operation is
    not supported yet. NOTE: It may be already supported when you read
    this!</para>
  </sect1>

  <sect1 id="_1012">
    <title>1012</title>

    <indexterm>
      <primary>1012</primary>
    </indexterm>

    <para>';' is not legal here (empty statement is not allowed)</para>
  </sect1>

  <sect1 id="_1013">
    <title>1013</title>

    <indexterm>
      <primary>1013</primary>
    </indexterm>

    <para>A field in transform already assigned a value</para>
  </sect1>

  <sect1 id="_1014">
    <title>1014</title>

    <indexterm>
      <primary>1014</primary>
    </indexterm>

    <para>physicalLength is not needed, ignored</para>
  </sect1>

  <sect1 id="_1015">
    <title>1015</title>

    <indexterm>
      <primary>1015</primary>
    </indexterm>

    <para>Module is already imported</para>
  </sect1>

  <sect1 id="_1016">
    <title>1016</title>

    <indexterm>
      <primary>1016</primary>
    </indexterm>

    <para>Syntax obsoleted: use alternative</para>
  </sect1>

  <sect1 id="_1017">
    <title>1017</title>

    <indexterm>
      <primary>1017</primary>
    </indexterm>

    <para>Empty assignall has no effort</para>
  </sect1>

  <sect1 id="_1018">
    <title>1018</title>

    <indexterm>
      <primary>1018</primary>
    </indexterm>

    <para>Unsupported service attribute</para>
  </sect1>

  <sect1 id="_1019">
    <title>1019</title>

    <indexterm>
      <primary>1019</primary>
    </indexterm>

    <para>An service attribute does not need a value</para>
  </sect1>

  <sect1 id="_1020">
    <title>1020</title>

    <indexterm>
      <primary>1020</primary>
    </indexterm>

    <para>Module name mismatch</para>
  </sect1>

  <sect1 id="_1021">
    <title>1021</title>

    <indexterm>
      <primary>1021</primary>
    </indexterm>

    <para>OUTPUT record contains no variables - probably an error</para>
  </sect1>

  <sect1 id="_1022">
    <title>1022</title>

    <indexterm>
      <primary>1022</primary>
    </indexterm>

    <para>Condition is always true</para>
  </sect1>

  <sect1 id="_1023">
    <title>1023</title>

    <indexterm>
      <primary>1023</primary>
    </indexterm>

    <para>Condition is always false</para>
  </sect1>

  <sect1 id="_1024">
    <title>1024</title>

    <indexterm>
      <primary>1024</primary>
    </indexterm>

    <para>#WARNING statement</para>
  </sect1>

  <sect1 id="_1025">
    <title>1025</title>

    <indexterm>
      <primary>1025</primary>
    </indexterm>

    <para>Duplicate case values</para>
  </sect1>

  <sect1 id="_1026">
    <title>1026</title>

    <indexterm>
      <primary>1026</primary>
    </indexterm>

    <para>Local will be ignored for a grouped dataset</para>
  </sect1>

  <sect1 id="_1027">
    <title>1027</title>

    <indexterm>
      <primary>1027</primary>
    </indexterm>

    <para>Local expected</para>
  </sect1>

  <sect1 id="_1028">
    <title>1028</title>

    <indexterm>
      <primary>1028</primary>
    </indexterm>

    <para>Grouping will be ignored.</para>
  </sect1>

  <sect1 id="_1029">
    <title>1029</title>

    <indexterm>
      <primary>1029</primary>
    </indexterm>

    <para>No longer used (this is now an error, not a warning)</para>
  </sect1>

  <sect1 id="_1030">
    <title>1030</title>

    <indexterm>
      <primary>1030</primary>
    </indexterm>

    <para>Counter not used in transform</para>
  </sect1>

  <sect1 id="_1031">
    <title>1031</title>

    <indexterm>
      <primary>1031</primary>
    </indexterm>

    <para>Merge inputs don't appear to be sorted</para>
  </sect1>

  <sect1 id="_1032">
    <title>1032</title>

    <indexterm>
      <primary>1032</primary>
    </indexterm>

    <para>Merge inputs don't appear to match</para>
  </sect1>

  <sect1 id="_1033">
    <title>1033</title>

    <indexterm>
      <primary>1033</primary>
    </indexterm>

    <para>Definition is sandboxed</para>
  </sect1>

  <sect1 id="_1034">
    <title>1034</title>

    <indexterm>
      <primary>1034</primary>
    </indexterm>

    <para>Definition reference sandbox</para>
  </sect1>

  <sect1 id="_1035">
    <title>1035</title>

    <indexterm>
      <primary>1035</primary>
    </indexterm>

    <para>regular expression syntax</para>
  </sect1>

  <sect1 id="_1036">
    <title>1036</title>

    <indexterm>
      <primary>1036</primary>
    </indexterm>

    <para>deprecated syntax</para>
  </sect1>

  <sect1 id="_1037">
    <title>1037</title>

    <indexterm>
      <primary>1037</primary>
    </indexterm>

    <para>group input does not appear to be sorted</para>
  </sect1>

  <sect1 id="_1038">
    <title>1038</title>

    <indexterm>
      <primary>1038</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1039">
    <title>1039</title>

    <indexterm>
      <primary>1039</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1040">
    <title>1040</title>

    <indexterm>
      <primary>1040</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1041">
    <title>1041</title>

    <indexterm>
      <primary>1041</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1042">
    <title>1042</title>

    <indexterm>
      <primary>1042</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1043">
    <title>1043</title>

    <indexterm>
      <primary>1043</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1044">
    <title>1044</title>

    <indexterm>
      <primary>1044</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1045">
    <title>1045</title>

    <indexterm>
      <primary>1045</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1046">
    <title>1046</title>

    <indexterm>
      <primary>1046</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1047">
    <title>1047</title>

    <indexterm>
      <primary>1047</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1048">
    <title>1048</title>

    <indexterm>
      <primary>1048</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_1049">
    <title>1049</title>

    <indexterm>
      <primary>1049</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2000">
    <title>2000</title>

    <indexterm>
      <primary>2000</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2001">
    <title>2001</title>

    <indexterm>
      <primary>2001</primary>
    </indexterm>

    <para><emphasis role="bold">Type mismatch - Real value
    expected</emphasis></para>

    <para>In the context where the error occurs, a real value is expected. A
    real value can be an real con- stant, or an expression that evaluates to a
    real value. Therefore, 12, 12.34, LOG(0.4)+3, are valid, but ‘12.34’ and
    ‘String’ are not.</para>

    <para>Solution: Make sure the expression in question evaluates to a real
    number. A string constant, like ‘123.2’ is NOT a real number. For C
    programmers, don’t think ‘C’ or ‘1’ is a char, and therefore can be used
    as an integer (or real); there is no char type in ECL. Type casting may be
    needed in some cases. For example: (REAL4)‘12.34’ creates a valid real
    value by casting the strinf to real. Checking the code before and after
    the offending code often helps.</para>

    <para>Example:</para>

    <programlisting>        01: v1 := EXP(‘STR’);
        02: v2 := LN(‘STR’);
        03: v3 := LOG(‘STR’);
        04: v4 := POWER(‘STR’, 12);
        05: v5 := ROUND(‘STR’);
        06: v6 := ROUNDUP(‘STR’);
        07: v7 := SQRT(‘STR’);
        08: v8 := TRUNCATE(‘STR’);
        09: v9 := REALFORMAT(‘STR’,3,4);
</programlisting>

    <para>These examples all need to change to a real value. All the functions
    expect real value as the first parameters.</para>
  </sect1>

  <sect1 id="_2002">
    <title>2002</title>

    <indexterm>
      <primary>2002</primary>
    </indexterm>

    <para><emphasis role="bold">Type mismatch – Integer value
    expected</emphasis></para>

    <para>An integer value is expected in the context. An integer value can be
    an integer constant, or an</para>

    <para>expression that evaluates to an integer value The following is a
    (not necessarily complete) list</para>

    <para>where an integer value is expected:</para>

    <para>• BIG_ENDIAN value</para>

    <para>• LITTLE_ENDIAN value</para>

    <para>• WAIT (value)</para>

    <para>• expr1 op expr2, where op can be: %, DIV, &amp;, |, ^</para>

    <para>• substring range: [ start_index .. end_index]</para>

    <para>• CHOOSE(expr, choose_list)</para>

    <para>• CHOOSEN(dataset, value)</para>

    <para>• DEDUP(…, KEEP value)</para>

    <para>• INTFORMAT(value1, value2, value3)</para>

    <para>• REALFORMAT(real_value, value1, value2) All bold expressions must
    be integer values.</para>

    <para>Solution: Make sure the value is an integer value. Use type cast if
    necessary. Example:</para>

    <programlisting>        01: WAIT(‘STR’);
        02: v1 := <emphasis role="bold">10.2 </emphasis>% <emphasis
        role="bold">11.2</emphasis>;
        03: v2 := <emphasis role="bold">10.2 </emphasis>DIV <emphasis
        role="bold">11.2</emphasis>;
        04: v3 := <emphasis role="bold">10.2 </emphasis>| <emphasis
        role="bold">11.2</emphasis>;
        05: v4 := <emphasis role="bold">10.2 </emphasis>&amp; <emphasis
        role="bold">11.2</emphasis>;
        06: v5 := <emphasis role="bold">10.2 </emphasis>^ <emphasis
        role="bold">11.2</emphasis>;
        07: STRING s := ‘This is a string.’;
        08: s[<emphasis role="bold">0.23</emphasis>];
        09: s[<emphasis role="bold">0.23</emphasis>..<emphasis role="bold">2.34</emphasis>];
        10: s[..<emphasis role="bold">2.3</emphasis>];
        11: s[<emphasis role="bold">2.3</emphasis>..];
        12: INTFORMAT(<emphasis role="bold">1.2</emphasis>, <emphasis
        role="bold">2.2</emphasis>, <emphasis role="bold">3.3</emphasis>);
        13: REALFORMAT(1.0, <emphasis role="bold">2.0</emphasis>, <emphasis
        role="bold">3.0</emphasis>);
        14: CHOOSE(<emphasis role="bold">3.2</emphasis>, 9, 8, 7, 6, 5);
        15: aaa := DATASET(‘aaa’,{STRING1 fa; }, FLAT);
        16: OUTPUT(choosen(aaa,<emphasis role="bold">10.2</emphasis>));
        17: OUTPUT(DEDUP(aaa, fa = ‘A’, KEEP <emphasis role="bold">2.2</emphasis>));
</programlisting>

    <para>All bold expressions cause such an error.</para>
  </sect1>

  <sect1 id="_2003">
    <title>2003</title>

    <indexterm>
      <primary>2003</primary>
    </indexterm>

    <para><emphasis role="bold">Type mismatch - String value
    expected</emphasis></para>

    <para>A string value is expected. A string value can be a string constant,
    or an expression that evaluates</para>

    <para>to a string value. The following is a list that a string is
    expected:</para>

    <para>• EVENT(expr1, expr2)</para>

    <para>• LENGTH(value)</para>

    <para>• TRIM(value [, options])</para>

    <para>All bold expressions must be string values.</para>

    <para>For C/C++/Java/Pascal etc programmers, string constants are enclosed
    in single quotes (‘’) in ECL, not double quotes (“”). Also, ECL currently
    only supports two escape sequences: \’ and \\ which stands for the single
    quote and backslash. Support for more escape sequences may be added as
    needed in the future.</para>

    <para>Solution: Make sure the expression is a string constant or evaluates
    to a string value. Use type cast or TRANSFER as needed.</para>

    <para>Example:</para>

    <programlisting>        01: WAIT(EVENT(123, TRUE));
        02: len := LENGTH(123);
        03: STRING s:= TRIM(123);</programlisting>
  </sect1>

  <sect1 id="_2004">
    <title>2004</title>

    <indexterm>
      <primary>2004</primary>
    </indexterm>

    <para><emphasis role="bold">Type mismatch - Integer or real value
    expected</emphasis></para>

    <para>An integer or real value is expected. It can be an integer constant,
    real constant, or an expression that evaluates to a real or integer value.
    The following is a list of cases where an integer or</para>

    <para>real value is expected:</para>

    <para>• expr1 + epxr2</para>

    <para>• expr1 – expr2</para>

    <para>• POWER(value1, value2)</para>

    <para>• AVE(dataset, expr)</para>

    <para>• AVE(GROUP, expr)</para>

    <para>• DISTRIBUTE(dataset, value)</para>

    <para>• DISTRIBUTED(dataset, value, tranform) This error is the same as
    error C2072.</para>

    <para>Solution: Make sure it is a integer or real value. Use type casting
    if necessary. Example:</para>

    <programlisting>        01: aaa := DATASET(‘aaa’, {STRING1 fa; }, FLAT);
        02: i := 3 + <emphasis role="bold">TRUE</emphasis>;
        03: j := 4 - <emphasis role="bold">TRUE</emphasis>;
        04: x1 := POWER(20, <emphasis role="bold">TRUE</emphasis>);
        05: x2 := AVE(aaa, <emphasis role="bold">‘string’</emphasis>);
        06: x3 := AVE(GROUP, <emphasis role="bold">‘string’</emphasis>);
        07: d1 := DISTRIBUTE(aaa, <emphasis role="bold">‘abc’</emphasis>);
        08: d2 := DISTRIBUTED(aaa, <emphasis role="bold">TRUE</emphasis>);
</programlisting>

    <para>All bold expressions are expected to be integer or real
    value.</para>
  </sect1>

  <sect1 id="_2005">
    <title>2005</title>

    <indexterm>
      <primary>2005</primary>
    </indexterm>

    <para><emphasis role="bold">Table type mismatch</emphasis></para>

    <para>???</para>

    <para>Solution: Example:</para>
  </sect1>

  <sect1 id="_2006">
    <title>2006</title>

    <indexterm>
      <primary>2006</primary>
    </indexterm>

    <para><emphasis role="bold">Record type mismatch</emphasis></para>

    <para>???</para>

    <para>Solution: Example:</para>
  </sect1>

  <sect1 id="_2007">
    <title>2007</title>

    <indexterm>
      <primary>2007</primary>
    </indexterm>

    <para><emphasis role="bold">Incompatible types</emphasis></para>

    <para>There is a type incompatiblity problem here. This normally a result
    of some other error, like</para>

    <para>“Integer value is expected”.</para>

    <para>Solution: Resolve the error before this one (if any) first,
    otherwise, make sure the types are compatible.</para>

    <para>Example:</para>

    <programlisting>      01: i := 3 + TRUE;
      02: STRING20 s := ‘ABC’;
      03: TYPEOF(s) y := 10;
</programlisting>

    <para>First, an Error C2004 will be reported by the compiler, then this
    error will be reported. For line</para>

    <para>3, since TYPEOF(s) is STRING20, so we such an error for assignment
    :=10.</para>
  </sect1>

  <sect1 id="_2008">
    <title>2008</title>

    <indexterm>
      <primary>2008</primary>
    </indexterm>

    <para><emphasis role="bold">Type does not require
    parameters</emphasis></para>

    <para>No parameter is required for a user defined type. A user defined
    type can be defined in ECL</para>

    <para>using TYPE. A user defined type can have parameters. See Example
    below.</para>

    <para>Solution: Try to get rid of the parameter(s). Example:</para>

    <programlisting>
      01: MyType := TYPE
      02: EXPORT INTEGER Load(INTEGER x) := x+1;
      03: EXPORT INTEGER Store(INTEGER x) := x-1;
      04: END;
      05:
      06: MyRec := RECORD
      07: MyType(3) abc;
      08: END;
      09:
      10: NeedC(INTEGER len) := TYPE
      11: EXPORT String Load(String S) := ‘C’+S[1..len];
      12: EXPORT String Store(String s) := S[2..len+1];
      13: EXPORT Integer PhysicalLength(String s) := len;
      14: END;
      15:
      16: Rec := RECORD
      17: NeedC(3) good;
      18: NeedC(3,5) abc;
      19: NeedC xyz;
      20: END;
  </programlisting>

    <para>In line 7, this error ocurrs. Line 10-14 shows an example that
    defines a user type with parameter. Line 17 is fine, but an error C2061
    occurs in line 18, and C2062 occurs in line 19.</para>
  </sect1>

  <sect1 id="_2009">
    <title>2009</title>

    <indexterm>
      <primary>2009</primary>
    </indexterm>

    <para><emphasis role="bold">Boolean/Set
    of/Integer/Real/String/Table/Record/Unknown value
    expected</emphasis></para>

    <para>A certain type is expected to be passed as the parameter in this
    context. Solution: Make sure the passed parameter is one of the expected
    types.</para>
  </sect1>

  <sect1 id="_2010">
    <title>2010</title>

    <indexterm>
      <primary>2010</primary>
    </indexterm>

    <para><emphasis role="bold">Illegal operand for TYPEOF</emphasis></para>

    <para>The operand for TYPEOF must be an expression whose type is
    known.</para>

    <para>In ECL, we can get the type of an expression and use it as type. All
    the following are legal uses of TYPEOF:</para>

    <programlisting>
TYPEOF(‘ABC’) x1 := ‘XYZ’; 
TYPEOF(5) x2 := 10; 
STRING20 s := ‘ABC’; 
TYPEOF(s) x3 := ‘DEF’; 
TYPEOF(x1) x4 := ‘GHI’

</programlisting>

    <para>Solution: Make sure the type of the operand is known.</para>
  </sect1>

  <sect1 id="_2011">
    <title>2011</title>

    <indexterm>
      <primary>2011</primary>
    </indexterm>

    <para><emphasis role="bold">Cannot nest TYPE
    declarations</emphasis></para>

    <para>TYPE defintions cannot be nested.</para>

    <para>Solution: Define these TYPEs separately instead of nested.
    Example:</para>

    <programlisting>      ReverseString4 := TYPE
      MyType := TYPE
      EXPORT INTEGER Load(INTEGER x) := x+1; EXPORT INTEGER
      Store(INTEGER x) := x-1;

      END;
      END;

      SHARED STRING4 Rev(String4 S) := s[4]+s[3]+s[2]+s[1]; EXPORT
      String4 Load(String4 s) := Rev(s);

      EXPORT String4 Store(String4 s) := Rev(s);
</programlisting>

    <para>Here, inside the TYPE defintion for ReverseString4, we are trying to
    define another TYPE MyType. This nesting is not allowed.</para>
  </sect1>

  <sect1 id="_2012">
    <title>2012</title>

    <indexterm>
      <primary>2012</primary>
    </indexterm>

    <para><emphasis role="bold">Datasets must be the same
    type</emphasis></para>

    <para>The datasets have different types. The + and – operations can be
    applied to datasets and these</para>

    <para>two datasets must have the same type. Two datasets are of the same
    type if:</para>

    <para>• Both are defined as the same DATASET type</para>

    <para>• Both are defined as a subset of the same DATASET using
    filters</para>

    <para>• One is defined as a DATASET type, the other is a subset of the
    same type using filter</para>

    <para>Two datasets are not the same type if:</para>

    <para>• They are defined with different DATASET names, even if they have
    exactly the same</para>

    <para>RECORD structures.</para>

    <para>• One is defined as a DATASET type, the other is derived from the
    same DATASET type using TABLE(), even if they have exactly the same RECORD
    structure.</para>

    <para>The following example illustrates these rules.</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa; STRING1 fb;}, HOLE);
      02: bbb := DATASET(‘bbb’, {STRING1 fa; STRING1 fb;}, HOLE);
      03:
      04: a1 := aaa(fa = ‘a’);
      05: a2 := aaa(fa = ‘b’);
      06: a3 := TABLE(aaa, {aaa.fa,aaa.fb});
      07:
      08: OUTPUT(aaa+a1); // OK
      09: OUTPUT(a1+a2);
      10:
      11: OUTPUT(a1+a3); // BAD
      12: OUTPUT(aaa+bbb);
</programlisting>

    <para>In line 8, aaa is a dataset type, a1 is a subset of the same type
    using a filter (line 4). In line 10, both a1 and a2 are subsets of dataset
    type aaa. They are OK.</para>

    <para>In line 11, a3 is derived from aaa using TABLE(). In line 14, aaa
    and bbb are different dataset types, although they have exactly the same
    structure.</para>

    <para>Solution: Follow the above guidelines to make sure the two datasets
    involved are the same type. The fact that they have the same structure is
    not enough.</para>

    <para>Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa; }, FLAT);
      02: bbb := DATASET(‘bbb’, {STRING1 fa; }, HOLE);
      03:
      04: OUTPUT(aaa+bbb,{fa});
      05: OUTPUT(aaa-bbb,{fa});
      06:
      07: a1 := aaa(fa = ‘a’);
      08: a2 := aaa(fa = ‘b’);
      09:
      10: OUTPUT(a1+a2);
      11: OUTPUT(a1-a2);</programlisting>
  </sect1>

  <sect1 id="_2013">
    <title>2013</title>

    <indexterm>
      <primary>2013</primary>
    </indexterm>

    <para><emphasis role="bold">The types must be the same</emphasis></para>

    <para>The items that are in question must have the same type. More
    precisely, the types must be exactly the same, not just compatible. See
    Error C2012 for more details on how two dataset types are treated as the
    same type.</para>

    <para>Solution: Make sure they have the same type. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 a;}, HOLE);
      02: bbb := DATASET(‘bbb’, {STRING1 b;}, HOLE);
      03: ccc := aaa(a=’a’);
      04: s1 := if(aaa=bbb,’true’,’false’);
      05: s2 := if(aaa=ccc,’true’,’false’);
      06: s3 := if(aaa!=bbb,’true’,’false’);
      07: s4 := if(aaa!=ccc,’true’,’false’);
</programlisting>

    <para>In this example, we are comparing the equality of two datasets. Two
    dataset must be the same types if we want to compare them.</para>
  </sect1>

  <sect1 id="_2014">
    <title>2014</title>

    <indexterm>
      <primary>2014</primary>
    </indexterm>

    <para>List element has unknown type</para>
  </sect1>

  <sect1 id="_2015">
    <title>2015</title>

    <indexterm>
      <primary>2015</primary>
    </indexterm>

    <para><emphasis role="bold">Integer type expected</emphasis></para>

    <para>A valid INTEGER type is expected. A valid INTEGER type can be
    INTEGER or INTEGERn, where n is 1, 2, 4 or 8. Note that this error is
    different from Error C2002, where an integer value is expected.</para>

    <para>Solution: Make sure it is an valid INTEGER type. Example:</para>

    <programlisting>      01: BIG_ENDIAN STRING i := ‘ABC’;
      02: LITTLE_ENDIAN BOOLEAN b := FALSE;
</programlisting>

    <para>BIG_ENDIAN and LITTLE_ENDIAN can be used on valid INTEGER types
    only.</para>
  </sect1>

  <sect1 id="_2016">
    <title>2016</title>

    <indexterm>
      <primary>2016</primary>
    </indexterm>

    <para><emphasis role="bold">Integer or decimal type
    expected</emphasis></para>

    <para>A valid INTEGER or DECIMAL type is expected. A valid INTEGER type
    can be INTEGER</para>

    <para>or INTEGERn, where n is 1, 2, 4 or 8. A valid decimal type can be
    DECIMALn where n is an</para>

    <para>positive integer, or DECIMALn_y where n and y are positive integers.
    This normally happens</para>

    <para>after the UNSIGNED keyword, which can be applied to INTEGER or
    DECIMAL types only.</para>

    <para>Note that this error is different from Error C2001, 2002, where an
    integer value or real value is</para>

    <para>expected.</para>

    <para>Solution: Make sure it is a valid INTEGER or DECIMAL type.
    Example:</para>

    <programlisting>      UNSIGNED STRING s := ‘ABC’;
      UNSIGNED BOOLEAN b := FALSE;</programlisting>

    <para>UNSIGNED cannot be used with STRING or BOOLEAN.</para>
  </sect1>

  <sect1 id="_2017">
    <title>2017</title>

    <indexterm>
      <primary>2017</primary>
    </indexterm>

    <para><emphasis role="bold">String type expected</emphasis></para>

    <para>A valid STRING type is expected. A valid STRING type can be STRING
    or STRINGn, where n is an integer that is greater than 0.</para>

    <para>The following list are the cases this error can occur:</para>

    <para>• ASCII type</para>

    <para>• EBCDIC type</para>

    <para>The bold type must be a valid STRING type. Note that this error is
    different from Error C2003, where a string value is expected.</para>

    <para>Solution: Change it to a valid STRING type. Example:</para>

    <programlisting>      01: ASCII <emphasis role="bold">INTEGER </emphasis>s1 :=   123;
      02: EBCDIC <emphasis role="bold">BOOLEAN </emphasis>b :=   TRUE;
</programlisting>

    <para>All bold types should be a STRING type as expected by ASCII or
    EBCDIC.</para>
  </sect1>

  <sect1 id="_2018">
    <title>2018</title>

    <indexterm>
      <primary>2018</primary>
    </indexterm>

    <para><emphasis role="bold">Indexing ALL is undefined</emphasis></para>
  </sect1>

  <sect1 id="_2019">
    <title>2019</title>

    <indexterm>
      <primary>2019</primary>
    </indexterm>

    <para><emphasis role="bold">Type mismatch - Integer or string value
    expected</emphasis></para>
  </sect1>

  <sect1 id="_2020">
    <title>2020</title>

    <indexterm>
      <primary>2020</primary>
    </indexterm>

    <para><emphasis role="bold">COUNT not valid in this
    context</emphasis></para>

    <para>In the context where this error occurs, COUNT is not allowed.</para>

    <para>COUNT (as an alias to the COUNTER keyword) is only allowed in the
    following two cases:</para>

    <para>1. As a parameter passed to the transform function in
    NORMALIZE:</para>

    <para>NORMALIZE(dataset, expression, myTranform (LEFT,COUNT));</para>

    <para>2. As a parameter passed to the transform function in
    DENORMALIZE:</para>

    <para>DENORMALIZE(dataset, expression, myTranform (LEFT,COUNT));</para>

    <para>The COUNT keyword is not allowed to be used anywhere else.</para>

    <para>Please note that the COUNT() function can be applied to a dataset,
    as in COUNT(Person()); Solution: Make sure it is in the NORMALIZE or
    DENORMALIZE context. If you are using</para>

    <para>COUNT to count the number of tuples in a dataset, use the function
    COUNT(): the ( ) is</para>

    <para>required to use it as a function.</para>

    <para>Example:</para>

    <programlisting>      01: NamesRec := RECORD
      02: UNSIGNED1 numRows := 0;
      03: STRING20 thename;
      04: STRING20 addr1 := ‘’;
      05: STRING20 addr2 := ‘’;
      06: STRING20 addr3 := ‘’;
      07: STRING20 addr4 := ‘’;
      08: END;
      09:
      10: NamesTable := DATASET([
      11: {1, ‘Gavin’, ’10 Maltings Lane’},
      12: {2, ‘Liz’, ’10 Maltings Lane’, ‘3 The Cottages’},
      13: {0, ‘Mr Nobody’},
      14: {4, ‘Mr Everywhere’, ‘Here’, ‘There’, ‘Near’, ‘Far’}
      15: ], NamesRec);
      16:
      17: OutRec := RECORD
      18: UNSIGNED1 order;
      19: UNSIGNED1 numRows;
      20: STRING20 thename;
      21: STRING20 addr;
      22: END;
      23:
      24: OutRec NormalizeAddresses(NamesRec L, INTEGER C) :=  TRANSFORM
      25: SELF := L;
      26: SELF.order := C;
      27: SELF.addr := CHOOSE(C, L.addr1, L.addr2, L.addr3, L.addr4);
      28: END;
      29:
      30: NormalizeAddrs := NORMALIZE(namesTable, LEFT.numRows,
      31: NormalizeAddresses(LEFT,COUNT));
      32:
      33: OUTPUT(NormalizeAddrs);
</programlisting>

    <para>This example is a correct use of COUNT. We can also replace the
    COUNT keyword with</para>

    <para>COUNTER. The output of this example is:</para>

    <para><informaltable colsep="0" frame="none" rowsep="0">
        <tgroup cols="4">
          <colspec colwidth="35.00pt" />

          <colspec colwidth="60.00pt" />

          <colspec colwidth="108.00pt" />

          <colspec colwidth="113.00pt" />

          <tbody>
            <row>
              <entry>Order</entry>

              <entry>NumRows</entry>

              <entry>thename</entry>

              <entry>addr</entry>
            </row>

            <row>
              <entry>1</entry>

              <entry>1</entry>

              <entry>Gavin</entry>

              <entry>10 Maltings Lane</entry>
            </row>

            <row>
              <entry>1</entry>

              <entry>2</entry>

              <entry>Liz</entry>

              <entry>10 Maltings Lane</entry>
            </row>

            <row>
              <entry>2</entry>

              <entry>2</entry>

              <entry>Liz</entry>

              <entry>3 The Cottages</entry>
            </row>

            <row>
              <entry>1</entry>

              <entry>4</entry>

              <entry>Mr Everywhere</entry>

              <entry>Here</entry>
            </row>

            <row>
              <entry>2</entry>

              <entry>4</entry>

              <entry>Mr Everywhere</entry>

              <entry>There</entry>
            </row>

            <row>
              <entry>3</entry>

              <entry>4</entry>

              <entry>Mr Everywhere</entry>

              <entry>Near</entry>
            </row>

            <row>
              <entry>4</entry>

              <entry>4</entry>

              <entry>Mr Everywhere</entry>

              <entry>Far</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>Example:</para>

    <programlisting>      MyValue := COUNT + 3;
      OUTPUT(Person( career = ‘Study’), {per_first_name, COUNT});
</programlisting>

    <para>Both statements will produce a C2002 error since they are not in the
    context of NORMALIZE</para>

    <para>or DENORMALIZE.</para>
  </sect1>

  <sect1 id="_2021">
    <title>2021</title>

    <indexterm>
      <primary>2021</primary>
    </indexterm>

    <para><emphasis role="bold">COUNTER not valid in this
    context</emphasis></para>

    <para>The COUNTER keyword (as an alias of COUNT) is used only in NORMALIZE
    or</para>

    <para>DENORMALIZED. See Error 2020 for explanation, solution etc.</para>
  </sect1>

  <sect1 id="_2022">
    <title>2022</title>

    <indexterm>
      <primary>2022</primary>
    </indexterm>

    <para><emphasis role="bold">LEFT not legal here</emphasis></para>

    <para>The LEFT keyword is not legal in this context. LEFT can be used only
    in the following contexts:</para>

    <para>• Passing a parameter to a TRANSFORM function where a LEFT scope
    exists.</para>

    <para>• In TRIM(value, LEFT). LEFT means leading spaces.</para>

    <para>• In JOIN(dataset1, dataset2, join-fields, LEFT OUTER | LEFT
    ONLY).</para>

    <para>• In DEDUP(recordset, expression, LEFT). LEFT means to keep the head
    records from the comparison when duplication happens.</para>

    <para>Solution: Make sure LEFT is in one of the legal contexts listed
    above. Example:</para>

    <programlisting>      01: a := EXP(LEFT);
      02: NamesRec := RECORD
      03: STRING20 thename;
      04: END;
      05: NamesTable := DATASET([{‘Gavin’}], NamesRec);
      06: OutRec := RECORD
      07: STRING20 thename;
      08: END;
      09: OutRec NormalizeAddresses(NamesRec L, INTEGER C) :=
      10: TRANSFORM
      11: SELF := L;
      12: END;
      13: NormalizeAddrs := NORMALIZE(namesTable, LEFT.numRows,
      14: NormalizeAddresses(LEFT,COUNT));
</programlisting>

    <para>In line 1, LEFT is within none of the above contexts. In line 13 and
    14, LEFT is used to specify the left record passed to the transform
    function.</para>
  </sect1>

  <sect1 id="_2023">
    <title>2023</title>

    <indexterm>
      <primary>2023</primary>
    </indexterm>

    <para><emphasis role="bold">RIGHT not legal here</emphasis></para>

    <para>This is very simliar to Error 2022. Refer to it for
    information.</para>
  </sect1>

  <sect1 id="_2024">
    <title>2024</title>

    <indexterm>
      <primary>2024</primary>
    </indexterm>

    <para><emphasis role="bold">JOIN is not valid here</emphasis></para>

    <para>See Error C2027.</para>
  </sect1>

  <sect1 id="_2025">
    <title>2025</title>

    <indexterm>
      <primary>2025</primary>
    </indexterm>

    <para><emphasis role="bold">SELF not legal here</emphasis></para>

    <para>SELF can only be used inside a TRANSFORM structure to indicate the
    current output record. Otherwise it is not legal.</para>

    <para>Solution: Don’t use SELF outside a TRANSFORM structure.</para>
  </sect1>

  <sect1 id="_2026">
    <title>2026</title>

    <indexterm>
      <primary>2026</primary>
    </indexterm>

    <para><emphasis role="bold">ALL not legal here</emphasis></para>

    <para>ALL is illegal in this context. ALL can only be used in the
    following contexts:</para>

    <para>• Inside a GROUP function</para>

    <para>• As a optional parameter to TRIM function</para>

    <para>• As a default value to a SET or SET OF parameter.</para>

    <para>Solution: Make sure it is one of the above cases, otherwise, don’t
    use ALL. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1;}, HOLE);
      02: bbb := GROUP(aaa, ALL);
      03: s := ‘ abc ‘;
      04: TRIM(s, ALL);
      05: f(SET is, INTEGER i) := i IN is;
      06: MyJobSet := [1,2,3];
      07: BOOLEAN ok := f(ALL, 1);
      08: SORT(aaa, ALL);
</programlisting>

    <para>All lines from 1-7 are legal. In line 8, ALL is not in any of the
    legal contexts and causes this error.</para>
  </sect1>

  <sect1 id="_2027">
    <title>2027</title>

    <indexterm>
      <primary>2027</primary>
    </indexterm>

    <para><emphasis role="bold">JOINED can only be specified inside SORT or
    SORTED</emphasis></para>

    <para>JOINED can only be used inside SORT or SORTED. Otherwise, it is
    illegal.</para>

    <para>Solution: Make sure it is in the SORT or SORTED.</para>
  </sect1>

  <sect1 id="_2028">
    <title>2028</title>

    <indexterm>
      <primary>2028</primary>
    </indexterm>

    <para><emphasis role="bold">A value must be supplied for this
    attribute</emphasis></para>

    <para>The attribute in question needs to be supplied a value. In ECL, we
    cannot just declare an at- tribute without defining its value. There is
    only one exception, that is when the attribute name starts with a $. Names
    that start with a $ will be used as environment variable in the future,
    but that functionality is not implemented yet.</para>

    <para>Solution: Use := to define a value to it. Example:</para>

    <programlisting>      01: integer1 a;
      02: EXPORT STRING1 s;
      03: SHARED BOOLEAN b;
</programlisting>

    <para>Attributes a, s and b (whether it is local, EXPORTed, or SHARED)
    need a value when they are being defined.</para>
  </sect1>

  <sect1 id="_2029">
    <title>2029</title>

    <indexterm>
      <primary>2029</primary>
    </indexterm>

    <para><emphasis role="bold">Constant doesn’t make any sense
    here</emphasis></para>

    <para>Using a Constant doesn’t make sense in this context. For example,
    sorting or grouping by a constant doesn’t make sense.</para>

    <para>Example:</para>

    <programlisting>
      01: aaa := DATASET(‘aaa’,{STRING1 a; }, FLAT);
      02: iftotal := IF(TRUE, 1, 0);
      03:
      04: countrec := RECORD
      05: total := SUM(GROUP, iftotal);
      06: END;
      07:
      08: a := OUTPUT(TABLE(aaa,countrec,1));

</programlisting>

    <para>In line 8, the last 1 is not making sense.</para>
  </sect1>

  <sect1 id="_2030">
    <title>2030</title>

    <indexterm>
      <primary>2030</primary>
    </indexterm>

    <para>Illegal join flags for a lookup join</para>
  </sect1>

  <sect1 id="_2031">
    <title>2031</title>

    <indexterm>
      <primary>2031</primary>
    </indexterm>

    <para>DEDUP(file) not supported (or meaningful) on hole files</para>
  </sect1>

  <sect1 id="_2032">
    <title>2032</title>

    <indexterm>
      <primary>2032</primary>
    </indexterm>

    <para>Scheduling not allowed on an attribute (scheduling a definition
    makes no sense)</para>
  </sect1>

  <sect1 id="_2033">
    <title>2033</title>

    <indexterm>
      <primary>2033</primary>
    </indexterm>

    <para>Multiple workflow clauses</para>
  </sect1>

  <sect1 id="_2034">
    <title>2034</title>

    <indexterm>
      <primary>2034</primary>
    </indexterm>

    <para>Expected INDEX()...</para>
  </sect1>

  <sect1 id="_2035">
    <title>2035</title>

    <indexterm>
      <primary>2035</primary>
    </indexterm>

    <para>Type returned from transform must match the source dataset
    type</para>
  </sect1>

  <sect1 id="_2036">
    <title>2036</title>

    <indexterm>
      <primary>2036</primary>
    </indexterm>

    <para>Keyed parameter does not match the dataset passed as a second
    parameter</para>
  </sect1>

  <sect1 id="_2037">
    <title>2037</title>

    <indexterm>
      <primary>2037</primary>
    </indexterm>

    <para>Name of base file was not supplied and cannot be deduced</para>
  </sect1>

  <sect1 id="_2038">
    <title>2038</title>

    <indexterm>
      <primary>2038</primary>
    </indexterm>

    <para>BIAS not supplied and can't be calculated</para>
  </sect1>

  <sect1 id="_2039">
    <title>2039</title>

    <indexterm>
      <primary>2039</primary>
    </indexterm>

    <para>Character in string literal is not defined in encoding</para>
  </sect1>

  <sect1 id="_2040">
    <title>2040</title>

    <indexterm>
      <primary>2040</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for INTEGER
    type</emphasis></para>

    <para>An INTEGER type can only be 1, 2, 4 or 8 bytes. The size is
    specified by appending the size right after the INTEGER keyword (no space
    allowed), as in: INTEGER1, INTEGER2, etc. By default, the size is 8;
    INTEGER is the same as INTEGER8.</para>

    <para>Solution: Make sure it is one of the following:</para>

    <para>INTEGER1, INTEGER2, INTEGER4, INTEGER8 or INTEGER. No space is
    allowed between INTEGER and the size digit.</para>

    <para>All identifiers that are INTEGER followed by a legal octal integer
    are reserved (for future extension, or just for the purpose of type
    checking). Therefore, INTEGER5 is neither a legal type, nor a legal
    identifier for attribute, function, formal parameter name, etc.</para>

    <para>Example:</para>

    <programlisting>
      01: <emphasis role="bold">INTEGER3 </emphasis>x := 10;
      02: <emphasis role="bold">INTEGER10 </emphasis>y := 30;
      03: f(INTEGER <emphasis role="bold">INTEGER32</emphasis>) :=  INTEGER32 + 3;

</programlisting>

    <para>In line 1 and 2, the size is wrong. In line 3, we can not use
    INTEGER32 as an identifier for formal parameter.</para>
  </sect1>

  <sect1 id="_2041">
    <title>2041</title>

    <indexterm>
      <primary>2041</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for REAL type</emphasis></para>

    <para>A REAL type can be 4 or 8 bytes. So the valid forms are: REAL4,
    REAL8, and REAL. The last one will use the default size: 8.</para>

    <para>Solution: Choose the proper size. Example:</para>

    <programlisting>
      REAL3 a := 1.2;
  </programlisting>
  </sect1>

  <sect1 id="_2042">
    <title>2042</title>

    <indexterm>
      <primary>2042</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for DATA type</emphasis></para>

    <para>The size of DATA type can be any positive integer; zero or negative
    integers are not allowed. When used as a function parameter type, the size
    can be omitted.</para>

    <para>Solution: Choose a proper size. Example:</para>

    <programlisting>01: DATA0 a := ’03DF21';</programlisting>
  </sect1>

  <sect1 id="_2043">
    <title>2043</title>

    <indexterm>
      <primary>2043</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for STRING type</emphasis></para>

    <para>The size of STRING type can be any positive integer; zero or
    negative integers are not allowed.</para>

    <para>When used as a function parameter type, the size can be
    omitted.</para>

    <para>Solution: Choose a proper size. Example:</para>

    <programlisting>STRING0 abc := ‘abc’;</programlisting>
  </sect1>

  <sect1 id="_2044">
    <title>2044</title>

    <indexterm>
      <primary>2044</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for VARSTRING
    type</emphasis></para>

    <para>The size of VARSTRING can be any positive integer; zero or negative
    integers are not allowed. Solution: Choose the proper size.</para>

    <para>Example:</para>

    <programlisting>VARSTRING0 abc := ‘abc’;</programlisting>
  </sect1>

  <sect1 id="_2045">
    <title>2045</title>

    <indexterm>
      <primary>2045</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for DECIMAL
    type</emphasis></para>

    <para>A DECIMAL type does not specify or specifies an invalid size. An
    valid size must be specified for DECIMAL type. DECIMAL can be:</para>

    <para>• DECIMALn, where n can be 0-32 (inclusive)</para>

    <para>• DECIMALn_m, where n, m can be 0-32 (inclusive), and m must be less
    than or equal to n. In the above, n defines the number of digits in a
    packed decimal value while m defines the</para>

    <para>number of digits that appear after the decimal point.</para>

    <para>Solution: Choose a proper size. Example:</para>

    <programlisting>01: DECIMAL x1 := 20;
02: DECIMAL10_11 x2 := 20;</programlisting>

    <para>In line 1, no size is defined. In line 2, the size of the fractional
    portion is greater than the total number of digits.</para>
  </sect1>

  <sect1 id="_2046">
    <title>2046</title>

    <indexterm>
      <primary>2046</primary>
    </indexterm>

    <para>A UDECIMAL type does not specify a size or specifies an invalid
    size. UDECIMAL is a short-</para>

    <para>hand alias for UNSIGNED DECIMAL. UDECIMAL can be:</para>

    <para>• UDECIMALn, where n can be 0-32 (inclusive), OR</para>

    <para>• UDECIMALn_m, where n, m can be 0-32 (inclusive), and m must be
    less than or equal to</para>

    <para>n.</para>

    <para>In the above, n defines the number of digits in a packed decimal
    value. m defines the number of digits after the decimal point.</para>

    <para>Solution: Choose a proper size. Example:</para>

    <programlisting>
      01: UDECIMAL x1 := 20;
      02: UDECIMAL10_11 x2 := 20;
      03: UDECIMAL34 x3 := 20;

</programlisting>

    <para>In line 1, no size is defined. In line 2, the size of percision is
    greater than the total length. In line</para>

    <para>3, the size is greater than 32.</para>

    <para>Solution: Choose the proper size.</para>
  </sect1>

  <sect1 id="_2047">
    <title>2047</title>

    <indexterm>
      <primary>2047</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for BITFIELD
    type</emphasis></para>

    <para>A BITFIELD (PROVISIONAL DOCUMENTATION, NOT YET IMPLEMENTED)</para>

    <para>type must have a valid size. A valid size for BITFIELD must:</para>

    <para>• explicitly specify the size</para>

    <para>• spcify the size in the range 1..64 (inclusive) Solution: Choose a
    proper size.</para>

    <para>Example:</para>

    <programlisting>
      01: MyRec := RECORD
      02: BITFIELD sex := 1;
      03: BITFIELD0 married := 1;
      04: BITFIELD2 class := 1;
      05: BITFIELD65 age := 100;
      06: END;

</programlisting>

    <para>In line 2, sex does not specify a size. In line 3, married specifies
    a size of 0. In line 5, age speci- fies a size of 65. All these are not
    allowed. In line 4, class has size of 2, which is legal.</para>
  </sect1>

  <sect1 id="_2048">
    <title>2048</title>

    <indexterm>
      <primary>2048</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid size for UNSIGNED
    type</emphasis></para>

    <para>UNSIGNEDn is a shorthand alias for UNSIGNED INTEGERn. So see Error
    2040.</para>
  </sect1>

  <sect1 id="_2049">
    <title>2049</title>

    <indexterm>
      <primary>2049</primary>
    </indexterm>

    <para>Invalid size for QSTRING type</para>
  </sect1>

  <sect1 id="_2050">
    <title>2050</title>

    <indexterm>
      <primary>2050</primary>
    </indexterm>

    <para><emphasis role="bold">Recursive macro call</emphasis></para>

    <para>Recursive macro calls are not allowed. Recursive calls happen when a
    macro call itself directly or indirectly. Unlike functions, macros have no
    way to terminate once a recursive call starts; because the parser just
    does simple text substitution for macros. Recursive functions terminate at
    runtime by proper runtime logic.</para>

    <para>Note that since there are no forward references in ECL, it is also
    not possible to contruct a legal recursive function call. This situation
    may be changed in the future, however, recursive macros will still not be
    allowed due to the above reason.</para>

    <para>Solution: Change the code to eliminate the recursion.
    Example:</para>

    <programlisting>
      01: f(x) := MACRO
      02: g(x)+3
      03: ENDMACRO;
      04:
      05: g(x) := MACRO
      06: f(x)+2
      07: ENDMACRO;
      08:
      09: h(X) := MACRO
      10: h(x)+1
      11: ENDMACRO;
      12:
      13: abc := <emphasis role="bold">g(3)</emphasis>;
      14: xyz := <emphasis role="bold">h(4)</emphasis>;

</programlisting>

    <para>In the example, macro f calls g, and g calls f again. Therefore we
    have an indirect recursive call. In macro h, it directly calls itself
    recursively.</para>
  </sect1>

  <sect1 id="_2051">
    <title>2051</title>

    <indexterm>
      <primary>2051</primary>
    </indexterm>

    <para><emphasis role="bold">No matching ENDMACRO found</emphasis></para>

    <para>The ENDMACRO keyword must terminate a MACRO definition.</para>

    <para>Due to the way macros are implemented internally, sometimes this
    error will appear in an unex- pected place. This happens within a macro
    call because, according to the grammar the parser thinks it should end the
    macro call, but the macro definition actually still has more code to
    generate. This normally indicates an error in the macro, the parameter(s)
    passed to the macro, or a combination of the two.</para>

    <para>Solution: Check the macro definition and the calls. Since the parser
    only realizes that an ENDMACRO is missing when it reaches the end of a
    file or a module, the position its report may be far away from the place
    it actually occurs.</para>

    <para>Example:</para>

    <programlisting>
      01: MyMacro(INTEGER i) := MACRO
      02: i + 4;
      03:
      04: MyMacro(5);

</programlisting>

    <para>MyMacro is not terminated by an ENDMACRO. But the parser report the
    error at end of line 4 (the end of the file).</para>
  </sect1>

  <sect1 id="_2052">
    <title>2052</title>

    <indexterm>
      <primary>2052</primary>
    </indexterm>

    <para><emphasis role="bold">EOF encountered while gathering macro
    parameters</emphasis></para>

    <para>The file ends while the parser is still trying to look for macro
    parameters. This means that the code is not yet complete.</para>

    <para>Solution: Complete the code with proper parameters, and ending ‘)’.
    Example:</para>

    <programlisting>
      01: m2(x) := MACRO
      02: 10+x
      03: ENDMACRO;
      04: m2(1
 </programlisting>

    <para>In line 4, macro call m2 doesn’t have complete parameters.</para>
  </sect1>

  <sect1 id="_2053">
    <title>2053</title>

    <indexterm>
      <primary>2053</primary>
    </indexterm>

    <para>No type is allowed for macro parameter</para>
  </sect1>

  <sect1 id="_2054">
    <title>2054</title>

    <indexterm>
      <primary>2054</primary>
    </indexterm>

    <para>Default value for macro parameter must be constant</para>
  </sect1>

  <sect1 id="_2055">
    <title>2055</title>

    <indexterm>
      <primary>2055</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2056">
    <title>2056</title>

    <indexterm>
      <primary>2056</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2061">
    <title>2061</title>

    <indexterm>
      <primary>2061</primary>
    </indexterm>

    <para><emphasis role="bold">Too many parameters: XXX parameters
    expected</emphasis></para>

    <para>Too many parameters are supplied for a function call or macro
    call.</para>

    <para>Solution: Check the definition of the function or macro. Supply the
    proper number of param- eters as required. Be careful about the scope
    rules in ECL, especially the local scope. See Ex- ample 2 below.</para>

    <para>Example 1:</para>

    <programlisting>
      01: f(x) := 4;
      02:
      03: m1() := MACRO
      04: 10
      05: ENDMACRO;
      06:
      07: m2(x) := MACRO
      08: 10+x
      09: ENDMACRO;
      10:
      11: <emphasis role="bold">f(2,3)</emphasis>;
      12: <emphasis role="bold">m1(1)</emphasis>;
      13: <emphasis role="bold">m2(1,2)</emphasis>;
 </programlisting>

    <para>All the calls in lines 11, 12, and 13 have extra parameters than
    that are needed. Example 2:</para>

    <programlisting>
      01: f(x) := x+1;
      02:
      03: EXPORT ab := 1;
      04:
      05: f(x,y) := x+y;
      06:
      07: f(3,4,1);

</programlisting>

    <para>In this example, function f is defined twice. Since an EXPORT or
    SHARED Attribute ends the local scope of an attribute/function/macro name,
    the f() in line 7 is a call to function f in line 5, not in line 1,
    therefore too many parameters are supplied.</para>
  </sect1>

  <sect1 id="_2062">
    <title>2062</title>

    <indexterm>
      <primary>2062</primary>
    </indexterm>

    <para><emphasis role="bold">Omitted parameter has no default
    value</emphasis></para>

    <para>A parameter to a function can be omittable when it is defined to
    have a default value. When a function is called, parameters that have
    default values can be omitted or not. However, those parameters that have
    no default values defined must pass a value for the parameter.</para>

    <para>Default value parameters in ECL are more general than in C++. In
    C++, if a parameter is defined to have default value, all the parameters
    following it must have default values defined as well, and if we supply a
    value to a parameter when we call a function, all parameters before this
    parameter must have values supplied. In ECL, these two constraints do not
    hold. The user can define default values for any set of parameters,
    regardless of their order in the parameter list. The user can also choose
    to pass values to those parameters that do have default values. See
    Example 2 below.</para>

    <para>Note that macros in ECL don’t have this default value concept,
    therefore this error can never happen to a macro call.</para>

    <para>Solution: Either pass a value for the parameter, or specify a
    default value in the function defini- tion, if possible.</para>

    <para>Example 1:</para>

    <programlisting>
      01: f(x,y,z=3) := x+y;
      02:
      03: f(12);
      04: f(,2);
 </programlisting>

    <para>In line 1, function f() only has a default value defined for the
    third parameter, so we must supply values for parameters 1 and 2. In line
    3, no default value is given for parameter 2, and in line 4, no default
    value is given for parameter 1.</para>

    <para>Example 2:</para>

    <programlisting>
      01: f(x=1,y,z=3) := x+y;
      02:
      03: f(2,3,4);
      04: f(,3);
      05: f(,3,);
      06: f(,3,4);
      07: f(1,2);
 </programlisting>

    <para>In line 1, function f() defines default values for parameters 1 and
    3, which is perfectly OK in ECL, but is not allowed in C++. Calls in lines
    3-7 are all legal in ECL, while calls in lines 4,5,6 are illegal in C++
    (supposing line 1 were legal in C++).</para>
  </sect1>

  <sect1 id="_2063">
    <title>2063</title>

    <indexterm>
      <primary>2063</primary>
    </indexterm>

    <para><emphasis role="bold">Too few parameters supplied</emphasis></para>

    <para>Too few parameters are supplied to a macro call. Note that since
    function calls in ECL have the</para>

    <para>default value for omitted parameter rule (Error C2062), we can never
    get this error from a</para>

    <para>function call. Be careful with the scoping rules in ECL, as shown in
    Example 2.</para>

    <para>Example 1:</para>

    <programlisting>
      01: m(x) := MACRO
      02: 10+x
      03: ENDMACRO;
      04: <emphasis role="bold">m()</emphasis>;
      05: m2(x,y) := MACRO
      06: 10+x
      07: ENDMACRO;
      08: <emphasis role="bold">m2(1)</emphasis>;

</programlisting>

    <para>The macro calls in both lines 4 and 8 are supplied fewer parameters
    than required. Example 2:</para>

    <programlisting>
        01: m() := MACRO  
        02: 2             
        03: ENDMACRO;     
        04: SHARED y:= 3; 
        05: m(x) := MACRO 
        06: x+2           
        07: ENDMACRO;     
        08: m();          

</programlisting>

    <para>In this example, call m() in line 8 is to the macro defined in lines
    5-7, not the macro defined in lines 1-3. The reason is that the SHARED
    statement in line 4 ends the scope of local macro m() in line 1.</para>
  </sect1>

  <sect1 id="_2064">
    <title>2064</title>

    <indexterm>
      <primary>2064</primary>
    </indexterm>

    <para><emphasis role="bold">param type mismatch</emphasis></para>

    <para>The parameter supplied to a function call has a different type than
    the type specified for the</para>

    <para>function definition. Automatic type promotion (implicit type
    casting) will be applied when the</para>

    <para>compiler tries to match the types. Therefore, we can legally use an
    integer to call a function that</para>

    <para>requires a real parameter. Narrow casting (down casting from real to
    integer) is also applied</para>

    <para>when proper.</para>

    <para>A macro is used for text substitution, only. There is no type
    information associated with a macro parameter. Therefore, this error only
    applies to function calls.</para>

    <para>Solution: Check the function definition and make sure the types
    match. Use type cast when necessary.</para>

    <para>Example:</para>

    <programlisting>
      01: f(integer i) := i+1;
      02: f(‘123’);

</programlisting>

    <para>In line 2, actual parameter ‘123’ is a string, not an integer as
    expected by the definition of f. We can use type casting to correct
    this:</para>

    <programlisting>f((INTEGER)‘123’);</programlisting>
  </sect1>

  <sect1 id="_2065">
    <title>2065</title>

    <indexterm>
      <primary>2065</primary>
    </indexterm>

    <para>Wrong number of parameters: either 2061 or 2062</para>
  </sect1>

  <sect1 id="_2066">
    <title>2066</title>

    <indexterm>
      <primary>2066</primary>
    </indexterm>

    <para>non-typed or void expression can not used as parameter</para>
  </sect1>

  <sect1 id="_2071">
    <title>2071</title>

    <indexterm>
      <primary>2071</primary>
    </indexterm>

    <para><emphasis role="bold">Constant expression expected</emphasis></para>

    <para>A constant expression is expected. A constant expression can
    be:</para>

    <itemizedlist>
      <listitem>
        <para>any constant value, such as: 123, ‘abc’.</para>
      </listitem>

      <listitem>
        <para>any expression that evaluates to a constant value, such as:
        2*4+5, ‘abc’+’def ’, 3&gt;2 &amp;&amp; 3^2=8.</para>
      </listitem>

      <listitem>
        <para>any function or macro that evaluates at compile time to a
        constant value. For example, if we have the following:</para>

        <para><programlisting>c(x) := x*2;
y := 3;</programlisting>Then c(y) is a constant since at compile time, it can
        be evaluted as a constant value 6.</para>
      </listitem>
    </itemizedlist>

    <para>The third rule is different from languages like C and Java where a
    function’s return value is never regarded as a compile time constant,
    macros in C (Java doesn’t have macros) are not an issue since they
    disappear after preprocessing.</para>

    <para>The following are not constants:</para>

    <itemizedlist>
      <listitem>
        <para>RANDOM(), or any expression that contains RANDOM()</para>
      </listitem>

      <listitem>
        <para>The result from a dataset, such as COUNT(Person())</para>
      </listitem>

      <listitem>
        <para>Any expression that contains any non-constant value(s).</para>

        <para>Solution: Choose another name for the field, or remove one if
        they are just duplicated.</para>

        <para>Example 1:</para>

        <para><programlisting>      01: STRING8 MyString1 := INTFORMAT(10, <emphasis
              role="bold">RANDOM()</emphasis>, 1); 
      02: c(x) := x*2;
      03: y := 3;
      04: STRING8 MyString2 := INTFORMAT(10, c(y), 1);
      05: ct := COUNT(Person());
      06: STRING8 MyString3 := INTFORMAT(10, <emphasis role="bold">ct</emphasis>, 1);
</programlisting>Both RANDOM() in line 1 and ct in line 6 are not constant,
        but c(y) in line 4 is constant. Example 2:</para>

        <para><programlisting>      01: loadxml(‘myxml.xml’);
      02: #DECLARE (S)
      03: #SET (S, <emphasis role="bold">RANDOM()</emphasis>)
      04: #APPEND(S, <emphasis role="bold">RANDOM()</emphasis>)
      05: #IF (<emphasis role="bold">RANDOM()</emphasis>)
      06: #APPEND(S, ‘x := 1; ‘)
      07: #ELSE
      08: #APPEND(S, ‘x := 2; ‘)
      09: #END
</programlisting></para>
      </listitem>
    </itemizedlist>

    <para>All these RANDOM() function calls are illegal since constants are
    expected where they appear. To test this, an xml file named myxml.xml must
    be provided, but the content of the file is not important for our
    concern.</para>
  </sect1>

  <sect1 id="_2072">
    <title>2072</title>

    <indexterm>
      <primary>2072</primary>
    </indexterm>

    <para><emphasis role="bold">Expected numeric expression</emphasis></para>

    <para>An expression that is not compatible with a numeric type is
    encountered. A numeric expression</para>

    <para>can be: INTEGER, REAL, or DECIMAL (for all legal size, and signed,
    unsigned types). This</para>

    <para>error happens in the +, -, *, / operations. In the
    expression:</para>

    <programlisting>expr1 + expr2</programlisting>

    <para>if one of the expr1 and expr2 is string, the other is implicitly
    cast to string (if it is not already string, and can be cast to string).
    For instance:</para>

    <programlisting>x := 123 + ‘STR’</programlisting>

    <para>is a legal expression, and x has the value: ‘123STR’. For other
    operations (-, *, /), only numeric values are allowed. Implicit cast may
    be involved, but:</para>

    <para>• A string is not implicitly cast to a numeric value (while an
    numeric can be implicitly cast to a string value).</para>

    <para>• A boolean vaue cannot be cast to either string or numeric
    values.</para>

    <para>• A DATA value can only be cast to or from STRING, and not to or
    from a numeric value.</para>

    <para>Solution: Change the expression to be a numeric type. Use explict
    casting where proper. Example:</para>

    <programlisting>      01: x1 := <emphasis role="bold">TRUE </emphasis>+ 35;
      02:
      03: x2 := 35 - <emphasis role="bold">‘STR’</emphasis>;
      04:
      05: x3 := 34 * <emphasis role="bold">‘STR’</emphasis>;
      06:
      07: x4 := 12 * <emphasis role="bold">x’abcd’</emphasis>;
</programlisting>

    <para>All bold expressions are not numeric (and cannot be implicitly cast
    to a numeric value).</para>
  </sect1>

  <sect1 id="_2073">
    <title>2073</title>

    <indexterm>
      <primary>2073</primary>
    </indexterm>

    <para><emphasis role="bold">Expected boolean expression</emphasis></para>

    <para>A boolean expression is expected where this error occurs. For C
    programmers, integer is not</para>

    <para>compatible with boolean in ECL. So 0, 1 or 2 are not a legal boolean
    values as in C. You can cast</para>

    <para>an INTEGER to a BOOLEAN.</para>

    <para>The following is a partial list of where a boolean expression is
    expected:</para>

    <para>• IF(condition, expr1,expr2)</para>

    <para>• MAP(condtion1=&gt;expr1,…,condition_n=&gt;exprn, defvalue)</para>

    <para>• IFBLOCK(condition)</para>

    <para>• WHEN</para>

    <para>• WHICH(condition1,…,conditions)</para>

    <para>• REJECTED(condition1,…,conditions)</para>

    <para>• #IF(condition)</para>

    <para>Solution: Use boolean expression instead. Use comparison (=, !=,
    &lt;&gt;, etc.) to change an integer to a boolean when proper.</para>

    <para>Example:</para>

    <programlisting>      01: x1 := NOT <emphasis role="bold">2</emphasis>;
      02: x2 := FALSE AND <emphasis role="bold">‘STR’</emphasis>;
      03: x3 := TRUE OR <emphasis role="bold">x’abcd’</emphasis>;
      04: x4 := IF (<emphasis role="bold">2</emphasis>,3,4);
      05: x5 := MAP(<emphasis role="bold">1</emphasis>=&gt;3,4);
      06: x6 := WHICH(<emphasis role="bold">‘2’</emphasis>,3&lt;4);
</programlisting>

    <para>All the bol expressions should be replaced by boolean
    expressions.</para>
  </sect1>

  <sect1 id="_2074">
    <title>2074</title>

    <indexterm>
      <primary>2074</primary>
    </indexterm>

    <para><emphasis role="bold">‘(‘ expected</emphasis></para>

    <para>An open parenthesis ‘(’ is missing. This error normally happens in
    ECL template commands:</para>

    <para>• #DECLARE</para>

    <para>• #IF</para>

    <para>• #FOR</para>

    <para>• #SET</para>

    <para>Solution: Add a ‘(‘ and ‘)’ if needed. Example:</para>

    <programlisting>
      01: loadxml(‘myxml.xml’)
      02:
      03: #DECLARE <emphasis role="bold">s</emphasis>
      04:
      05: #IF <emphasis role="bold">TRUE</emphasis>
      06: #END
      07:
      08: #SET <emphasis role="bold">s</emphasis>
      09:
      10: #FOR <emphasis role="bold">item(%’type’% = ‘count’)</emphasis>
      11: #APPEND(s, ‘count’)
      12: #END

</programlisting>

    <para>All bold expressions should be surrounded by parentheses.</para>
  </sect1>

  <sect1 id="_2075">
    <title>2075</title>

    <indexterm>
      <primary>2075</primary>
    </indexterm>

    <para><emphasis role="bold">‘)’ expected</emphasis></para>

    <para>A close parenthesis ‘)’ is missing. This error normally happens in
    ECL template commands:</para>

    <para>Solution: Add the missing ‘)’.</para>

    <para>Example:</para>

    <programlisting>
      01: loadxml(‘myxml.xml’)
      02:
      03: #DECLARE (s
      04:
      05: #IF (TRUE
      06: #END
      07:
      08: #SET (s,3
      09:
      10: #FOR (item(%’type’% = ‘cunt’)
      11: #APPEND(s, ‘count’)
      12: #END

</programlisting>

    <para>The compiler may not do well enough to point out every missing ‘)’
    in this example, so looking around is always a good idea.</para>
  </sect1>

  <sect1 id="_2076">
    <title>2076</title>

    <indexterm>
      <primary>2076</primary>
    </indexterm>

    <para><emphasis role="bold">',' expected </emphasis></para>

    <para>A comma (‘,’) is expected. Normally this means another parameter is
    expected, or the program construct is incomplete.</para>

    <para>Solution: Check the context where the error occurs and make sure to
    supply complete parameters or complete constructs.</para>

    <para>Example:</para>

    <programlisting>
      01: #SET (s)

</programlisting>

    <para>#SET expects two parameters instead of one.</para>
  </sect1>

  <sect1 id="_2077">
    <title>2077</title>

    <indexterm>
      <primary>2077</primary>
    </indexterm>

    <para><emphasis role="bold">identifier expected</emphasis></para>

    <para>An identifier is expected. This normally means the code expected an
    attribute name. Solution: Check the context, and make sure understand the
    construct you are using.</para>

    <para>Example:</para>

    <programlisting>      01: #DECLARE (1)
      02: #SET(1,2)</programlisting>
  </sect1>

  <sect1 id="_2078">
    <title>2078</title>

    <indexterm>
      <primary>2078</primary>
    </indexterm>

    <para>; expected</para>
  </sect1>

  <sect1 id="_2079">
    <title>2079</title>

    <indexterm>
      <primary>2079</primary>
    </indexterm>

    <para>Expected an 8 byte file position</para>
  </sect1>

  <sect1 id="_2080">
    <title>2080</title>

    <indexterm>
      <primary>2080</primary>
    </indexterm>

    <para>Fileposition should be the last field in an index</para>
  </sect1>

  <sect1 id="_2081">
    <title>2081</title>

    <indexterm>
      <primary>2081</primary>
    </indexterm>

    <para><emphasis role="bold">Import names unknown module
    XXX</emphasis></para>

    <para>The IMPORT names a module that appears not to exist. In ECL, ll
    modules are defined and</para>

    <para>stored in a central ECL repository.</para>

    <para>Solution: Make sure the module exists in the ECL repository and its
    name is spelled correctly for the IMPORT. If you believe the module is
    there and you still have problem, this is often a</para>

    <para>system configuration problem. Unless you are unfamiliar with the
    system, contact your system administrator.</para>

    <para>The following information is only for the advanced user who will do
    the configuration by him/ herself. If you are using Query Builder program,
    use the Connections tab in the File/Preferences dialog. Use the Quick
    Config button if you can. If youare running a local ECL server, you can
    first use the Quick Config to set up the Jack and Hole cluster. Then
    change the ECL server to point to you machine (either the machine name or
    IP will be OK).</para>

    <para>Example:</para>

    <programlisting>      IMPORT unknown_module;
</programlisting>

    <para>In the above example, unknown_module is not the ECL
    repository.</para>
  </sect1>

  <sect1 id="_2091">
    <title>2091</title>

    <indexterm>
      <primary>2091</primary>
    </indexterm>

    <para><emphasis role="bold">JOINED must specify a sorted
    dataset</emphasis></para>

    <para>In the SORT function:</para>

    <para>SORT (recordset, value [, value …], JOINED(joinedset)]);</para>

    <para>the parameter to JOINED must be a sorted set.</para>

    <para>A sorted dataset is either a dataset that is labeled as SORTED, or
    the result set of a SORT</para>

    <para>function.</para>

    <para>Solution: Label the dataset as SORTED if it is already sorted,
    otherwise sort it first. Normally, we need a temporary attribute to hold
    the sorted dataset because of Error C2161.</para>

    <para>Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa}, hole);
      02: bbb := DATASET(‘bbb’, {STRING1 fb}, hole, aaa);
      03: sorted_bbb := SORTED(bbb, fb);
      04: OUTPUT(SORT(aaa, fa, JOINED(bbb)));
</programlisting>

    <para>The bbb is not a sorted dataset in line 4, so we get this error.
    sorted_bbb is sorted, so we can solve this problm by replacing bbb with
    sorted_bbb.</para>
  </sect1>

  <sect1 id="_2092">
    <title>2092</title>

    <indexterm>
      <primary>2092</primary>
    </indexterm>

    <para><emphasis role="bold">JOINED data set has different number of sort
    fields</emphasis></para>

    <para>In the SORT statement:</para>

    <para><programlisting>SORT (recordset, value, [value…], JOINED(joinedset));</programlisting></para>

    <para>the number of sort fields in joinedset and the number of field to be
    sorted on for the recordset must be the same.</para>

    <para>The sort fields are the fields that are specified in the SORT or
    SORTED statement. For example:</para>

    <programlisting>SortedPerson := SORT(person, first_name, last_name);</programlisting>

    <para>has 2 sort fields: first_name, and last_name, and</para>

    <programlisting>sortedPerson2 := SORTED(sortedPerson, first_name);</programlisting>

    <para>has only 1 sort field: first_name as specified in the SORTED
    statement, although sortedPerson was sorted on two fields.</para>

    <para>Solution: Specify the same number of sort fields as required.
    Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1, STRING1 f2}, hole);
      02: sored_aaa := SORT(aaa,f1,f2);
      03: OUTPUT(SORT(aaa, f2, JOINED(sorted_aaa)));
      04: // this is OK although sorted_aaa was sorted on 2 fields.
      05: sorted_aaa2 := SORTED(sorted_aaa,f1);
      06: OUTPUT(SORT(aaa, f2, JOINED(sorted_aaa2)));
      07: bbb := DATASET(‘bbb’, {STRING1 fb}, hole);
      08: sorted_bbb := SORTED(bbb,fb);
      09: OUTPUT(SORT(aaa, f1, f2, JOINED(sorted_bbb)));
</programlisting>

    <para>In line 3, sorted_aaa has 2 sort fields (f1, f2 as defined in line
    2), while the outer sort to aaa only has 1 field (f2). In line 9,
    sorted_bbb has 1 sort field while sort on aaa has 2. Both cases are not
    allowed. Note that line 6 is OK since sorted_aaa2 has only 1 sort field
    specified although sorted_aaa was sorted on two fields.</para>
  </sect1>

  <sect1 id="_2093">
    <title>2093</title>

    <indexterm>
      <primary>2093</primary>
    </indexterm>

    <para><emphasis role="bold">Component of JOINED has different type to this
    sort</emphasis></para>

    <para>In the SORT statement:</para>

    <para><programlisting>SORT (recordset, value, [value…], JOINED(joinedset));</programlisting></para>

    <para>the type of each field specified in SORT (by value, [value…]) must
    be the same as the sort fields</para>

    <para>in the joinedset. The type is compared in the order they are
    specified. (Note that they must have</para>

    <para>the same number of fields, see Error 2092.)</para>

    <para>Solution: Make sure they have the same types. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1, BOOLEAN f2}, hole);
      02: sorted_aaa := SORT(aaa,f1);
      03: OUTPUT(SORT(aaa, f2, JOINED(sorted_aaa)));
      04:
      05: sorted_aaa1 := SORT(aaa,f1,f2);
      06: OUTPUT(SORT(aaa, f2, f1, JOINED(sorted_aaa1)));
</programlisting>

    <para>In line 2, sorted_aaa is sorted on f1, whose type is STRING1.
    However, in line 3, we are sorting aa on field f2 which is of type
    BOOLEAN. In line 6, we should know that the order of the fields
    matters.</para>
  </sect1>

  <sect1 id="_2094">
    <title>2094</title>

    <indexterm>
      <primary>2094</primary>
    </indexterm>

    <para><emphasis role="bold">Too many joined clauses</emphasis></para>

    <para>In a SORT statement, only one JOINED clause is allowed. If we give
    more than one JOINED clause, we get this error.</para>

    <para>Solution: Remove extra JOINED clause, and only keep one.
    Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1, BOOLEAN f2}, hole);
      02: sorted_aaa := SORT(aaa,f1);
      03: OUTPUT(SORT(aaa, f1, JOINED(sorted_aaa), JOINED(sorted_aaa)));
</programlisting>

    <para>Two JOINED clauses are presented in the SORT of line 3.</para>
  </sect1>

  <sect1 id="_2095">
    <title>2095</title>

    <indexterm>
      <primary>2095</primary>
    </indexterm>

    <para>Implicit joins are only supported in HOLE</para>
  </sect1>

  <sect1 id="_2096">
    <title>2096</title>

    <indexterm>
      <primary>2096</primary>
    </indexterm>

    <para>The list to be sorted on can not be empty</para>
  </sect1>

  <sect1 id="_2097">
    <title>2097</title>

    <indexterm>
      <primary>2097</primary>
    </indexterm>

    <para>Invalid size for UNICODE or VARUNICODE type</para>
  </sect1>

  <sect1 id="_2098">
    <title>2098</title>

    <indexterm>
      <primary>2098</primary>
    </indexterm>

    <para>Incompatible locales in unicode arguments of binary operation</para>
  </sect1>

  <sect1 id="_2099">
    <title>2099</title>

    <indexterm>
      <primary>2099</primary>
    </indexterm>

    <para>Bad locale name</para>
  </sect1>

  <sect1 id="_2100">
    <title>2100</title>

    <indexterm>
      <primary>2100</primary>
    </indexterm>

    <para><emphasis role="bold">Definition must define EXPORTed or SHAREed
    value for XXX.</emphasis></para>

    <para>You are trying to use an attribute that is defined in a module but
    not EXPORTed or SHARED. If you want use an attribute that is defined in
    another module, the attribute must be EXPORTed. If you are using an
    attribute defined in the same module, bt in a different file (a Query
    Build window), it must be defined as SHARED.</para>

    <para>Solution: Export or share the attribute. Example:</para>

    <programlisting>Inside MyModule:
      01: SmallPersonSet := CHOOSEN(Person(), 50);

ECL code that is trying to use SmallPersonSet:
      01: import MyModule;
      02: output(MyModule.SmallPersonSet);
</programlisting>

    <para>We get this error since SmallPersonSet is defined, but neither
    EXPORTed or SHARED.</para>
  </sect1>

  <sect1 id="_2101">
    <title>2101</title>

    <indexterm>
      <primary>2101</primary>
    </indexterm>

    <para>Error in referenced attribute</para>
  </sect1>

  <sect1 id="_2110">
    <title>2110</title>

    <indexterm>
      <primary>2110</primary>
    </indexterm>

    <para><emphasis role="bold">A value for XXX has already been
    specified</emphasis></para>

    <para>In a TRANSFORM definition, each field of the return record structure
    must receive a value once (otherwise Error 2111 occurs) and only once
    (otherwise this error occurs).</para>

    <para>Note that the collective assignment definition:</para>

    <programlisting><emphasis role="bold">      SELF </emphasis>:= label;</programlisting>

    <para>places a value in each field of the result record from its matching
    field in the label record. How- ever, this collective assignment
    definition can be overwritten by a following individual assign- ment
    definition to one or more of the fields. This is a special exception. The
    execution engine can detect this situation if a following assignment
    definition exists.</para>

    <para>Solution: Make sure to only define each output field once. Use CSE,
    MAP, CHOOSE, or IF</para>

    <para>when proper so that there is only one assignment definition for each
    output ield.</para>

    <para>Example:</para>

    <programlisting>      01: NamesRec := RECORD
      02: STRING20 thename;
      03: STRING20 addr1 := ‘’;
      04: STRING20 addr2 := ‘’;
      05: END;
      06:
      07: OutRec := RECORD
      08: STRING20 thename;
      09: STRING20 addr;
      10: END;
      11:
      12: OutRec Trans(NamesRec L, INTEGER C) :=
      13: TRANSFORM
      14: SELF := L;
      15: SELF.addr := CHOOSE(C, L.addr1, L.addr2);
      16: SELF.addr := ‘ABC’;
      17: END;</programlisting>
  </sect1>

  <sect1 id="_2111">
    <title>2111</title>

    <indexterm>
      <primary>2111</primary>
    </indexterm>

    <para><emphasis role="bold">Transform does not supply a value for field
    XXX</emphasis></para>

    <para>In a TRANSFORM definition, each field of the return record structure
    must recieve a value, either explicitly by an assignment definition, or
    implicitly by</para>

    <programlisting><emphasis role="bold">      SELF </emphasis>:= label;</programlisting>

    <para>Either way, we must guarantee each field receives a value.</para>

    <para>Solution: Ensure a value is placed in the field. If you want the
    field just get the value of a corre- sponding filed in an input record,
    the two fields must have the same names.</para>

    <para>Example:</para>

    <programlisting>      01: NamesRec := RECORD
      02: //STRING20 <emphasis role="bold">thename</emphasis>;
      03: STRING20 addr1 := ‘’;
      04: STRING20 addr2 := ‘’;
      05: END;
      06:
      07: OutRec := RECORD
      08: STRING20 thename;
      09: STRING20 addr;
      10: END;
      11:
      12: OutRec Trans(NamesRec L, INTEGER C) := TRANFORM
      13: SELF := L;
      14: SELF.addr := CHOOSE(C, L.addr1, L.addr2);
      15: END;
</programlisting>

    <para>Since we commented out the field thename in NamesRec definition
    (line 2), and we don’t explicitly place a value in OutRec’s thename field
    (line 13-15), we get this error. We can either un- comment line 2, or
    place a value in OutRec.thename within the transform to resolve the
    problem.</para>
  </sect1>

  <sect1 id="_2112">
    <title>2112</title>

    <indexterm>
      <primary>2112</primary>
    </indexterm>

    <para><emphasis role="bold">A field called XXX is already defined in this
    record</emphasis></para>

    <para>A field with the same name as the one in question is already defined
    in the record. Field names must be unique within a record definition. It
    doesn’t matter if their types are the same or not.</para>

    <para>Solution: Choose another name for the field, or remove one if they
    are just duplicated. Example:</para>

    <programlisting>      01: MyRec := RECORD
      02: STRING20 name;
      03: INTEGER1 age;
      04: STRING20 <emphasis role="bold">name</emphasis>;
      05: INTEGER1 <emphasis role="bold">name</emphasis>;
      06: END;
</programlisting>

    <para>In the above example, name is aleady defined in line 2, the
    definitions in line 4 and 5 are not allowed.</para>
  </sect1>

  <sect1 id="_2113">
    <title>2113</title>

    <indexterm>
      <primary>2113</primary>
    </indexterm>

    <para>TRANSFORM required a record return type</para>
  </sect1>

  <sect1 id="_2114">
    <title>2114</title>

    <indexterm>
      <primary>2114</primary>
    </indexterm>

    <para>Can not assign type XXX to self</para>
  </sect1>

  <sect1 id="_2115">
    <title>2115</title>

    <indexterm>
      <primary>2115</primary>
    </indexterm>

    <para>Transform must have at least 1 parameter</para>
  </sect1>

  <sect1 id="_2116">
    <title>2116</title>

    <indexterm>
      <primary>2116</primary>
    </indexterm>

    <para>Dataset can not be used in transform</para>
  </sect1>

  <sect1 id="_2117">
    <title>2117</title>

    <indexterm>
      <primary>2117</primary>
    </indexterm>

    <para>Can not use dataset directly in transform parameters</para>
  </sect1>

  <sect1 id="_2121">
    <title>2121</title>

    <indexterm>
      <primary>2121</primary>
    </indexterm>

    <para><emphasis role="bold">Invalid substring range</emphasis></para>

    <para>The index to a string is in an illegal range. There are 3
    cases:</para>

    <para>• If a start index is specified, it must e in the range [1 ..
    string_len], inclusive.</para>

    <para>• If a stop index is specified, it must be in the range [1 ..
    string_len], inclusive.</para>

    <para>• If both start index and stop indexes are specified, the start
    index must be less than or equal to the stop index.</para>

    <para>The &lt;more info&gt; will explain which case the error is. If there
    are mutiple cases in one substring expression, only the first error is
    given (to reduce the number of error messages). For the C/ C++/Java
    programmers, ECL indexing always starts at element 1 (not 0).</para>

    <para>This error is a compiler error, not a runtime error. Don’t count on
    the compiler to do all the index checking for you. It is always a good
    idea to mae sure the index is in proper range. For example:</para>

    <programlisting>      01: STRING concat(STRING x, STRING y) := x+y;
      02: STRING a := ‘a’;
      03: STRING b := ‘bc’;
      04: STRING c := concat(a,b);
      05: c[10];
</programlisting>

    <para>The compiler cannot know that the index value (10) in line 5 is out
    of range. The behavior is undefined if the index is out of range at
    runtime.</para>

    <para>Solution: For indexing string constants, make sure it is in proper
    range. For strings of unknown size (like a STRING parameter passed to a
    function), use the LENGTH function as necessary.</para>

    <para>Example:</para>

    <programlisting>      01: STRING3 s := ‘abc’;
      02: s1 := s[0];
      03: s2 := s[1..4];
      04: s3 := s[3..2];
</programlisting>

    <para>We get the following error message:</para>

    <programlisting>      error C2121: Invalid substring range: start index out of [1..len] 
      error C2121: Invalid substring range: end index out of [1..len] 
      error C2121: Invalid substring range: start index &gt; end index</programlisting>
  </sect1>

  <sect1 id="_2124">
    <title>2124</title>

    <indexterm>
      <primary>2124</primary>
    </indexterm>

    <para>STORED() has zero length</para>
  </sect1>

  <sect1 id="_2130">
    <title>2130</title>

    <indexterm>
      <primary>2130</primary>
    </indexterm>

    <para><emphasis role="bold">Value for field XXX cannot be computed in this
    scope</emphasis></para>

    <para>Inside an OUTPUT, the output record specifies a field that is not
    part of the dataset. The example will help to clarify this.</para>

    <para>Solution: Remove the offending field from the output record set.
    Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa }, HOLE);
      02: bbb := DATASET(‘bbb’, {STRING1 fb }, HOLE);
      03:
      04: OUTPUT(aaa, {aaa.fa, bbb.fb});
</programlisting>

    <para>In line 4, field bbb.fb is not a field of output dataset aaa,
    therefore cannot be specified here.</para>
  </sect1>

  <sect1 id="_2131">
    <title>2131</title>

    <indexterm>
      <primary>2131</primary>
    </indexterm>

    <para><emphasis role="bold">Incorrect assertion scoping</emphasis></para>

    <para>There is a problem with the scoping of the referenced attribute.
    There are several cases.</para>

    <para>• In a filter, each referenced field must be a field of the dataset
    we are filtering. The examplewill help to clarify this.</para>

    <para>• In SORT, the field to be sorted must be a field of the dataset
    that is being sorted.</para>

    <para>• In SORTED, the field that is specified as having been sorted on
    must be a field of the dataset.</para>

    <para>And much more…</para>

    <para>Solution: Remove the offending field from the filter. Example
    1:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa }, HOLE);
      02: bbb := DATASET(‘bbb’, {STRING1 fb }, HOLE);
      03:
      04: OUTPUT(aaa(fa=’Good’, bbb.fb=’Bad’));
</programlisting>

    <para>This is a filter example. In line 4, the filter bbb.fb = ‘Bad’
    refers to a field of dataset bbb, but we are trying to filter dataset
    aaa.</para>

    <para>Example 2:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa }, HOLE);
      02: bbb := DATASET(‘aaa’, {STRING1 fb }, HOLE);
      03: ccc := SORT(aaa, fa, bbb.fb);
</programlisting>

    <para>This is a SORT example. In line 3, bbb.fb is not a field of the
    dataset aaa which we are sorting.</para>
  </sect1>

  <sect1 id="_2132">
    <title>2132</title>

    <indexterm>
      <primary>2132</primary>
    </indexterm>

    <para><emphasis role="bold">Assertion must be boolean</emphasis></para>

    <para>Each filter for a dataset must be a boolean expression. This error
    usually follows error C2073: Boolean expression expected.</para>

    <para>Solution: Change the expression in question to a boolean expression.
    Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1; STRING1 f2; }, HOLE);
      02: bbb := aaa(f1);
      03: ccc := aaa(f1*2);
</programlisting>

    <para>In line 2, f1 is not boolean type, and in line 3, f1*2 gives an
    error, and results in an unknown type filter.</para>
  </sect1>

  <sect1 id="_2133">
    <title>2133</title>

    <indexterm>
      <primary>2133</primary>
    </indexterm>

    <para>Use dataset in expression without proper context</para>
  </sect1>

  <sect1 id="_2134">
    <title>2134</title>

    <indexterm>
      <primary>2134</primary>
    </indexterm>

    <para>Parameter to fetch isn't a dataset</para>
  </sect1>

  <sect1 id="_2141">
    <title>2141</title>

    <indexterm>
      <primary>2141</primary>
    </indexterm>

    <para><emphasis role="bold">Illegal combination of
    modifers</emphasis></para>

    <para>The modifiers to attributes have an illegal combination. Duplicating
    the same modifier is an example of illegal combination. Combining some
    conflicted modifiers will be an error too, but will cause different errors
    than this one (e.g., see Error C2142).</para>

    <para>Solution: Remove any duplicated modifier. Example:</para>

    <programlisting>      01: SHARED SHARED aa := 3;
</programlisting>

    <para>Here two SHARED are used at the same time – an illegal combination.
    Remove one of them.</para>
  </sect1>

  <sect1 id="_2142">
    <title>2142</title>

    <indexterm>
      <primary>2142</primary>
    </indexterm>

    <para><emphasis role="bold">EXPORT and SHARED cannot be specified
    together</emphasis></para>

    <para>EXPORT and SHARED are both specified on an attribute, which is not
    allowed.</para>

    <para>Solution: Remove EXPORT or SHARED. Example:</para>

    <programlisting>
      01: SHARED EXPORT aa := 3;
      02: EXPORT SHARED bb := 3;
  </programlisting>

    <para>Both lines specify SHARED and EXPORT at the same time.</para>
  </sect1>

  <sect1 id="_2143">
    <title>2143</title>

    <indexterm>
      <primary>2143</primary>
    </indexterm>

    <para><emphasis role="bold">Identifier XXX is already
    defined</emphasis></para>

    <para>The identifier in question is already defined somewhere before. The
    identifier can be an attribute name, a user-defined function name, a
    user-defined macro name, etc. Functions, macros, and attributes all share
    a name space. Therefore, an identifier that is used as a function name
    cannot be used again in the same scope. See Scope rules in ECL for
    information about scoping.</para>

    <para>In ECL, an attribute can be defined only once in a given scope. Once
    defined, we cannot rede- fine it again in the same scope. In this regard,
    attributes are different from variables in the normal procedure
    programming languages.</para>

    <para>Solution: Choose another name, or make the conflicting names exist
    in different scopes, if possible. Removing EXPORT or SHARED to changethe
    scope level may make once-valid code invalid since EXPORT or SHARED
    changes the scope of any local attributes before it.</para>

    <para>Example:</para>

    <programlisting>      01: attr := 4;
      02: <emphasis role="bold">attr </emphasis>:= 3;
      03:
      04: func(x) := x*2;
      05: <emphasis role="bold">func</emphasis>(x) := x+2;
      06:
      07: macro1 := MACRO
      08: 4
      09: ENDMACRO;
      10: <emphasis role="bold">macro1 </emphasis>:= 2;
</programlisting>

    <para>In the example, all identifiers in bold are already defined before
    it.</para>
  </sect1>

  <sect1 id="_2144">
    <title>2144</title>

    <indexterm>
      <primary>2144</primary>
    </indexterm>

    <para><emphasis role="bold">Expression produces string field of unknown
    length</emphasis></para>

    <para>The compiler cannot determine the size of a string field. This
    normally is the result of some other ECL error that causes the compiler to
    have trouble evaluating the size of a string. This error happens often in
    RECORD definitions (and its IFBLOCK).</para>

    <para>Solution: If the error happens in a RECORD definition, make sure the
    field has a name, and a STRINGn type (STRING without a length cannot be
    used, otherwise you get a C2043 error). The field can be anonymous only
    if: (1) the data type is omitted, and (2) a dataset name is used as the
    expression (which is used to include all the fields from the dataset at
    their declared sizes and value types). For example:</para>

    <programlisting>      aaa := DATASET(‘aaa’,{STRING1 f1, INTEGER1 f2}, FLAT); MyRec :=
      RECORD
      aaa;
      STRING1 sex;
      END;

This is equal to:
      MyRec := RECORD STRING1 f1; INTEGER1 f2; STRING1 sex;
      END;
      
Example:
      01: STRING cat(STRING s1, STRING s2) := s1 + s2;
      02:
      03: MyRec := RECORD
      04: cat(‘abc’,’def’);
      05: END;
</programlisting>

    <para>In line 4, no name is given to the to-be-defined field of MyRec. The
    compiler tries to decide the type of the expression cat(‘abc’, ‘def ’) and
    discovers it is STRING (with no specific length) from the definition the
    cat function in line 1. Therefore you get this unknown size error. Giving
    a name and a specific size type to the field solves the problem:</para>

    <programlisting>      04: STRING6 magictag := cat(‘abc’,’def’);</programlisting>

    <para>Note that we also have to give a size explicitly to the STRING type
    in the above code, otherwise, an error C2043 occurs.</para>
  </sect1>

  <sect1 id="_2145">
    <title>2145</title>

    <indexterm>
      <primary>2145</primary>
    </indexterm>

    <para><emphasis role="bold">Different character sets in
    concatenation</emphasis></para>

    <para>The operands in string concatenation (+) have different character
    sets. In ECL, we can use ASCII or EBCDIC charset. By default, a STRING is
    ASCII. We can not concatenate an EB- CDIC string to an ASCII string (or
    vice versa).</para>

    <para>Solution: Concatenate an EBCDIC string and an ASCII string seldom
    make sense. If you do want to do this, what you really want to do is to
    change the code of one string so that the two strings have the same
    charsets. An ECL function or service can be defined to accomplish this
    task. There is no build in function or service to do this (AFAIK).</para>

    <para>Example:</para>

    <programlisting>      01: ASCII STRING3 x := ‘ABC’;
      02: EBCDIC STRING4 y := ‘ABCD’;
      03: STRING7 a := x + y;
</programlisting>

    <para>Note that in line 3, y is not an ASCII string ‘ABCD’ since we are
    defining it as an EBCDIC encoded string.</para>
  </sect1>

  <sect1 id="_2146">
    <title>2146</title>

    <indexterm>
      <primary>2146</primary>
    </indexterm>

    <para><emphasis role="bold">Type transfer: target type is larger than
    source type</emphasis></para>

    <para>In a type transfer, the size of target type is larger the size of
    source type.</para>

    <para>ECL doesn’t allow this because it doesn’t know how to fill the extra
    space in the target. However, it quietly accepts the other case: target
    size is smaller than the source type in which case data is lost. It
    assumes that the user doing the transfer knows what he is doing.</para>

    <para>Type transfer in ECL can be done using the build-in function
    TRANSFER or use the transfer operator: (&gt;, &lt;). They are
    equivalent.</para>

    <para>Solution: Make sure the size of the target type is equal to or less
    than that of the source type. Example:</para>

    <programlisting>      01: INTEGER2 x := 65;
      02: STRING3 xstr1 := TRANSFER(x,STRING3);
      03: STRING3 xstr2 := (&gt;STRING3&lt;)x;
</programlisting>

    <para>In line 1, x is defined as INTEGER2 (which has size 2). In line 2
    and 3, both target types are STRING3 (size=3). Line 2 and line 3 are doing
    the same thing: one uses TRANSFER function, the other uses (&gt;, &lt;)
    operator.</para>
  </sect1>

  <sect1 id="_2147">
    <title>2147</title>

    <indexterm>
      <primary>2147</primary>
    </indexterm>

    <para>Illegal identifier XXX: $ is not allowed</para>
  </sect1>

  <sect1 id="_2160">
    <title>2160</title>

    <indexterm>
      <primary>2160</primary>
    </indexterm>

    <para><emphasis role="bold">SIZEOF requires a field or dataset
    parameter</emphasis></para>

    <para>The build-in function SIZEOF only works with a field or DATASET. For
    C programmers,</para>

    <para>SIZEOF in ECL is different from the sizeof operator in C/C++, where
    it can be used on a data</para>

    <para>type or a variable.</para>

    <para>Solution: Use SIZEOF only on a field or a dataset as required.
    Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 f1, STRING1 f2}, hole);
      02: OUTPUT(aaa, {f1,SIZEOF(aaa),SIZEOF(f1)});
      03:
      04: INTEGER4 x := 3;
      05: sizeOfInt := SIZEOF(x);
      06: sizeOfInt4 := SIZEOF(INTEGER4);
</programlisting>

    <para>In line 2, SIZEOF is on dataset aaa or field f1. Therefore, it is
    OK. However, in lines 5 and 6, SIZEOF is on an attribute x and a data type
    INTEGER4, which will causing this compile error.</para>
  </sect1>

  <sect1 id="_2161">
    <title>2161</title>

    <indexterm>
      <primary>2161</primary>
    </indexterm>

    <para><emphasis role="bold">Nested SORTs may behave incorrectly. Split the
    attribute into two</emphasis></para>

    <para>Sort function calls are nested and may behave incorrectly. This is a
    limit of the current implementation. In the future, this limitation may be
    removed.</para>

    <para>Solution: Split the attribute into two. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa}, hole);
      02: bbb := DATASET(‘bbb’, {STRING1 fb}, hole, aaa);
      03: OUTPUT(SORT(aaa, <emphasis role="bold">SORT</emphasis>(bbb, fb)[1].fb));
</programlisting>

    <para>The compiler complains on the second SORT in line 3. We can solve
    the problem by splitting the attribute, like this:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa}, hole);
      02: bbb := DATASET(‘bbb’, {STRING1 fb}, hole, aaa);
      03: temp := SORT(bbb, fb);
      04: OUTPUT(SORT(aaa, temp[1].fb));</programlisting>
  </sect1>

  <sect1 id="_2162">
    <title>2162</title>

    <indexterm>
      <primary>2162</primary>
    </indexterm>

    <para><emphasis role="bold">Nested GROUPs may behave incorrectly. Split
    the attribute into two</emphasis></para>

    <para>Group function calls are nested and may behave incorrectly. This is
    a limit of the current implementation. In the future, this limitation may
    be removed.</para>

    <para>Solution: Split the attribute into two. Example:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa}, hole);
      02: bbb := DATASET(‘bbb’, {STRING1 fb}, hole, aaa);
      03: OUTPUT(GROUP(aaa, <emphasis role="bold">GROUP</emphasis>(bbb, fb)[1].fb));
</programlisting>

    <para>The compiler complains on the second GROUP in line 3. We can solve
    the problem by splitting the attribute, like this:</para>

    <programlisting>      01: aaa := DATASET(‘aaa’, {STRING1 fa}, hole);
      02: bbb := DATASET(‘bbb’, {STRING1 fb}, hole, aaa);
      03: temp := GROUP(bbb, fb);
      04: OUTPUT(GROUP(aaa, temp[1].fb));</programlisting>
  </sect1>

  <sect1 id="_2163">
    <title>2163</title>

    <indexterm>
      <primary>2163</primary>
    </indexterm>

    <para><emphasis role="bold">Too many operands</emphasis></para>

    <para>This error happens in the ECL template commands. The command
    expected a certain number of parameters, and the code supplies more than
    it needs.</para>

    <para>Solution: Reduce the number of parameters as required.
    Example:</para>

    <programlisting>      01: LOADXML(‘myxml.xml’);
      02:
      03: #DECLARE(S)
      04:
      05: <emphasis role="bold">#IF(S &gt; 1, S &lt; 5)</emphasis>
      06: #ENDIF
      07:
      08: <emphasis role="bold">#SET (S, ‘1’, 2)</emphasis>
</programlisting>

    <para>Both #IF and #SET need fewer parameters than they are
    supplied.</para>
  </sect1>

  <sect1 id="_2164">
    <title>2164</title>

    <indexterm>
      <primary>2164</primary>
    </indexterm>

    <para><emphasis role="bold">No XML scope active</emphasis></para>

    <para>The current statement is legal only in an XML context. For example,
    the template language is designed specifically for parsing XML code, and
    therefore requires an active XML source.</para>

    <para>Solution: Add an XML scope before the error (normally at the
    beginning of the file) using LOADXML(xml-file-name).</para>

    <para>Example:</para>

    <programlisting>      01: #DECLARE(s)
</programlisting>

    <para>We can simply add a dummy loadxml statement before line 1 to resolve
    this error:</para>

    <programlisting>     LOADXML(“myxml.xml”);
</programlisting>

    <para>The content for this example is not important, but it is important
    that the file does exist.</para>
  </sect1>

  <sect1 id="_2165">
    <title>2165</title>

    <indexterm>
      <primary>2165</primary>
    </indexterm>

    <para><emphasis role="bold">File extension must be
    ".HQL"</emphasis></para>

    <para>The file extension used to provide input for an application is
    illegal. For example, Seisint’s internal test program hqltest requires the
    .hql file extension on its input files.</para>

    <para>Solution: Change the file extension to the one required for the
    specific application. Example: N/A.</para>
  </sect1>

  <sect1 id="_2166">
    <title>2166</title>

    <indexterm>
      <primary>2166</primary>
    </indexterm>

    <para><emphasis role="bold">File XXX not found</emphasis></para>

    <para>A file is not found. This only happens with Seisint’s internal test
    programs hqltest or ecltest.</para>

    <para>Solution: Check the file name, and make sure the file exists in the
    proper directory. If the path is relative, it is relative to the current
    (working) directory.</para>
  </sect1>

  <sect1 id="_2167">
    <title>2167</title>

    <indexterm>
      <primary>2167</primary>
    </indexterm>

    <para><emphasis role="bold">Unknown identifier</emphasis></para>

    <para>The identifer is unknown for one of the following reasons:</para>

    <para>• The identifier has been misspelled.</para>

    <para>• The identifier names an attribute, function, dataset, or macro
    defined in another module that has not been imported.</para>

    <para>• The identifier is defined but it is not visible due to the scoping
    rules of ECL. In particu- lar, the identifier is probably local (not
    SHARED or EXPORTed), and there is an EX- PORT or SHARED attribute
    defintion that terminates its scope.</para>

    <para>• It is a field of a record, a dataset etc, and it is not properly
    qualified.</para>

    <para>Solution: First make sure it is spelled correctly. If it is defined
    in other module, make sure it is properly imported and qualified. If it is
    a field of some structure (like record, or table), qualify it properly
    (such as: myrecord.field, mytable.field). If it is defined as a local
    attribute to another SHARED and EXPORT attribute, either promote it to
    SHARED or EXPORTed scope, or move the code around so that the identifier’s
    defintion and the defintion using it are within the same local
    scope.</para>

    <para>Example:</para>

    <programlisting>      01: a := f(x);
      02: f(x) := x+3;
      03: EXPORT y := 4;
      04: a := f(y);
</programlisting>

    <para>In line 1, f is not defined in this module. In line 4, f is alreaday
    defined in line 2, but the scope of f in line 2 is terminated by the
    EXPORT in line 3. Make f in line 2 SHARED or move line 2 after line 3 to
    solve the problem.</para>
  </sect1>

  <sect1 id="_2168">
    <title>2168</title>

    <indexterm>
      <primary>2168</primary>
    </indexterm>

    <para>Select a field other than these grouped upon</para>
  </sect1>

  <sect1 id="_2169">
    <title>2169</title>

    <indexterm>
      <primary>2169</primary>
    </indexterm>

    <para>Aggregate field following a field that has a variable length</para>
  </sect1>

  <sect1 id="_2170">
    <title>2170</title>

    <indexterm>
      <primary>2170</primary>
    </indexterm>

    <para><emphasis role="bold">No default value for a field</emphasis></para>

    <para>A default value is required for some fields in a record. See example
    for additional information.</para>

    <para>Solution: Given a default value if proper. Most likely, a default
    value is not what you need al- though it may solve the compiler error
    problem.</para>

    <para>Example:</para>

    <programlisting>01: bbb := DATASET(‘aaa’, {STRING1 fa; }, FLAT);
02: table1 := TABLE(bbb, {STRING1 fa; STRING1 fb; });</programlisting>

    <para>In this example, we create a table from dataset aaa. Since bbb has a
    field called fa, we can have a value for field fa in the table. However,
    there is no such field called fb in dataset bbb. Hence we get an error
    saying that Field fb does not have default value. In this case, assign a
    default value to fb.</para>
  </sect1>

  <sect1 id="_2171">
    <title>2171</title>

    <indexterm>
      <primary>2171</primary>
    </indexterm>

    <para><emphasis role="bold">Object has no such a field</emphasis></para>
  </sect1>

  <sect1 id="_2180">
    <title>2180</title>

    <indexterm>
      <primary>2180</primary>
    </indexterm>

    <para><emphasis role="bold">Unknown escape sequence</emphasis></para>

    <para>Astring constant contains an unknown escape sequence. Currently, the
    only supported escape sequences are:</para>

    <para>\’ and \\</para>

    <para>For C/C++/Java programmers, don’t assume that ECL supports the
    standard escape sequences in these languages.</para>

    <para>Solution: Remove the offending escape sequence. Example:</para>

    <programlisting>      01: string x1 := ‘\r\n\t\b\x0123’;
</programlisting>

    <para>None of the above C escape sequences is supported in ECL.</para>
  </sect1>

  <sect1 id="_2181">
    <title>2181</title>

    <indexterm>
      <primary>2181</primary>
    </indexterm>

    <para><emphasis role="bold">A string end with escape char \, eg., x :=
    'abc\';</emphasis></para>

    <para>A string constant is terminated by a backslash (\). Most of the
    time, the intention of the user is</para>

    <para>to have a single quote (‘) as the last character in the string. As a
    result, he/she puts an escape</para>

    <para>character (\) in front of the single quote (‘) indicating the end of
    the string constant and the</para>

    <para>terminating quote is ignored.</para>

    <para>Solution: Add another ‘ to terminate the string or remove the
    offending \ whichever is proper. Example:</para>

    <programlisting>
      01: String s := ‘It is brothers\’;
 </programlisting>

    <para>The last character in this string is ‘, which has to be escaped as
    \’, therefore we need another ‘ to terminate the string constant.</para>
  </sect1>

  <sect1 id="_2182">
    <title>2182</title>

    <indexterm>
      <primary>2182</primary>
    </indexterm>

    <para><emphasis role="bold">Illegal hex data, it can only have
    0-9a-fA-F</emphasis></para>

    <para>Illegal characters are present in hex data. Hex data is defined
    as:</para>

    <para><programlisting>X’hex-digits’ or x’hex-digits’</programlisting></para>

    <para>A hex digit may only be any of the numbers 0 through 9 or the
    letters A through F (upper or lower case). The number of digits in the hex
    string must be even (see Warning C1002) and be greater than 0 (see Warning
    C1003).</para>

    <para>Solution: Remove the illegal characters in the hex. Example:</para>

    <programlisting>      01: DATA x1 := x’ABC<emphasis role="bold">X</emphasis>’;
      02: DATA x2 := x’<emphasis role="bold">^</emphasis>1';
      03: DATA x3 := x’A B’;
      04: DATA x4 := x’<emphasis role="bold">\n</emphasis>’;
</programlisting>

    <para>All bold chars are illegal hex digits (line 3 has a blank space
    between A and B), therefore none of the above are legal hex data
    strings.</para>
  </sect1>

  <sect1 id="_2183">
    <title>2183</title>

    <indexterm>
      <primary>2183</primary>
    </indexterm>

    <para><emphasis role="bold">Odd number of digits in hex data, e.g.,
    x'ABC'. </emphasis></para>

    <para>In a hex data constant, the number of digits in the string must be
    even because it takes two hex digits to define the value of a single byte
    of data.</para>

    <para>Solution: Check that there are no missing or extra digits. Add a
    leading or trailing 0 as required. Example:</para>

    <programlisting>      DATA d := x’ABCD123';
</programlisting>

    <para>The hex data string x’ABCD123' contains 7 digits (an odd number).
    Make it: x’0ABCD123'.</para>
  </sect1>

  <sect1 id="_2184">
    <title>2184</title>

    <indexterm>
      <primary>2184</primary>
    </indexterm>

    <para><emphasis role="bold">Empty hex data, e.g., "x".</emphasis></para>

    <para>The hex data cannot be empty.</para>

    <para>Solution: Change it to meaningful, non-empty hex data.
    Example:</para>

    <programlisting>DATA d = ‘’;</programlisting>
  </sect1>

  <sect1 id="_2185">
    <title>2185</title>

    <indexterm>
      <primary>2185</primary>
    </indexterm>

    <para>Comment is not started: ending is not allowed</para>
  </sect1>

  <sect1 id="_2186">
    <title>2186</title>

    <indexterm>
      <primary>2186</primary>
    </indexterm>

    <para>Char XXX needs to be escaped</para>
  </sect1>

  <sect1 id="_2187">
    <title>2187</title>

    <indexterm>
      <primary>2187</primary>
    </indexterm>

    <para>#ERROR statement</para>
  </sect1>

  <sect1 id="_2190">
    <title>2190</title>

    <indexterm>
      <primary>2190</primary>
    </indexterm>

    <para><emphasis role="bold">Empty record definition: no field
    defined</emphasis></para>

    <para>In a record definition, no field is defined. This is not allowed in
    ECL. For C/C++/Java programmers where empty structures (struct, class etc)
    are allowed, note that this is not allowed in ECL.</para>

    <para>Solution: Provide at least one field for the record. If you really
    don’t need a real field, add a dummy field.</para>

    <para>Example:</para>

    <programlisting>      01: MyRec := RECORD
      02: END</programlisting>
  </sect1>

  <sect1 id="_2191">
    <title>2191</title>

    <indexterm>
      <primary>2191</primary>
    </indexterm>

    <para><emphasis role="bold">Empty substring range</emphasis></para>

    <para>The sub string expression is empty. In ECL, a sub string can
    be:</para>

    <para>• str [start_index .. end_index]</para>

    <para>• str [ .. end_index]</para>

    <para>• str [ start_index .. ]</para>

    <para>• str [ one_index ]</para>

    <para>Each index is an integer within the range of 1…LENGTH(str),
    inclusive. Solution: Either provide an index value or remove the square
    brackets. Example:</para>

    <programlisting>      01: STRING s := ‘abc’;
      02: STRING subs := s[];</programlisting>
  </sect1>

  <sect1 id="_2192">
    <title>2192</title>

    <indexterm>
      <primary>2192</primary>
    </indexterm>

    <para><emphasis role="bold">Empty user type definition </emphasis></para>

    <para>The user type definition body is empty. In ECL, user types are
    defined by the TYPE structure.</para>

    <para>Solution: Provide at least one function for the defintion.
    Example:</para>

    <programlisting>      01: MyType := TYPE
      02: END</programlisting>
  </sect1>

  <sect1 id="_2193">
    <title>2193</title>

    <indexterm>
      <primary>2193</primary>
    </indexterm>

    <para><emphasis role="bold">Empty transform definition</emphasis></para>

    <para>The TRANSFORM definition body is empty. Since a RECORD type can not
    be empty (see error C2190), and each record must be assigned a value in
    the transform (see error C2111), an empty transform definition cannot be
    legal.</para>

    <para>Solution: Provide at least a trival SELF assignment. Example:</para>

    <programlisting>      01: NamesRec := RECORD
      02: STRING20 thename;
      03: END;
      04:
      05: OutRec := RECORD
      06: STRING20 thename;
      07: END;
      08:
      09: OutRec Trans(NamesRec L, INTEGER C) :=
      10: TRANSFORM
      11: END;
</programlisting>

    <para>Adding the following trival assignment definition in the TRANSFORM
    will solve the problem:</para>

    <programlisting>      SELF := L;</programlisting>
  </sect1>

  <sect1 id="_2194">
    <title>2194</title>

    <indexterm>
      <primary>2194</primary>
    </indexterm>

    <para><emphasis role="bold">Unended comment</emphasis></para>

    <para>This error indicates that EOF was reached while a comment is not
    ended. This only occurs to C- style comment: /* and */.</para>

    <para>Solution: Add an ending */ in the proper position. Example:</para>

    <programlisting>      01: a := 1;
      02: /* this is a unended comment ..
      The ending */ is missing in the above example.</programlisting>
  </sect1>

  <sect1 id="_2195">
    <title>2195</title>

    <indexterm>
      <primary>2195</primary>
    </indexterm>

    <para><emphasis role="bold">Unended string constant: string must end in
    one line</emphasis></para>

    <para>In ECL, a string constant must be complete in one line. The string
    delimitor is single quote (‘). Note that ECL doesn’t support string
    constants that span multiple lines. However, you can use the concatenation
    operator (+) to reach the goal. Since constants are folded at compile
    time, there is no performance penalty for this.</para>

    <para>Solution: Add a single quote at the end to terminate the string.
    Example:</para>

    <programlisting>      01: STRING long_string := ‘the part on first line’
      02: + ’the part on second line ‘
      03: + ‘and the third line’;
      04:
      05: STRING s := ‘unended string const;
</programlisting>

    <para>In line 1-3, we are defining a long string which spans multiple
    lines. The string in line 5 doesn’t end with a single quote. Note that the
    ‘;’ is regarded as part of the string, and will not end the string
    constant.</para>
  </sect1>

  <sect1 id="_2196">
    <title>2196</title>

    <indexterm>
      <primary>2196</primary>
    </indexterm>

    <para><emphasis role="bold">is illegal string delimiter: use '
    instead</emphasis></para>

    <para>In ECL, the string constant delimiter is the single quote (‘)
    character, not double quotes as in some other languages (C/C++/Java etc).
    Since single quote is the delimiter, it needs to be escaped if it is part
    of the string, like: ‘He\’s a nice guy’. And double quote does not need
    (and cannot use) escape.</para>

    <para>Solution: Change double quote to single quote</para>

    <para>Example:</para>

    <programlisting>      01: string s := “abc”;</programlisting>
  </sect1>

  <sect1 id="_2197">
    <title>2197</title>

    <indexterm>
      <primary>2197</primary>
    </indexterm>

    <para>Empty ifblock definition</para>
  </sect1>

  <sect1 id="_2200">
    <title>2200</title>

    <indexterm>
      <primary>2200</primary>
    </indexterm>

    <para><emphasis role="bold">EOF encountered inside #FOR</emphasis></para>

    <para>The File ends while we are examining a #FOR command. This usually
    means the terminating</para>

    <para>#END is missing.</para>

    <para>Solution: Add #END if proper. Example:</para>

    <programlisting>      01: loadxml(‘myxml.xml’);
      02: #DECLARE (x)
      03: #SET(x, 1)
      04:
      05: #FOR (x)
      06: #APPEND(s, ‘1’)</programlisting>
  </sect1>

  <sect1 id="_2201">
    <title>2201</title>

    <indexterm>
      <primary>2201</primary>
    </indexterm>

    <para><emphasis role="bold">EOF inside parameter
    gathering</emphasis></para>

    <para>EOF is encountered when the parser is trying to gather parameters.
    This normally occurs in a template command.</para>

    <para>Solution: Make sure the ECL is complete. Example:</para>

    <programlisting>
      01: LOADXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);
      02: #IF(
 </programlisting>

    <para>The #IF doesn’t have a parameter yet.</para>
  </sect1>

  <sect1 id="_2202">
    <title>2202</title>

    <indexterm>
      <primary>2202</primary>
    </indexterm>

    <para><emphasis role="bold">Template symbol has already been
    declared</emphasis></para>

    <para>In ECL template language, a symbol can only be declared once. You
    get this error if you are trying to declare it a second time. Pay
    attention to the scope rule. A symbol can be defined multiple times if it
    belongs to different scope each time. However, if you change the scoping,
    they may become within the same scope and therefore generate this
    error.</para>

    <para>Solution: Make sure to only declare each symbol once in the current
    scope. Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;x&lt;/xml&gt;’);
      02:
      03: #DECLARE(s)
      04:
      05: #FOR(i)
      06: #DECLARE(s)
      07: #BREAK
      08: #END
      09:
      10: #DECLARE(s)
</programlisting>

    <para>Since #FOR will start a new local scope, the #DECLARE in line 6
    doesn’t cause problem. However, line 10 does cause problem, because s is
    already defined in line 3 (which is in the same scope).</para>
  </sect1>

  <sect1 id="_2203">
    <title>2203</title>

    <indexterm>
      <primary>2203</primary>
    </indexterm>

    <para><emphasis role="bold">Template symbol has not been
    declared</emphasis></para>

    <para>In ECL template language, a symbol must be declared before it can be
    used. A symbol is de-</para>

    <para>clared using the #DECLARE command.</para>

    <para>Solution: Make sure you declare it before you use it.
    Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;&lt;/xml&gt;’);
      02: #SET(s, ‘abc’)
</programlisting>

    <para>In line 2, s is not declared.</para>
  </sect1>

  <sect1 id="_2204">
    <title>2204</title>

    <indexterm>
      <primary>2204</primary>
    </indexterm>

    <para><emphasis role="bold">Can not find #end for XXX</emphasis></para>

    <para>#END is missing for a # command. In ECL template language, some
    commands need a matching #END:</para>

    <para>• #FOR</para>

    <para>• #IF</para>

    <para>• #IF #ELSE</para>

    <para>• #LOOP</para>

    <para>Solution: Add a matching #END. Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;&lt;/xml&gt;’);
      02: #FOR(i)
</programlisting>

    <para>#END is needed for #FOR in line 2.</para>
  </sect1>

  <sect1 id="_2205">
    <title>2205</title>

    <indexterm>
      <primary>2205</primary>
    </indexterm>

    <para><emphasis role="bold">#ELSE does not match a #IF</emphasis></para>

    <para>#ELSE is not allowed outside a #IF structure. Note that #END will
    end a #IF statement, and</para>

    <para>#ELSE can no longer be used after the #IF structure is
    terminated.</para>

    <para>Solution: Ensure the #ELSE is inside your #IF. Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);
      02:
      03: #ELSE
      04: #DECLARE(s)
      05: #END
</programlisting>

    <para>In line 3, #ELSE doesn’t match any #IF statement.</para>
  </sect1>

  <sect1 id="_2206">
    <title>2206</title>

    <indexterm>
      <primary>2206</primary>
    </indexterm>

    <para><emphasis role="bold">#END does not match a #
    command</emphasis></para>

    <para>A #END is used only to match a # command. This error normally
    happens if an extra #END</para>

    <para>is used.</para>

    <para>Solution: Make sure you use the proper number of #END.
    Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);
      02:
      03: #IF(true)
      04: #DECLARE(s)
      05: #END
      06: #END
</programlisting>

    <para>The last #END (in line 6) is extra.</para>
  </sect1>

  <sect1 id="_2207">
    <title>2207</title>

    <indexterm>
      <primary>2207</primary>
    </indexterm>

    <para><emphasis role="bold">LoadXML failed</emphasis></para>

    <para>LoadXML() failed. The reason it failed can be:</para>

    <para>• The xml file doesn’t exist</para>

    <para>• The direct xml string is not well-formed.</para>

    <para>• The xml in the xml file is not well-formed. LoadXML() function can
    use a direct XML string, e.g.,</para>

    <para>LoadXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);</para>

    <para>Or it can load from a file, e.g.,</para>

    <para>LoadXML(‘myxml.xml’);</para>

    <para>Solution: If it is a file, make sure the file exists, and you have
    the proper permission. Also make sure the xml is well formed.</para>

    <para>Example:</para>

    <programlisting>01: LOADXML(‘non-exist-xml.xml’);</programlisting>

    <para>If non-exist-xml.xml does not exist, such an error will
    occur.</para>
  </sect1>

  <sect1 id="_2208">
    <title>2208</title>

    <indexterm>
      <primary>2208</primary>
    </indexterm>

    <para><emphasis role="bold">#BREAK is only allowed with a #FOR or
    #LOOP</emphasis></para>

    <para>In ECL template language, #BREAK can only be used inside a #FOR or
    #LOOP. Solution: Make sure it is the right context before you use
    #BREAK.</para>

    <para>Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);
      02:
      03: #IF (true)
      04: #BREAK
      05: #END
</programlisting>

    <para>#BREAK cannot be used without #FOR or #LOOP in line 4.</para>
  </sect1>

  <sect1 id="_2209">
    <title>2209</title>

    <indexterm>
      <primary>2209</primary>
    </indexterm>

    <para><emphasis role="bold">#LOOP does not have a #BREAK: an infinite loop
    will occur</emphasis></para>

    <para>In ECL template language, #LOOP is like a while(true) in C/C++. The
    only way to break out</para>

    <para>the loop is to use #BREAK. Therefore, a #LOOP without a #BREAK is an
    infinite loop, and is</para>

    <para>not allowed.</para>

    <para>Note: The compiler uses a simple method to detect infinite loops.
    Don’t depend on it to find infinite loops for you. For example:</para>

    <programlisting>      01: #LOOP
      02: #IF(false)
      03: #BREAK
      04: #END
      05: #END
</programlisting>

    <para>This example has a #BREAK inside the loop, however it is an infinite
    loop. The compiler is not smart enough to figure out this. However,
    another simple scheme is used to detect this. See Error C2210.</para>

    <para>Solution: Use #BREAK to break out of the loop. Normally, #IF is
    needed to break out of the loop conditionally.</para>

    <para>Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;dummy&lt;/xml&gt;’);
      02:
      03: #LOOP
      04: #END
</programlisting>

    <para>Line 3 and 4 forms an infinite loop. Although it does nothing, it
    will stuck the compiler if it fails to detect this.</para>
  </sect1>

  <sect1 id="_2210">
    <title>2210</title>

    <indexterm>
      <primary>2210</primary>
    </indexterm>

    <para><emphasis role="bold">Loops more than max times</emphasis></para>

    <para>This error detects more complicated infinite loops other than the
    cases in error C2209. For each</para>

    <para>#FOR or #LOOP, the compiler regards it as an infinite loop if it
    runs more than the predefined max times. The max times is quite large, and
    should be enough for normal situations.</para>

    <para>Solution: Make sure it is not an infinite loop. If you are pretty
    sure you get this error and think it is not an infinite loop (which may
    never happen to you, just believe me), contact Seisint. We can increase
    the constant or disable the check.</para>

    <para>Example:</para>

    <programlisting>      01: LOADXML(‘&lt;xml&gt;&lt;/xml&gt;’);
      02:
      03: #LOOP
      04: #IF (false)
      05: #BREAK
      06: #END
      07: #END
</programlisting>

    <para>This example is trick code that is actually an infinite loop.</para>
  </sect1>

  <sect1 id="_2211">
    <title>2211</title>

    <indexterm>
      <primary>2211</primary>
    </indexterm>

    <para>Unknown # command</para>
  </sect1>

  <sect1 id="_2212">
    <title>2212</title>

    <indexterm>
      <primary>2212</primary>
    </indexterm>

    <para>Can not fold non pure function</para>
  </sect1>

  <sect1 id="_2213">
    <title>2213</title>

    <indexterm>
      <primary>2213</primary>
    </indexterm>

    <para>Can not fold non c function</para>
  </sect1>

  <sect1 id="_2214">
    <title>2214</title>

    <indexterm>
      <primary>2214</primary>
    </indexterm>

    <para>#ELIF does not match a #IF</para>
  </sect1>

  <sect1 id="_2216">
    <title>2216</title>

    <indexterm>
      <primary>2216</primary>
    </indexterm>

    <para>Bad format for access token</para>
  </sect1>

  <sect1 id="_2220">
    <title>2220</title>

    <indexterm>
      <primary>2220</primary>
    </indexterm>

    <para>No load function is defined</para>
  </sect1>

  <sect1 id="_2221">
    <title>2221</title>

    <indexterm>
      <primary>2221</primary>
    </indexterm>

    <para>No store function is defined</para>
  </sect1>

  <sect1 id="_2222">
    <title>2222</title>

    <indexterm>
      <primary>2222</primary>
    </indexterm>

    <para>No physical length function is defined</para>
  </sect1>

  <sect1 id="_2223">
    <title>2223</title>

    <indexterm>
      <primary>2223</primary>
    </indexterm>

    <para>Inconsistent logical type</para>
  </sect1>

  <sect1 id="_2224">
    <title>2224</title>

    <indexterm>
      <primary>2224</primary>
    </indexterm>

    <para>Inconsistent physical type</para>
  </sect1>

  <sect1 id="_2225">
    <title>2225</title>

    <indexterm>
      <primary>2225</primary>
    </indexterm>

    <para>Store/Load/physicalLength(?) is not defined as func</para>
  </sect1>

  <sect1 id="_2226">
    <title>2226</title>

    <indexterm>
      <primary>2226</primary>
    </indexterm>

    <para>physicalLength must have physical type</para>
  </sect1>

  <sect1 id="_2230">
    <title>2230</title>

    <indexterm>
      <primary>2230</primary>
    </indexterm>

    <para>Function is already defined</para>
  </sect1>

  <sect1 id="_2231">
    <title>2231</title>

    <indexterm>
      <primary>2231</primary>
    </indexterm>

    <para>Attribute is already defined</para>
  </sect1>

  <sect1 id="_2232">
    <title>2232</title>

    <indexterm>
      <primary>2232</primary>
    </indexterm>

    <para>Invalid library entry</para>
  </sect1>

  <sect1 id="_2233">
    <title>2233</title>

    <indexterm>
      <primary>2233</primary>
    </indexterm>

    <para>Invalid entrypoint: must be valid C identifier.</para>
  </sect1>

  <sect1 id="_2234">
    <title>2234</title>

    <indexterm>
      <primary>2234</primary>
    </indexterm>

    <para>Function in service can not specify EXPORT or SHARED</para>
  </sect1>

  <sect1 id="_2235">
    <title>2235</title>

    <indexterm>
      <primary>2235</primary>
    </indexterm>

    <para>Entrypoint is not defined, default to XXX</para>
  </sect1>

  <sect1 id="_2236">
    <title>2236</title>

    <indexterm>
      <primary>2236</primary>
    </indexterm>

    <para>Invalid include entry</para>
  </sect1>

  <sect1 id="_2237">
    <title>2237</title>

    <indexterm>
      <primary>2237</primary>
    </indexterm>

    <para>Serive does need a type</para>
  </sect1>

  <sect1 id="_2238">
    <title>2238</title>

    <indexterm>
      <primary>2238</primary>
    </indexterm>

    <para>Conflicted attributes defined</para>
  </sect1>

  <sect1 id="_2239">
    <title>2239</title>

    <indexterm>
      <primary>2239</primary>
    </indexterm>

    <para>Invalid initfunction: must be valid C identifier</para>
  </sect1>

  <sect1 id="_2240">
    <title>2240</title>

    <indexterm>
      <primary>2240</primary>
    </indexterm>

    <para>Load library failed</para>
  </sect1>

  <sect1 id="_2241">
    <title>2241</title>

    <indexterm>
      <primary>2241</primary>
    </indexterm>

    <para>Load procedure in library failed</para>
  </sect1>

  <sect1 id="_2242">
    <title>2242</title>

    <indexterm>
      <primary>2242</primary>
    </indexterm>

    <para>library is not defined (it is an error in template)</para>
  </sect1>

  <sect1 id="_2243">
    <title>2243</title>

    <indexterm>
      <primary>2243</primary>
    </indexterm>

    <para>Exception occurs when executing service function</para>
  </sect1>

  <sect1 id="_2244">
    <title>2244</title>

    <indexterm>
      <primary>2244</primary>
    </indexterm>

    <para>Service can not have any parameter</para>
  </sect1>

  <sect1 id="_2250">
    <title>2250</title>

    <indexterm>
      <primary>2250</primary>
    </indexterm>

    <para>LOADXML is not an attribute: it can only used alone for test
    purpose</para>
  </sect1>

  <sect1 id="_2251">
    <title>2251</title>

    <indexterm>
      <primary>2251</primary>
    </indexterm>

    <para>Invalid transform for ITERATE</para>
  </sect1>

  <sect1 id="_2252">
    <title>2252</title>

    <indexterm>
      <primary>2252</primary>
    </indexterm>

    <para>Invalid transform for JOIN</para>
  </sect1>

  <sect1 id="_2255">
    <title>2255</title>

    <indexterm>
      <primary>2255</primary>
    </indexterm>

    <para>expected a DATASET(...)</para>
  </sect1>

  <sect1 id="_2256">
    <title>2256</title>

    <indexterm>
      <primary>2256</primary>
    </indexterm>

    <para>Only one arg supplied in record for INDEX</para>
  </sect1>

  <sect1 id="_2257">
    <title>2257</title>

    <indexterm>
      <primary>2257</primary>
    </indexterm>

    <para>Parameter to STORED() should be a valid id</para>
  </sect1>

  <sect1 id="_2260">
    <title>2260</title>

    <indexterm>
      <primary>2260</primary>
    </indexterm>

    <para>A field is mapped more than once</para>
  </sect1>

  <sect1 id="_2261">
    <title>2261</title>

    <indexterm>
      <primary>2261</primary>
    </indexterm>

    <para>Dataset has no field as required or mapped</para>
  </sect1>

  <sect1 id="_2262">
    <title>2262</title>

    <indexterm>
      <primary>2262</primary>
    </indexterm>

    <para>A map is not used</para>
  </sect1>

  <sect1 id="_2263">
    <title>2263</title>

    <indexterm>
      <primary>2263</primary>
    </indexterm>

    <para>Mapping fields type mismatch</para>
  </sect1>

  <sect1 id="_2280">
    <title>2280</title>

    <indexterm>
      <primary>2280</primary>
    </indexterm>

    <para>token used inside a token definition</para>
  </sect1>

  <sect1 id="_2281">
    <title>2281</title>

    <indexterm>
      <primary>2281</primary>
    </indexterm>

    <para>Can't refer to a rule inside a pattern</para>
  </sect1>

  <sect1 id="_2282">
    <title>2282</title>

    <indexterm>
      <primary>2282</primary>
    </indexterm>

    <para>Bad syntax inside a PATTERN() definition</para>
  </sect1>

  <sect1 id="_2283">
    <title>2283</title>

    <indexterm>
      <primary>2283</primary>
    </indexterm>

    <para>expected pattern</para>
  </sect1>

  <sect1 id="_2284">
    <title>2284</title>

    <indexterm>
      <primary>2284</primary>
    </indexterm>

    <para>Invalid format for an assertion subpattern</para>
  </sect1>

  <sect1 id="_2285">
    <title>2285</title>

    <indexterm>
      <primary>2285</primary>
    </indexterm>

    <para>This expression can't be included in a pattern</para>
  </sect1>

  <sect1 id="_2286">
    <title>2286</title>

    <indexterm>
      <primary>2286</primary>
    </indexterm>

    <para>Can't reference a pattern function in a MATCHED() arg</para>
  </sect1>

  <sect1 id="_2287">
    <title>2287</title>

    <indexterm>
      <primary>2287</primary>
    </indexterm>

    <para>Self used outside a rule definition</para>
  </sect1>

  <sect1 id="_2288">
    <title>2288</title>

    <indexterm>
      <primary>2288</primary>
    </indexterm>

    <para>Can only use use() inside a rule definition</para>
  </sect1>

  <sect1 id="_2289">
    <title>2289</title>

    <indexterm>
      <primary>2289</primary>
    </indexterm>

    <para>:stored etc. used in a pattern attribute</para>
  </sect1>

  <sect1 id="_2290">
    <title>2290</title>

    <indexterm>
      <primary>2290</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2291">
    <title>2291</title>

    <indexterm>
      <primary>2291</primary>
    </indexterm>

    <para>Could not deduce feature from the guard condition</para>
  </sect1>

  <sect1 id="_2292">
    <title>2292</title>

    <indexterm>
      <primary>2292</primary>
    </indexterm>

    <para>Expected a list of characters</para>
  </sect1>

  <sect1 id="_2293">
    <title>2293</title>

    <indexterm>
      <primary>2293</primary>
    </indexterm>

    <para>Expected a repeat...</para>
  </sect1>

  <sect1 id="_2294">
    <title>2294</title>

    <indexterm>
      <primary>2294</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2295">
    <title>2295</title>

    <indexterm>
      <primary>2295</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2296">
    <title>2296</title>

    <indexterm>
      <primary>2296</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2297">
    <title>2297</title>

    <indexterm>
      <primary>2297</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2299">
    <title>2299</title>

    <indexterm>
      <primary>2299</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2300">
    <title>2300</title>

    <indexterm>
      <primary>2300</primary>
    </indexterm>

    <para>Multi dimension array indexing not supported.</para>
  </sect1>

  <sect1 id="_2301">
    <title>2301</title>

    <indexterm>
      <primary>2301</primary>
    </indexterm>

    <para>Could not find distributed fields</para>
  </sect1>

  <sect1 id="_2302">
    <title>2302</title>

    <indexterm>
      <primary>2302</primary>
    </indexterm>

    <para>Only LOCAL merge is currently supported</para>
  </sect1>

  <sect1 id="_2303">
    <title>2303</title>

    <indexterm>
      <primary>2303</primary>
    </indexterm>

    <para>Field not found</para>
  </sect1>

  <sect1 id="_2304">
    <title>2304</title>

    <indexterm>
      <primary>2304</primary>
    </indexterm>

    <para>Deprecated</para>
  </sect1>

  <sect1 id="_2305">
    <title>2305</title>

    <indexterm>
      <primary>2305</primary>
    </indexterm>

    <para>KEYED index is invalid</para>
  </sect1>

  <sect1 id="_2306">
    <title>2306</title>

    <indexterm>
      <primary>2306</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2307">
    <title>2307</title>

    <indexterm>
      <primary>2307</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2308">
    <title>2308</title>

    <indexterm>
      <primary>2308</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2309">
    <title>2309</title>

    <indexterm>
      <primary>2309</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2310">
    <title>2310</title>

    <indexterm>
      <primary>2310</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2311">
    <title>2311</title>

    <indexterm>
      <primary>2311</primary>
    </indexterm>

    <para>No longer supported language feature</para>
  </sect1>

  <sect1 id="_2312">
    <title>2312</title>

    <indexterm>
      <primary>2312</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2313">
    <title>2313</title>

    <indexterm>
      <primary>2313</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2314">
    <title>2314</title>

    <indexterm>
      <primary>2314</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2315">
    <title>2315</title>

    <indexterm>
      <primary>2315</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2316">
    <title>2316</title>

    <indexterm>
      <primary>2316</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2317">
    <title>2317</title>

    <indexterm>
      <primary>2317</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2318">
    <title>2318</title>

    <indexterm>
      <primary>2318</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2319">
    <title>2319</title>

    <indexterm>
      <primary>2319</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2320">
    <title>2320</title>

    <indexterm>
      <primary>2320</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2321">
    <title>2321</title>

    <indexterm>
      <primary>2321</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2322">
    <title>2322</title>

    <indexterm>
      <primary>2322</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2323">
    <title>2323</title>

    <indexterm>
      <primary>2323</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2324">
    <title>2324</title>

    <indexterm>
      <primary>2324</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2325">
    <title>2325</title>

    <indexterm>
      <primary>2325</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2326">
    <title>2326</title>

    <indexterm>
      <primary>2326</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2327">
    <title>2327</title>

    <indexterm>
      <primary>2327</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2328">
    <title>2328</title>

    <indexterm>
      <primary>2328</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2329">
    <title>2329</title>

    <indexterm>
      <primary>2329</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2331">
    <title>2331</title>

    <indexterm>
      <primary>2331</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2332">
    <title>2332</title>

    <indexterm>
      <primary>2332</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2333">
    <title>2333</title>

    <indexterm>
      <primary>2333</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2334">
    <title>2334</title>

    <indexterm>
      <primary>2334</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2335">
    <title>2335</title>

    <indexterm>
      <primary>2335</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2336">
    <title>2336</title>

    <indexterm>
      <primary>2336</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2337">
    <title>2337</title>

    <indexterm>
      <primary>2337</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2338">
    <title>2338</title>

    <indexterm>
      <primary>2338</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2339">
    <title>2339</title>

    <indexterm>
      <primary>2339</primary>
    </indexterm>

    <para>Feature not yet enabled on this platform</para>
  </sect1>

  <sect1 id="_2340">
    <title>2340</title>

    <indexterm>
      <primary>2340</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2341">
    <title>2341</title>

    <indexterm>
      <primary>2341</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2342">
    <title>2342</title>

    <indexterm>
      <primary>2342</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2343">
    <title>2343</title>

    <indexterm>
      <primary>2343</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2344">
    <title>2344</title>

    <indexterm>
      <primary>2344</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2345">
    <title>2345</title>

    <indexterm>
      <primary>2345</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2346">
    <title>2346</title>

    <indexterm>
      <primary>2346</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2347">
    <title>2347</title>

    <indexterm>
      <primary>2347</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2348">
    <title>2348</title>

    <indexterm>
      <primary>2348</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2349">
    <title>2349</title>

    <indexterm>
      <primary>2349</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2350">
    <title>2350</title>

    <indexterm>
      <primary>2350</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2351">
    <title>2351</title>

    <indexterm>
      <primary>2351</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2352">
    <title>2352</title>

    <indexterm>
      <primary>2352</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2353">
    <title>2353</title>

    <indexterm>
      <primary>2353</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2354">
    <title>2354</title>

    <indexterm>
      <primary>2354</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2355">
    <title>2355</title>

    <indexterm>
      <primary>2355</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2356">
    <title>2356</title>

    <indexterm>
      <primary>2356</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2357">
    <title>2357</title>

    <indexterm>
      <primary>2357</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2358">
    <title>2358</title>

    <indexterm>
      <primary>2358</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2359">
    <title>2359</title>

    <indexterm>
      <primary>2359</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2360">
    <title>2360</title>

    <indexterm>
      <primary>2360</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2361">
    <title>2361</title>

    <indexterm>
      <primary>2361</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2362">
    <title>2362</title>

    <indexterm>
      <primary>2362</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2363">
    <title>2363</title>

    <indexterm>
      <primary>2363</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2364">
    <title>2364</title>

    <indexterm>
      <primary>2364</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2365">
    <title>2365</title>

    <indexterm>
      <primary>2365</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2366">
    <title>2366</title>

    <indexterm>
      <primary>2366</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2367">
    <title>2367</title>

    <indexterm>
      <primary>2367</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2368">
    <title>2368</title>

    <indexterm>
      <primary>2368</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2369">
    <title>2369</title>

    <indexterm>
      <primary>2369</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2370">
    <title>2370</title>

    <indexterm>
      <primary>2370</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2371">
    <title>2371</title>

    <indexterm>
      <primary>2371</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2372">
    <title>2372</title>

    <indexterm>
      <primary>2372</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2373">
    <title>2373</title>

    <indexterm>
      <primary>2373</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2374">
    <title>2374</title>

    <indexterm>
      <primary>2374</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2375">
    <title>2375</title>

    <indexterm>
      <primary>2375</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2376">
    <title>2376</title>

    <indexterm>
      <primary>2376</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2377">
    <title>2377</title>

    <indexterm>
      <primary>2377</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2378">
    <title>2378</title>

    <indexterm>
      <primary>2378</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2379">
    <title>2379</title>

    <indexterm>
      <primary>2379</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2380">
    <title>2380</title>

    <indexterm>
      <primary>2380</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2381">
    <title>2381</title>

    <indexterm>
      <primary>2381</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2382">
    <title>2382</title>

    <indexterm>
      <primary>2382</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2383">
    <title>2383</title>

    <indexterm>
      <primary>2383</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2384">
    <title>2384</title>

    <indexterm>
      <primary>2384</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2385">
    <title>2385</title>

    <indexterm>
      <primary>2385</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2386">
    <title>2386</title>

    <indexterm>
      <primary>2386</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_2387">
    <title>2387</title>

    <indexterm>
      <primary>2387</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_10000">
    <title>10000</title>

    <indexterm>
      <primary>10000</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_3000">
    <title>3000</title>

    <indexterm>
      <primary>3000</primary>
    </indexterm>

    <para><emphasis role="bold">Internal exception</emphasis></para>

    <para>Most often this error indicates an internal error of the compiler (a
    bug), but not always. Some- times, the message correctly reports a
    problem. In an ideal world, this error should never hap- pen.</para>

    <para>Solution: Try to work around the situation the message indicates.
    Contact Seisint when no work- around is apparent.</para>
  </sect1>

  <sect1 id="_3001">
    <title>3001</title>

    <indexterm>
      <primary>3001</primary>
    </indexterm>

    <para><emphasis role="bold">Too many errors</emphasis></para>

    <para>Normally this means either the code is too complicated and has many
    parsing errors, or the code’s logic confused the compiler, causing
    cascaded errors.</para>

    <para>Solution: Try to resolve the errors before this one first, and
    hopefully there will be fewer errors next time. Comment out some code and
    try to compile only a portion of the whole may be a good idea
    sometimes.</para>
  </sect1>

  <sect1 id="_3002">
    <title>3002</title>

    <indexterm>
      <primary>3002</primary>
    </indexterm>

    <para><emphasis role="bold">Expected ...</emphasis></para>

    <para>Normally this indicates a general syntax error. The compiler gives
    out the symbols it expects based on the grammar. This is the compiler’s
    last resort for reporting meaningful error messages.</para>

    <para>Solution: Try to understand the context and the ECL grammer. Don’t
    take the error message too serious. It may be simply the result of some
    error before this.</para>
  </sect1>

  <sect1 id="_3003">
    <title>3003</title>

    <indexterm>
      <primary>3003</primary>
    </indexterm>

    <para><emphasis role="bold">XXX is not valid here</emphasis></para>

    <para>Reference Errors C2020 through C2037; these are very similar.</para>
  </sect1>

  <sect1 id="_3004">
    <title>3004</title>

    <indexterm>
      <primary>3004</primary>
    </indexterm>

    <para><emphasis role="bold">Unexpected end of file
    encountered</emphasis></para>

    <para>The ECL source file reaches the end while the parser is still in the
    middle of something. This is normally the result of some other error. This
    also happens during the error recovery produre.</para>

    <para>Solution: Resolve other errors first, if any. Otherwise, look at the
    code pointed out carefully. Try to identify problems. Is some structure
    incomplete?</para>

    <para>Example:</para>

    <programlisting>      01: ReverseString4 := TYPE
      02: MyType := TYPE
      03: EXPORT INTEGER Load(INTEGER x) := x+1;
      04: EXPORT INTEGER Store(INTEGER x) := x-1;
      05: //END
      06: //END
</programlisting>

    <para>In the example, user defined types are not allowed to be nested (see
    error C2011), so the parser is trying to recover from the error in lines
    2-4, but couldn’t find the terminating END when it reached the end of the
    file.</para>
  </sect1>

  <sect1 id="_3005">
    <title>3005</title>

    <indexterm>
      <primary>3005</primary>
    </indexterm>

    <para>Whole record not valid here</para>
  </sect1>

  <sect1 id="_3006">
    <title>3006</title>

    <indexterm>
      <primary>3006</primary>
    </indexterm>

    <para>Except not found in the incoming list</para>
  </sect1>

  <sect1 id="_3007">
    <title>3007</title>

    <indexterm>
      <primary>3007</primary>
    </indexterm>

    <para>PIPE(name) and project not supported</para>
  </sect1>

  <sect1 id="_3100">
    <title>3100</title>

    <indexterm>
      <primary>3100</primary>
    </indexterm>

    <para>Field removed from dedup could not be found</para>
  </sect1>

  <sect1 id="_3101">
    <title>3101</title>

    <indexterm>
      <primary>3101</primary>
    </indexterm>

    <para>Module definition contain an illegal cycle/recursive definition
    %s</para>
  </sect1>

  <sect1 id="_3102">
    <title>3102</title>

    <indexterm>
      <primary>3102</primary>
    </indexterm>

    <para>Cannot calculate inversion of PROJECT on STEPPED index%s</para>
  </sect1>

  <sect1 id="_3103">
    <title>3103</title>

    <indexterm>
      <primary>3103</primary>
    </indexterm>

    <para>Dataset not expected in this context</para>
  </sect1>

  <sect1 id="_3104">
    <title>3104</title>

    <indexterm>
      <primary>3104</primary>
    </indexterm>

    <para>Equality on field[n..*] must match a similar equality</para>
  </sect1>

  <sect1 id="_3105">
    <title>3105</title>

    <indexterm>
      <primary>3105</primary>
    </indexterm>

    <para>Join only supports a single x[n..*] comparison</para>
  </sect1>

  <sect1 id="_3106">
    <title>3106</title>

    <indexterm>
      <primary>3106</primary>
    </indexterm>

    <para>INTERNAL: Serializing extract too complex</para>
  </sect1>

  <sect1 id="_3107">
    <title>3107</title>

    <indexterm>
      <primary>3107</primary>
    </indexterm>

    <para>INTERNAL: Unexpected '%s' at %s(%d)</para>
  </sect1>

  <sect1 id="_3108">
    <title>3108</title>

    <indexterm>
      <primary>3108</primary>
    </indexterm>

    <para>INTERNAL: Unexpected type '%s' at %s(%d)</para>
  </sect1>

  <sect1 id="_3109">
    <title>3109</title>

    <indexterm>
      <primary>3109</primary>
    </indexterm>

    <para>Field '%s' in the map was not found in the dataset parameter</para>
  </sect1>

  <sect1 id="_3110">
    <title>3110</title>

    <indexterm>
      <primary>3110</primary>
    </indexterm>

    <para>Field '%s' has already been mapped</para>
  </sect1>

  <sect1 id="_3111">
    <title>3111</title>

    <indexterm>
      <primary>3111</primary>
    </indexterm>

    <para>A field named '%s' was not found in the dataset parameter</para>
  </sect1>

  <sect1 id="_3112">
    <title>3112</title>

    <indexterm>
      <primary>3112</primary>
    </indexterm>

    <para>File %s not found</para>
  </sect1>

  <sect1 id="_3113">
    <title>3113</title>

    <indexterm>
      <primary>3113</primary>
    </indexterm>

    <para>Browsing child grouped tables not handled at the moment</para>
  </sect1>

  <sect1 id="_3114">
    <title>3114</title>

    <indexterm>
      <primary>3114</primary>
    </indexterm>

    <para>INTERNAL: Selected field '%s' does not appear in the dataset</para>
  </sect1>

  <sect1 id="_3115">
    <title>3115</title>

    <indexterm>
      <primary>3115</primary>
    </indexterm>

    <para>Illegal pattern</para>
  </sect1>

  <sect1 id="_3116">
    <title>3116</title>

    <indexterm>
      <primary>3116</primary>
    </indexterm>

    <para>Unknown character class [:%s:]</para>
  </sect1>

  <sect1 id="_3117">
    <title>3117</title>

    <indexterm>
      <primary>3117</primary>
    </indexterm>

    <para>Collation symbols not yet supported</para>
  </sect1>

  <sect1 id="_3118">
    <title>3118</title>

    <indexterm>
      <primary>3118</primary>
    </indexterm>

    <para>Equivalence class symbols not yet supported</para>
  </sect1>

  <sect1 id="_3119">
    <title>3119</title>

    <indexterm>
      <primary>3119</primary>
    </indexterm>

    <para>Could not connect to any ECL server</para>
  </sect1>

  <sect1 id="_3120">
    <title>3120</title>

    <indexterm>
      <primary>3120</primary>
    </indexterm>

    <para>Mismatch in major version number (%s v %s)</para>
  </sect1>

  <sect1 id="_3121">
    <title>3121</title>

    <indexterm>
      <primary>3121</primary>
    </indexterm>

    <para>Virtual field %s not supported in constant table - please provide a
    value</para>
  </sect1>

  <sect1 id="_3122">
    <title>3122</title>

    <indexterm>
      <primary>3122</primary>
    </indexterm>

    <para>Inline DATASET field '%s' cannot be initialized with a list of
    values</para>
  </sect1>

  <sect1 id="_3123">
    <title>3123</title>

    <indexterm>
      <primary>3123</primary>
    </indexterm>

    <para>No value or default provided for field %s in inline table</para>
  </sect1>

  <sect1 id="_3124">
    <title>3124</title>

    <indexterm>
      <primary>3124</primary>
    </indexterm>

    <para>Too many initializers (value %s) for inline dataset
    definition</para>
  </sect1>

  <sect1 id="_3125">
    <title>3125</title>

    <indexterm>
      <primary>3125</primary>
    </indexterm>

    <para>Initializer for field %s in inline dataset has the wrong type</para>
  </sect1>

  <sect1 id="_3126">
    <title>3126</title>

    <indexterm>
      <primary>3126</primary>
    </indexterm>

    <para>Could not constant fold the condition on a IFBLOCK for a inline
    table</para>
  </sect1>

  <sect1 id="Unknown_3005">
    <title>Unknown_3005</title>

    <indexterm>
      <primary>Unknown_3005</primary>
    </indexterm>

    <para>The parser can not recover from previous error(s)</para>
  </sect1>

  <sect1 id="_4000">
    <title>4000</title>

    <indexterm>
      <primary>4000</primary>
    </indexterm>

    <para>INTERNAL: Cannot generate code for an empty set in this
    context</para>
  </sect1>

  <sect1 id="_4001">
    <title>4001</title>

    <indexterm>
      <primary>4001</primary>
    </indexterm>

    <para>Multi dimensioned sets are not yet supported</para>
  </sect1>

  <sect1 id="_4002">
    <title>4002</title>

    <indexterm>
      <primary>4002</primary>
    </indexterm>

    <para>ALL cannot be passed to an external service</para>
  </sect1>

  <sect1 id="_4003">
    <title>4003</title>

    <indexterm>
      <primary>4003</primary>
    </indexterm>

    <para>Indexing ALL is undefined</para>
  </sect1>

  <sect1 id="_4004">
    <title>4004</title>

    <indexterm>
      <primary>4004</primary>
    </indexterm>

    <para>Cannot use ALL in this context</para>
  </sect1>

  <sect1 id="_4005">
    <title>4005</title>

    <indexterm>
      <primary>4005</primary>
    </indexterm>

    <para>Too many parameters passed to function '%s'</para>
  </sect1>

  <sect1 id="_4006">
    <title>4006</title>

    <indexterm>
      <primary>4006</primary>
    </indexterm>

    <para>Cannot define column %s with an unknown length (use alien
    datatype)</para>
  </sect1>

  <sect1 id="_4007">
    <title>4007</title>

    <indexterm>
      <primary>4007</primary>
    </indexterm>

    <para>BUILDINDEX can only be used to build fixed width indexes</para>
  </sect1>

  <sect1 id="_4008">
    <title>4008</title>

    <indexterm>
      <primary>4008</primary>
    </indexterm>

    <para>BUILDINDEX can only be used to build indexes on fixed width
    files</para>
  </sect1>

  <sect1 id="_4009">
    <title>4009</title>

    <indexterm>
      <primary>4009</primary>
    </indexterm>

    <para>INDEX does not support fields of type %s</para>
  </sect1>

  <sect1 id="_4010">
    <title>4010</title>

    <indexterm>
      <primary>4010</primary>
    </indexterm>

    <para>INDEX does not match the dataset being joined</para>
  </sect1>

  <sect1 id="_4011">
    <title>4011</title>

    <indexterm>
      <primary>4011</primary>
    </indexterm>

    <para>Join condition does not contain sufficient information to use
    key</para>
  </sect1>

  <sect1 id="_4012">
    <title>4012</title>

    <indexterm>
      <primary>4012</primary>
    </indexterm>

    <para>Not yet implemented: Cannot use a record structure containing a
    virtual field (%s) with stored or persist</para>
  </sect1>

  <sect1 id="_4013">
    <title>4013</title>

    <indexterm>
      <primary>4013</primary>
    </indexterm>

    <para>%s has more than one definition</para>
  </sect1>

  <sect1 id="_4014">
    <title>4014</title>

    <indexterm>
      <primary>4014</primary>
    </indexterm>

    <para>LIMIT clause can only be applied to a dataset</para>
  </sect1>

  <sect1 id="_4015">
    <title>4015</title>

    <indexterm>
      <primary>4015</primary>
    </indexterm>

    <para>Cannot resource activity %s a cluster with %d nodes</para>
  </sect1>

  <sect1 id="_4016">
    <title>4016</title>

    <indexterm>
      <primary>4016</primary>
    </indexterm>

    <para>Unsupported option #WORKUNIT ('%s')</para>
  </sect1>

  <sect1 id="_4017">
    <title>4017</title>

    <indexterm>
      <primary>4017</primary>
    </indexterm>

    <para>INTERNAL: Unsupported virtual attribute '%s'</para>
  </sect1>

  <sect1 id="_4018">
    <title>4018</title>

    <indexterm>
      <primary>4018</primary>
    </indexterm>

    <para>Illegal pattern '%s..%s'</para>
  </sect1>

  <sect1 id="_4020">
    <title>4020</title>

    <indexterm>
      <primary>4020</primary>
    </indexterm>

    <para>THOR must be used for sorting or joining datasets with variable
    width rows</para>
  </sect1>

  <sect1 id="_4021">
    <title>4021</title>

    <indexterm>
      <primary>4021</primary>
    </indexterm>

    <para>Substring index %d is outside the field range</para>
  </sect1>

  <sect1 id="_4022">
    <title>4022</title>

    <indexterm>
      <primary>4022</primary>
    </indexterm>

    <para>RANK/RANKED not supported on list %s</para>
  </sect1>

  <sect1 id="_4023">
    <title>4023</title>

    <indexterm>
      <primary>4023</primary>
    </indexterm>

    <para>Cannot cast a string of unknown length to another character
    set</para>
  </sect1>

  <sect1 id="_4024">
    <title>4024</title>

    <indexterm>
      <primary>4024</primary>
    </indexterm>

    <para>Not enough parameters passed to function '%s'</para>
  </sect1>

  <sect1 id="_4025">
    <title>4025</title>

    <indexterm>
      <primary>4025</primary>
    </indexterm>

    <para>Index is not supported for type %s yet</para>
  </sect1>

  <sect1 id="_4026">
    <title>4026</title>

    <indexterm>
      <primary>4026</primary>
    </indexterm>

    <para>RANK has no meaning on an empty list</para>
  </sect1>

  <sect1 id="_4027">
    <title>4027</title>

    <indexterm>
      <primary>4027</primary>
    </indexterm>

    <para>%s can only be used in a record supplied to a PARSE() command</para>
  </sect1>

  <sect1 id="_4028">
    <title>4028</title>

    <indexterm>
      <primary>4028</primary>
    </indexterm>

    <para>The parameter to MATCHED(%s) is not found in the pattern</para>
  </sect1>

  <sect1 id="_4029">
    <title>4029</title>

    <indexterm>
      <primary>4029</primary>
    </indexterm>

    <para>Roxie requires constant filenames - expression %s cannot be computed
    at deployment time</para>
  </sect1>

  <sect1 id="_4030">
    <title>4030</title>

    <indexterm>
      <primary>4030</primary>
    </indexterm>

    <para>MATCHTEXT found where MATCHUNICODE was expected</para>
  </sect1>

  <sect1 id="_4031">
    <title>4031</title>

    <indexterm>
      <primary>4031</primary>
    </indexterm>

    <para>MATCHUNICODE found where MATCHTEXT was expected</para>
  </sect1>

  <sect1 id="_4032">
    <title>4032</title>

    <indexterm>
      <primary>4032</primary>
    </indexterm>

    <para>Only MATCHTEXT and MATCHUNICODE are valid inside a VALIDATE</para>
  </sect1>

  <sect1 id="_4033">
    <title>4033</title>

    <indexterm>
      <primary>4033</primary>
    </indexterm>

    <para>Records containing child datasets must be output to a file</para>
  </sect1>

  <sect1 id="_4034">
    <title>4034</title>

    <indexterm>
      <primary>4034</primary>
    </indexterm>

    <para>Definition of USE(%s) was not found</para>
  </sect1>

  <sect1 id="_4035">
    <title>4035</title>

    <indexterm>
      <primary>4035</primary>
    </indexterm>

    <para>Definition of USE(%s.%s) was not found</para>
  </sect1>

  <sect1 id="_4036">
    <title>4036</title>

    <indexterm>
      <primary>4036</primary>
    </indexterm>

    <para>Duplicate definition of %s (use #stored to override default
    value)</para>
  </sect1>

  <sect1 id="_4037">
    <title>4037</title>

    <indexterm>
      <primary>4037</primary>
    </indexterm>

    <para>ROWDIFF: Types are not compatible for field %s</para>
  </sect1>

  <sect1 id="_4038">
    <title>4038</title>

    <indexterm>
      <primary>4038</primary>
    </indexterm>

    <para>FETCH not supported on dataset of kind %s</para>
  </sect1>

  <sect1 id="_4039">
    <title>4039</title>

    <indexterm>
      <primary>4039</primary>
    </indexterm>

    <para>COUNTER is not legal in this context</para>
  </sect1>

  <sect1 id="_4040">
    <title>4040</title>

    <indexterm>
      <primary>4040</primary>
    </indexterm>

    <para>XMLTEXT is only legal in a PARSE transform</para>
  </sect1>

  <sect1 id="_4041">
    <title>4041</title>

    <indexterm>
      <primary>4041</primary>
    </indexterm>

    <para>XMLUNICODE is only legal inside a PARSE transform</para>
  </sect1>

  <sect1 id="_4042">
    <title>4042</title>

    <indexterm>
      <primary>4042</primary>
    </indexterm>

    <para>Condition on DISTRIBUTE must match the key exactly</para>
  </sect1>

  <sect1 id="_4043">
    <title>4043</title>

    <indexterm>
      <primary>4043</primary>
    </indexterm>

    <para>Row size %u exceeds the maximum specified (%u)</para>
  </sect1>

  <sect1 id="_4044">
    <title>4044</title>

    <indexterm>
      <primary>4044</primary>
    </indexterm>

    <para>Select expression should have been hoisted</para>
  </sect1>

  <sect1 id="_4045">
    <title>4045</title>

    <indexterm>
      <primary>4045</primary>
    </indexterm>

    <para>%s() cannot have a parameter inside a VALIDATE</para>
  </sect1>

  <sect1 id="_4046">
    <title>4046</title>

    <indexterm>
      <primary>4046</primary>
    </indexterm>

    <para>%s is not supported in roxie queries</para>
  </sect1>

  <sect1 id="_4047">
    <title>4047</title>

    <indexterm>
      <primary>4047</primary>
    </indexterm>

    <para>Input to MERGE does not appear to be sorted</para>
  </sect1>

  <sect1 id="_4048">
    <title>4048</title>

    <indexterm>
      <primary>4048</primary>
    </indexterm>

    <para>Expression is too complicated to preload</para>
  </sect1>

  <sect1 id="_4049">
    <title>4049</title>

    <indexterm>
      <primary>4049</primary>
    </indexterm>

    <para>KEYED(%s) couldn't be looked up in a key.</para>
  </sect1>

  <sect1 id="_4050">
    <title>4050</title>

    <indexterm>
      <primary>4050</primary>
    </indexterm>

    <para>KEYED(%s) follows unfiltered component %s in the key%s</para>
  </sect1>

  <sect1 id="_4051">
    <title>4051</title>

    <indexterm>
      <primary>4051</primary>
    </indexterm>

    <para>WILD(%s) follows unfiltered component %s in the key%s</para>
  </sect1>

  <sect1 id="_4052">
    <title>4052</title>

    <indexterm>
      <primary>4052</primary>
    </indexterm>

    <para>%s could not be implemented by the key</para>
  </sect1>

  <sect1 id="_4053">
    <title>4053</title>

    <indexterm>
      <primary>4053</primary>
    </indexterm>

    <para>Cannot process zero length rows</para>
  </sect1>

  <sect1 id="_4054">
    <title>4054</title>

    <indexterm>
      <primary>4054</primary>
    </indexterm>

    <para>Set casts aren't supported yet</para>
  </sect1>

  <sect1 id="_4055">
    <title>4055</title>

    <indexterm>
      <primary>4055</primary>
    </indexterm>

    <para>Cannot call function %s in a non-global context</para>
  </sect1>

  <sect1 id="_4056">
    <title>4056</title>

    <indexterm>
      <primary>4056</primary>
    </indexterm>

    <para>Sets of items of unknown length are not yet supported!</para>
  </sect1>

  <sect1 id="_4057">
    <title>4057</title>

    <indexterm>
      <primary>4057</primary>
    </indexterm>

    <para>#STORED (%s) type mismatch (was '%s' replacement '%s')</para>
  </sect1>

  <sect1 id="_4058">
    <title>4058</title>

    <indexterm>
      <primary>4058</primary>
    </indexterm>

    <para>Cannot count number of elements in ALL</para>
  </sect1>

  <sect1 id="_4059">
    <title>4059</title>

    <indexterm>
      <primary>4059</primary>
    </indexterm>

    <para>Can only key fixed fields at fixed offsets</para>
  </sect1>

  <sect1 id="_4060">
    <title>4060</title>

    <indexterm>
      <primary>4060</primary>
    </indexterm>

    <para>Duplicate definition of %s with different type (use #stored to
    override default value)</para>
  </sect1>

  <sect1 id="_4061">
    <title>4061</title>

    <indexterm>
      <primary>4061</primary>
    </indexterm>

    <para>Features are not supported by regex - did you mean repeat() instead
    of {}?</para>
  </sect1>

  <sect1 id="_4062">
    <title>4062</title>

    <indexterm>
      <primary>4062</primary>
    </indexterm>

    <para>Option %s not yet supported on child datasets</para>
  </sect1>

  <sect1 id="_4063">
    <title>4063</title>

    <indexterm>
      <primary>4063</primary>
    </indexterm>

    <para>Grouped tables not yet supported in this context</para>
  </sect1>

  <sect1 id="_4064">
    <title>4064</title>

    <indexterm>
      <primary>4064</primary>
    </indexterm>

    <para>Nested child queries are not supported yet</para>
  </sect1>

  <sect1 id="_4066">
    <title>4066</title>

    <indexterm>
      <primary>4066</primary>
    </indexterm>

    <para>#STORED (%s) records must match</para>
  </sect1>

  <sect1 id="_4067">
    <title>4067</title>

    <indexterm>
      <primary>4067</primary>
    </indexterm>

    <para>ATMOST JOIN cannot be evaluated with this join condition%s</para>
  </sect1>

  <sect1 id="_4068">
    <title>4068</title>

    <indexterm>
      <primary>4068</primary>
    </indexterm>

    <para>ATMOST JOIN cannot be evaluated with this join condition%s</para>
  </sect1>

  <sect1 id="_4069">
    <title>4069</title>

    <indexterm>
      <primary>4069</primary>
    </indexterm>

    <para>RIGHT for a full keyed join must be a disk based DATASET</para>
  </sect1>

  <sect1 id="_4070">
    <title>4070</title>

    <indexterm>
      <primary>4070</primary>
    </indexterm>

    <para>ATMOST(%s) failed to match part of the join condition</para>
  </sect1>

  <sect1 id="_4071">
    <title>4071</title>

    <indexterm>
      <primary>4071</primary>
    </indexterm>

    <para>"LIMIT(%s, KEYED) could not be merged into an index read"</para>
  </sect1>

  <sect1 id="_4072">
    <title>4072</title>

    <indexterm>
      <primary>4072</primary>
    </indexterm>

    <para>EXTEND is required on all outputs to NAMED(%s)</para>
  </sect1>

  <sect1 id="_4073">
    <title>4073</title>

    <indexterm>
      <primary>4073</primary>
    </indexterm>

    <para>Duplicate output to NAMED(%s). EXTEND/OVERWRITE required</para>
  </sect1>

  <sect1 id="_4074">
    <title>4074</title>

    <indexterm>
      <primary>4074</primary>
    </indexterm>

    <para>OUTPUTs to NAMED(%s) have incompatible types</para>
  </sect1>

  <sect1 id="_4075">
    <title>4075</title>

    <indexterm>
      <primary>4075</primary>
    </indexterm>

    <para>OVERWRITE is required on all outputs to NAMED(%s)</para>
  </sect1>

  <sect1 id="_4076">
    <title>4076</title>

    <indexterm>
      <primary>4076</primary>
    </indexterm>

    <para>OVERWRITE/EXTEND should be consistent on all outputs to
    NAMED(%s)</para>
  </sect1>

  <sect1 id="_4078">
    <title>4078</title>

    <indexterm>
      <primary>4078</primary>
    </indexterm>

    <para>Insufficient access rights to use embedded C++</para>
  </sect1>

  <sect1 id="_4079">
    <title>4079</title>

    <indexterm>
      <primary>4079</primary>
    </indexterm>

    <para>Tag contents syntax &lt;&gt; is not supported by SOAPCALL</para>
  </sect1>

  <sect1 id="_4081">
    <title>4081</title>

    <indexterm>
      <primary>4081</primary>
    </indexterm>

    <para>RIGHT side of a full keyed join must be a disk file</para>
  </sect1>

  <sect1 id="_4082">
    <title>4082</title>

    <indexterm>
      <primary>4082</primary>
    </indexterm>

    <para>Expression is not constant: %s</para>
  </sect1>

  <sect1 id="_4083">
    <title>4083</title>

    <indexterm>
      <primary>4083</primary>
    </indexterm>

    <para>"Unimplemented: Cannot access row blob inside a child query, contact
    tech support"</para>
  </sect1>

  <sect1 id="_4084">
    <title>4084</title>

    <indexterm>
      <primary>4084</primary>
    </indexterm>

    <para>Field '%s' with dataset type not supported in csv output</para>
  </sect1>

  <sect1 id="_4085">
    <title>4085</title>

    <indexterm>
      <primary>4085</primary>
    </indexterm>

    <para>Field '%s' with set type not supported in csv output</para>
  </sect1>

  <sect1 id="_4086">
    <title>4086</title>

    <indexterm>
      <primary>4086</primary>
    </indexterm>

    <para>Cannot determine the maximum size of the expression</para>
  </sect1>

  <sect1 id="_4087">
    <title>4087</title>

    <indexterm>
      <primary>4087</primary>
    </indexterm>

    <para>Cannot determine size because variable size dataset is not in scope.
    Try using sizeof(x,max)</para>
  </sect1>

  <sect1 id="_4088">
    <title>4088</title>

    <indexterm>
      <primary>4088</primary>
    </indexterm>

    <para>Duplicate definition of %s</para>
  </sect1>

  <sect1 id="_4089">
    <title>4089</title>

    <indexterm>
      <primary>4089</primary>
    </indexterm>

    <para>Duplicate definition of %s with different type</para>
  </sect1>

  <sect1 id="_4090">
    <title>4090</title>

    <indexterm>
      <primary>4090</primary>
    </indexterm>

    <para>WILD() doesn't reference fields in key %s</para>
  </sect1>

  <sect1 id="_4091">
    <title>4091</title>

    <indexterm>
      <primary>4091</primary>
    </indexterm>

    <para>Field %s cannot have both KEYED and KEYED,OPT conditions</para>
  </sect1>

  <sect1 id="_4092">
    <title>4092</title>

    <indexterm>
      <primary>4092</primary>
    </indexterm>

    <para>KEYED(%s,OPT) follows a WILD() field in key %s</para>
  </sect1>

  <sect1 id="_4093">
    <title>4093</title>

    <indexterm>
      <primary>4093</primary>
    </indexterm>

    <para>COUNT(,KEYED) cannot be used on a child dataset</para>
  </sect1>

  <sect1 id="_4094">
    <title>4094</title>

    <indexterm>
      <primary>4094</primary>
    </indexterm>

    <para>Filter for COUNT(,KEYED) did not contained KEYED()
    expressions</para>
  </sect1>

  <sect1 id="_4095">
    <title>4095</title>

    <indexterm>
      <primary>4095</primary>
    </indexterm>

    <para>KEYED COUNT used on a non-keyable dataset</para>
  </sect1>

  <sect1 id="_4096">
    <title>4096</title>

    <indexterm>
      <primary>4096</primary>
    </indexterm>

    <para>Attempting to lookup field %s in a dataset which has no active
    element</para>
  </sect1>

  <sect1 id="_4097">
    <title>4097</title>

    <indexterm>
      <primary>4097</primary>
    </indexterm>

    <para>Key condition (%s) is too complex, it cannot be done with the
    key.</para>
  </sect1>

  <sect1 id="_4098">
    <title>4098</title>

    <indexterm>
      <primary>4098</primary>
    </indexterm>

    <para>Key condition (%s) requires casts on comparison of field '%s'</para>
  </sect1>

  <sect1 id="_4099">
    <title>4099</title>

    <indexterm>
      <primary>4099</primary>
    </indexterm>

    <para>Key condition (%s) does not have any comparisons against key
    fields</para>
  </sect1>

  <sect1 id="_4100">
    <title>4100</title>

    <indexterm>
      <primary>4100</primary>
    </indexterm>

    <para>No explicit maxlength provided for record %s</para>
  </sect1>

  <sect1 id="_">
    <title></title>

    <indexterm>
      <primary></primary>
    </indexterm>

    <para>unary - cannot be performed on a string</para>
  </sect1>

  <sect1 id="_4102">
    <title>4102</title>

    <indexterm>
      <primary>4102</primary>
    </indexterm>

    <para>%s is not supported inside NOTHOR()</para>
  </sect1>

  <sect1 id="_4103">
    <title>4103</title>

    <indexterm>
      <primary>4103</primary>
    </indexterm>

    <para>Regular expression parsing doesn't support productions - need to use
    tomita</para>
  </sect1>

  <sect1 id="_4104">
    <title>4104</title>

    <indexterm>
      <primary>4104</primary>
    </indexterm>

    <para>Unimplemented: Cannot yet access $&lt;n&gt; inside a child
    query</para>
  </sect1>

  <sect1 id="_4105">
    <title>4105</title>

    <indexterm>
      <primary>4105</primary>
    </indexterm>

    <para>Ambiguous default production for rule with multiple inputs</para>
  </sect1>

  <sect1 id="_4106">
    <title>4106</title>

    <indexterm>
      <primary>4106</primary>
    </indexterm>

    <para>Selector %s is used ambiguously at multiple levels</para>
  </sect1>

  <sect1 id="_4107">
    <title>4107</title>

    <indexterm>
      <primary>4107</primary>
    </indexterm>

    <para>JOIN%s marked as KEYED does not have a key as the second
    parameter</para>
  </sect1>

  <sect1 id="_4108">
    <title>4108</title>

    <indexterm>
      <primary>4108</primary>
    </indexterm>

    <para>ALLNODES(dataset) only legal in roxie and in thor child
    queries</para>
  </sect1>

  <sect1 id="_4109">
    <title>4109</title>

    <indexterm>
      <primary>4109</primary>
    </indexterm>

    <para>ALLNODES() is not currently supported on grouped datasets</para>
  </sect1>

  <sect1 id="_4110">
    <title>4110</title>

    <indexterm>
      <primary>4110</primary>
    </indexterm>

    <para>Library %s cannot contain any workflow actions%s</para>
  </sect1>

  <sect1 id="_4111">
    <title>4111</title>

    <indexterm>
      <primary>4111</primary>
    </indexterm>

    <para>LOOP body too complicated to evaluate in parallel</para>
  </sect1>

  <sect1 id="_4112">
    <title>4112</title>

    <indexterm>
      <primary>4112</primary>
    </indexterm>

    <para>Operator %s not supported inside DFAs</para>
  </sect1>

  <sect1 id="_4113">
    <title>4113</title>

    <indexterm>
      <primary>4113</primary>
    </indexterm>

    <para>MATCHUTF8 found where MATCHUNICODE/MATCHTEXT was expected</para>
  </sect1>

  <sect1 id="_4114">
    <title>4114</title>

    <indexterm>
      <primary>4114</primary>
    </indexterm>

    <para>THISNODE() can only be used inside ALLNODES()</para>
  </sect1>

  <sect1 id="_4115">
    <title>4115</title>

    <indexterm>
      <primary>4115</primary>
    </indexterm>

    <para>STEPPED(%s) cannot be evaluated in this context</para>
  </sect1>

  <sect1 id="_4116">
    <title>4116</title>

    <indexterm>
      <primary>4116</primary>
    </indexterm>

    <para>Parameter to RANGE() is too complex - not currently supported</para>
  </sect1>

  <sect1 id="_4117">
    <title>4117</title>

    <indexterm>
      <primary>4117</primary>
    </indexterm>

    <para>Project of stepping fields is too complex</para>
  </sect1>

  <sect1 id="_4118">
    <title>4118</title>

    <indexterm>
      <primary>4118</primary>
    </indexterm>

    <para>Stepped field %s must have a fixed size</para>
  </sect1>

  <sect1 id="_4119">
    <title>4119</title>

    <indexterm>
      <primary>4119</primary>
    </indexterm>

    <para>Stepped field %s must be at a fixed offset</para>
  </sect1>

  <sect1 id="_4120">
    <title>4120</title>

    <indexterm>
      <primary>4120</primary>
    </indexterm>

    <para>Expression is too complex to STEP (%s)</para>
  </sect1>

  <sect1 id="_4121">
    <title>4121</title>

    <indexterm>
      <primary>4121</primary>
    </indexterm>

    <para>Cannot smart step on payload fields</para>
  </sect1>

  <sect1 id="_4122">
    <title>4122</title>

    <indexterm>
      <primary>4122</primary>
    </indexterm>

    <para>STEPPED range condition could only be matched in one
    direction</para>
  </sect1>

  <sect1 id="_4123">
    <title>4123</title>

    <indexterm>
      <primary>4123</primary>
    </indexterm>

    <para>Multiple STEPPED comparisons %s &gt;=</para>
  </sect1>

  <sect1 id="_4124">
    <title>4124</title>

    <indexterm>
      <primary>4124</primary>
    </indexterm>

    <para>STEPPED condition is not compatible with the sort/merge condition
    (%s expected)</para>
  </sect1>

  <sect1 id="_4125">
    <title>4125</title>

    <indexterm>
      <primary>4125</primary>
    </indexterm>

    <para>JOIN condition is not compatible with the sort/merge
    condition</para>
  </sect1>

  <sect1 id="_4126">
    <title>4126</title>

    <indexterm>
      <primary>4126</primary>
    </indexterm>

    <para>STEPPED field %s is not keyed</para>
  </sect1>

  <sect1 id="_4127">
    <title>4127</title>

    <indexterm>
      <primary>4127</primary>
    </indexterm>

    <para>STEPPED field %s does not follow the previous stepped field</para>
  </sect1>

  <sect1 id="_4128">
    <title>4128</title>

    <indexterm>
      <primary>4128</primary>
    </indexterm>

    <para>Merge order must match all the stepped join fields</para>
  </sect1>

  <sect1 id="_4129">
    <title>4129</title>

    <indexterm>
      <primary>4129</primary>
    </indexterm>

    <para>Cannot OR together conditions on multiple key fields (%s)</para>
  </sect1>

  <sect1 id="_4130">
    <title>4130</title>

    <indexterm>
      <primary>4130</primary>
    </indexterm>

    <para>ROW compression can only be used on fixed size indexes</para>
  </sect1>

  <sect1 id="_4131">
    <title>4131</title>

    <indexterm>
      <primary>4131</primary>
    </indexterm>

    <para>UPDATE cannot be used when the inputs names aren't globally
    constant</para>
  </sect1>

  <sect1 id="_4132">
    <title>4132</title>

    <indexterm>
      <primary>4132</primary>
    </indexterm>

    <para>THOR currently only supports LEFT OUTER denormalize</para>
  </sect1>

  <sect1 id="_4133">
    <title>4133</title>

    <indexterm>
      <primary>4133</primary>
    </indexterm>

    <para>THOR doesn't support DENORMALIZE(%s)</para>
  </sect1>

  <sect1 id="_4134">
    <title>4134</title>

    <indexterm>
      <primary>4134</primary>
    </indexterm>

    <para>SKIP cannot be used here. It is only valid directly with a
    transform</para>
  </sect1>

  <sect1 id="_4135">
    <title>4135</title>

    <indexterm>
      <primary>4135</primary>
    </indexterm>

    <para>Cannot read tables/datasets from a csv file</para>
  </sect1>

  <sect1 id="_4136">
    <title>4136</title>

    <indexterm>
      <primary>4136</primary>
    </indexterm>

    <para>Argument %s to #workunit must be a constant</para>
  </sect1>

  <sect1 id="_4137">
    <title>4137</title>

    <indexterm>
      <primary>4137</primary>
    </indexterm>

    <para>Argument %s to #debug must be a constant</para>
  </sect1>

  <sect1 id="Unknown_01">
    <title>Unknown_01</title>

    <indexterm>
      <primary>Unknown_01</primary>
    </indexterm>

    <para>Queries libraries must be implemented with a parameterised
    module</para>
  </sect1>

  <sect1 id="_4138">
    <title>4138</title>

    <indexterm>
      <primary>4138</primary>
    </indexterm>

    <para>Member %s not defined in module passed as library parameter</para>
  </sect1>

  <sect1 id="_4139">
    <title>4139</title>

    <indexterm>
      <primary>4139</primary>
    </indexterm>

    <para>Member %s was undefined in a module</para>
  </sect1>

  <sect1 id="_4140">
    <title>4140</title>

    <indexterm>
      <primary>4140</primary>
    </indexterm>

    <para>Thor does not support HAVING on a non-grouped dataset</para>
  </sect1>

  <sect1 id="_4141">
    <title>4141</title>

    <indexterm>
      <primary>4141</primary>
    </indexterm>

    <para>%s not currently supported as a child action</para>
  </sect1>

  <sect1 id="_4142">
    <title>4142</title>

    <indexterm>
      <primary>4142</primary>
    </indexterm>

    <para>Definitions in libraries cannot have side effects (%s)</para>
  </sect1>

  <sect1 id="_4143">
    <title>4143</title>

    <indexterm>
      <primary>4143</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4144">
    <title>4144</title>

    <indexterm>
      <primary>4144</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4145">
    <title>4145</title>

    <indexterm>
      <primary>4145</primary>
    </indexterm>

    <para>Index read only supports single STEPPED expression</para>
  </sect1>

  <sect1 id="_4146">
    <title>4146</title>

    <indexterm>
      <primary>4146</primary>
    </indexterm>

    <para>#%s (%s) creates an illegal recursive reference (%s also being
    processed)</para>
  </sect1>

  <sect1 id="_4147">
    <title>4147</title>

    <indexterm>
      <primary>4147</primary>
    </indexterm>

    <para>Insufficient access rights to use PIPE</para>
  </sect1>

  <sect1 id="_4148">
    <title>4148</title>

    <indexterm>
      <primary>4148</primary>
    </indexterm>

    <para>Parameter to __nameof__ must be a dataset or an index</para>
  </sect1>

  <sect1 id="_4149">
    <title>4149</title>

    <indexterm>
      <primary>4149</primary>
    </indexterm>

    <para>Expected a UPDATE attribute name</para>
  </sect1>

  <sect1 id="_4150">
    <title>4150</title>

    <indexterm>
      <primary>4150</primary>
    </indexterm>

    <para>%s @ %d:%d</para>
  </sect1>

  <sect1 id="_4152">
    <title>4152</title>

    <indexterm>
      <primary>4152</primary>
    </indexterm>

    <para>Index in RANK/RANKED is out of range</para>
  </sect1>

  <sect1 id="_4153">
    <title>4153</title>

    <indexterm>
      <primary>4153</primary>
    </indexterm>

    <para>INTERNAL: Dataset is not active: '%s'</para>
  </sect1>

  <sect1 id="_4154">
    <title>4154</title>

    <indexterm>
      <primary>4154</primary>
    </indexterm>

    <para>Could not open thor template '%s' at '%s'</para>
  </sect1>

  <sect1 id="_4155">
    <title>4155</title>

    <indexterm>
      <primary>4155</primary>
    </indexterm>

    <para>Could not create output '%s'</para>
  </sect1>

  <sect1 id="_4156">
    <title>4156</title>

    <indexterm>
      <primary>4156</primary>
    </indexterm>

    <para>Dataset '%.80s' does not contain expression '%.50s'</para>
  </sect1>

  <sect1 id="_4157">
    <title>4157</title>

    <indexterm>
      <primary>4157</primary>
    </indexterm>

    <para>Cannot return a result of this type from a workunit</para>
  </sect1>

  <sect1 id="_4158">
    <title>4158</title>

    <indexterm>
      <primary>4158</primary>
    </indexterm>

    <para>Could not find dataset %s</para>
  </sect1>

  <sect1 id="_4159">
    <title>4159</title>

    <indexterm>
      <primary>4159</primary>
    </indexterm>

    <para>Could not find dataset %s (no tables in scope)</para>
  </sect1>

  <sect1 id="_4160">
    <title>4160</title>

    <indexterm>
      <primary>4160</primary>
    </indexterm>

    <para>INTERNAL: Thor nodes should not be nested</para>
  </sect1>

  <sect1 id="_4161">
    <title>4161</title>

    <indexterm>
      <primary>4161</primary>
    </indexterm>

    <para>INTERNAL: Missing assignment from transform to %s[%p]</para>
  </sect1>

  <sect1 id="_4162">
    <title>4162</title>

    <indexterm>
      <primary>4162</primary>
    </indexterm>

    <para>"JOIN%s contains no equality conditions - use ,ALL to allow"</para>
  </sect1>

  <sect1 id="_4163">
    <title>4163</title>

    <indexterm>
      <primary>4163</primary>
    </indexterm>

    <para>A global DEDUP(ALL) or local hash dedup cannot include comparisons
    in the dedup criteria</para>
  </sect1>

  <sect1 id="_4164">
    <title>4164</title>

    <indexterm>
      <primary>4164</primary>
    </indexterm>

    <para>"Global dedup,ALL must have a field to partition"</para>
  </sect1>

  <sect1 id="_4165">
    <title>4165</title>

    <indexterm>
      <primary>4165</primary>
    </indexterm>

    <para>Hash dedup doesn't support %s</para>
  </sect1>

  <sect1 id="_4166">
    <title>4166</title>

    <indexterm>
      <primary>4166</primary>
    </indexterm>

    <para>SORTED() used by JOINED must be applied to a DATASET</para>
  </sect1>

  <sect1 id="_4167">
    <title>4167</title>

    <indexterm>
      <primary>4167</primary>
    </indexterm>

    <para>SORTED() used by JOINED must be applied to a THOR dataset</para>
  </sect1>

  <sect1 id="_4168">
    <title>4168</title>

    <indexterm>
      <primary>4168</primary>
    </indexterm>

    <para>SORT supplied to COSORT needs to be executed at the same time</para>
  </sect1>

  <sect1 id="_4169">
    <title>4169</title>

    <indexterm>
      <primary>4169</primary>
    </indexterm>

    <para>WAIT not yet supported</para>
  </sect1>

  <sect1 id="_4170">
    <title>4170</title>

    <indexterm>
      <primary>4170</primary>
    </indexterm>

    <para>Index has fields %s in scope</para>
  </sect1>

  <sect1 id="_4171">
    <title>4171</title>

    <indexterm>
      <primary>4171</primary>
    </indexterm>

    <para>Global dataset has fields %s in scope</para>
  </sect1>

  <sect1 id="_4172">
    <title>4172</title>

    <indexterm>
      <primary>4172</primary>
    </indexterm>

    <para>Create resource library %s failed</para>
  </sect1>

  <sect1 id="_4173">
    <title>4173</title>

    <indexterm>
      <primary>4173</primary>
    </indexterm>

    <para>Records not assignment compatible</para>
  </sect1>

  <sect1 id="_4174">
    <title>4174</title>

    <indexterm>
      <primary>4174</primary>
    </indexterm>

    <para>Missing end of placeholder</para>
  </sect1>

  <sect1 id="_4175">
    <title>4175</title>

    <indexterm>
      <primary>4175</primary>
    </indexterm>

    <para>%s can only be globally or inside ONFAIL or other failure
    processing</para>
  </sect1>

  <sect1 id="_4176">
    <title>4176</title>

    <indexterm>
      <primary>4176</primary>
    </indexterm>

    <para>Side-effect%s is not currently supported as a context-dependent
    dependency</para>
  </sect1>

  <sect1 id="_4177">
    <title>4177</title>

    <indexterm>
      <primary>4177</primary>
    </indexterm>

    <para>Cannot deduce MERGE transform for global AGGREGATE</para>
  </sect1>

  <sect1 id="_4178">
    <title>4178</title>

    <indexterm>
      <primary>4178</primary>
    </indexterm>

    <para>AGGREGATE does not include grouping field '%s' in the result
    record</para>
  </sect1>

  <sect1 id="_4179">
    <title>4179</title>

    <indexterm>
      <primary>4179</primary>
    </indexterm>

    <para>The calculated maximum row size has overflowed 32bits</para>
  </sect1>

  <sect1 id="_4180">
    <title>4180</title>

    <indexterm>
      <primary>4180</primary>
    </indexterm>

    <para>%s: %s cannot be dependent on the dataset</para>
  </sect1>

  <sect1 id="_4181">
    <title>4181</title>

    <indexterm>
      <primary>4181</primary>
    </indexterm>

    <para>Cannot determine the minimum size of the expression</para>
  </sect1>

  <sect1 id="_4182">
    <title>4182</title>

    <indexterm>
      <primary>4182</primary>
    </indexterm>

    <para>%s used outside of a TABLE aggregation</para>
  </sect1>

  <sect1 id="_4183">
    <title>4183</title>

    <indexterm>
      <primary>4183</primary>
    </indexterm>

    <para>%s resource added after manifest was finalized</para>
  </sect1>

  <sect1 id="_4184">
    <title>4184</title>

    <indexterm>
      <primary>4184</primary>
    </indexterm>

    <para>SKIP inside a ROW(&lt;transform&gt;) not supported. It is only
    allowed in a DATASET transform.</para>
  </sect1>

  <sect1 id="_4500">
    <title>4500</title>

    <indexterm>
      <primary>4500</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4501">
    <title>4501</title>

    <indexterm>
      <primary>4501</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4502">
    <title>4502</title>

    <indexterm>
      <primary>4502</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4503">
    <title>4503</title>

    <indexterm>
      <primary>4503</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4504">
    <title>4504</title>

    <indexterm>
      <primary>4504</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4505">
    <title>4505</title>

    <indexterm>
      <primary>4505</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4506">
    <title>4506</title>

    <indexterm>
      <primary>4506</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4507">
    <title>4507</title>

    <indexterm>
      <primary>4507</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4508">
    <title>4508</title>

    <indexterm>
      <primary>4508</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4509">
    <title>4509</title>

    <indexterm>
      <primary>4509</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4510">
    <title>4510</title>

    <indexterm>
      <primary>4510</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4512">
    <title>4512</title>

    <indexterm>
      <primary>4512</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4513">
    <title>4513</title>

    <indexterm>
      <primary>4513</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4515">
    <title>4515</title>

    <indexterm>
      <primary>4515</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4516">
    <title>4516</title>

    <indexterm>
      <primary>4516</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4517">
    <title>4517</title>

    <indexterm>
      <primary>4517</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4518">
    <title>4518</title>

    <indexterm>
      <primary>4518</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4519">
    <title>4519</title>

    <indexterm>
      <primary>4519</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4520">
    <title>4520</title>

    <indexterm>
      <primary>4520</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4521">
    <title>4521</title>

    <indexterm>
      <primary>4521</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4522">
    <title>4522</title>

    <indexterm>
      <primary>4522</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4523">
    <title>4523</title>

    <indexterm>
      <primary>4523</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4524">
    <title>4524</title>

    <indexterm>
      <primary>4524</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4525">
    <title>4525</title>

    <indexterm>
      <primary>4525</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4526">
    <title>4526</title>

    <indexterm>
      <primary>4526</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4527">
    <title>4527</title>

    <indexterm>
      <primary>4527</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4528">
    <title>4528</title>

    <indexterm>
      <primary>4528</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4529">
    <title>4529</title>

    <indexterm>
      <primary>4529</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4530">
    <title>4530</title>

    <indexterm>
      <primary>4530</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4531">
    <title>4531</title>

    <indexterm>
      <primary>4531</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4532">
    <title>4532</title>

    <indexterm>
      <primary>4532</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4533">
    <title>4533</title>

    <indexterm>
      <primary>4533</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4534">
    <title>4534</title>

    <indexterm>
      <primary>4534</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4535">
    <title>4535</title>

    <indexterm>
      <primary>4535</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4536">
    <title>4536</title>

    <indexterm>
      <primary>4536</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4537">
    <title>4537</title>

    <indexterm>
      <primary>4537</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4538">
    <title>4538</title>

    <indexterm>
      <primary>4538</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4539">
    <title>4539</title>

    <indexterm>
      <primary>4539</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4540">
    <title>4540</title>

    <indexterm>
      <primary>4540</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4601">
    <title>4601</title>

    <indexterm>
      <primary>4601</primary>
    </indexterm>

    <para>Rank/Ranked not supported on variable length strings</para>
  </sect1>

  <sect1 id="_4604">
    <title>4604</title>

    <indexterm>
      <primary>4604</primary>
    </indexterm>

    <para>DISTRIBUTION() only supported at the outer level</para>
  </sect1>

  <sect1 id="_4606">
    <title>4606</title>

    <indexterm>
      <primary>4606</primary>
    </indexterm>

    <para>Physical table join condition too complicated</para>
  </sect1>

  <sect1 id="_4609">
    <title>4609</title>

    <indexterm>
      <primary>4609</primary>
    </indexterm>

    <para>Arbitrary repeats not yet supported!</para>
  </sect1>

  <sect1 id="_4610">
    <title>4610</title>

    <indexterm>
      <primary>4610</primary>
    </indexterm>

    <para>Tomita doesn't yet support unicode</para>
  </sect1>

  <sect1 id="_4611">
    <title>4611</title>

    <indexterm>
      <primary>4611</primary>
    </indexterm>

    <para>Patterns are too complicated for Tomita to handle at the moment
    [%s]</para>
  </sect1>

  <sect1 id="_4613">
    <title>4613</title>

    <indexterm>
      <primary>4613</primary>
    </indexterm>

    <para>Cannot currently assign to DATASET(SIZEOF(x)) fields</para>
  </sect1>

  <sect1 id="_4614">
    <title>4614</title>

    <indexterm>
      <primary>4614</primary>
    </indexterm>

    <para>Can only normalize simple child datasets - use other form if more
    complicated</para>
  </sect1>

  <sect1 id="_4615">
    <title>4615</title>

    <indexterm>
      <primary>4615</primary>
    </indexterm>

    <para>ROXIE doesn't yet support local activities</para>
  </sect1>

  <sect1 id="_4616">
    <title>4616</title>

    <indexterm>
      <primary>4616</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4617">
    <title>4617</title>

    <indexterm>
      <primary>4617</primary>
    </indexterm>

    <para>STEPPED is not currently supported by thor</para>
  </sect1>

  <sect1 id="Unknown_02">
    <title>Unknown_02</title>

    <indexterm>
      <primary>Unknown_02</primary>
    </indexterm>

    <para>string[n..*] syntax is only valid in a join condition</para>
  </sect1>

  <sect1 id="Unknown_03">
    <title>Unknown_03</title>

    <indexterm>
      <primary>Unknown_03</primary>
    </indexterm>

    <para>Keyed distribute doesn' support join condition of the form
    field[n..*]</para>
  </sect1>

  <sect1 id="_4618">
    <title>4618</title>

    <indexterm>
      <primary>4618</primary>
    </indexterm>

    <para>ONCE workflow items cannot be dependent on other workflow items
    (including ONCE)</para>
  </sect1>

  <sect1 id="_4619">
    <title>4619</title>

    <indexterm>
      <primary>4619</primary>
    </indexterm>

    <para>Thor currently only supports the local version of COMBINE</para>
  </sect1>

  <sect1 id="_4799">
    <title>4799</title>

    <indexterm>
      <primary>4799</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4800">
    <title>4800</title>

    <indexterm>
      <primary>4800</primary>
    </indexterm>

    <para>INTERNAL: Clear not supported on LOCAL datasets</para>
  </sect1>

  <sect1 id="_4801">
    <title>4801</title>

    <indexterm>
      <primary>4801</primary>
    </indexterm>

    <para>INTERNAL: Local datasets cannot be created</para>
  </sect1>

  <sect1 id="_4802">
    <title>4802</title>

    <indexterm>
      <primary>4802</primary>
    </indexterm>

    <para>INTERNAL: Attempt to access dataset outside of Thor</para>
  </sect1>

  <sect1 id="_4803">
    <title>4803</title>

    <indexterm>
      <primary>4803</primary>
    </indexterm>

    <para>INTERNAL: Not all Transform targets were assigned to [%s]</para>
  </sect1>

  <sect1 id="_4804">
    <title>4804</title>

    <indexterm>
      <primary>4804</primary>
    </indexterm>

    <para>INTERNAL: Cannot access stored variable %s in this context</para>
  </sect1>

  <sect1 id="_4805">
    <title>4805</title>

    <indexterm>
      <primary>4805</primary>
    </indexterm>

    <para>INTERNAL: Evaluate table is not in scope</para>
  </sect1>

  <sect1 id="_4806">
    <title>4806</title>

    <indexterm>
      <primary>4806</primary>
    </indexterm>

    <para>INTERNAL: Internal function %s not found</para>
  </sect1>

  <sect1 id="_4807">
    <title>4807</title>

    <indexterm>
      <primary>4807</primary>
    </indexterm>

    <para>INTERNAL: OUTPUT() on a scalar not processed correctly</para>
  </sect1>

  <sect1 id="_4808">
    <title>4808</title>

    <indexterm>
      <primary>4808</primary>
    </indexterm>

    <para>INTERNAL: Expression too complex - cannot create a DFA</para>
  </sect1>

  <sect1 id="_4809">
    <title>4809</title>

    <indexterm>
      <primary>4809</primary>
    </indexterm>

    <para>INTERNAL: Unsupported inline query</para>
  </sect1>

  <sect1 id="_4813">
    <title>4813</title>

    <indexterm>
      <primary>4813</primary>
    </indexterm>

    <para>INTERNAL: Could not resolve file position</para>
  </sect1>

  <sect1 id="_4814">
    <title>4814</title>

    <indexterm>
      <primary>4814</primary>
    </indexterm>

    <para>INTERNAL: Cannot perform type cast from %s to %s</para>
  </sect1>

  <sect1 id="_4815">
    <title>4815</title>

    <indexterm>
      <primary>4815</primary>
    </indexterm>

    <para>INTERNAL: Could not find context to evaluate match expression</para>
  </sect1>

  <sect1 id="_4816">
    <title>4816</title>

    <indexterm>
      <primary>4816</primary>
    </indexterm>

    <para>INTERNAL: Blob translation context not found</para>
  </sect1>

  <sect1 id="_4817">
    <title>4817</title>

    <indexterm>
      <primary>4817</primary>
    </indexterm>

    <para>INTERNAL: ROWS can not be evaluated in this context</para>
  </sect1>

  <sect1 id="_4818">
    <title>4818</title>

    <indexterm>
      <primary>4818</primary>
    </indexterm>

    <para>INTERNAL: Expected a parent/container context. Likely to be caused
    by executing something invalid inside a NOTHOR.</para>
  </sect1>

  <sect1 id="_4820">
    <title>4820</title>

    <indexterm>
      <primary>4820</primary>
    </indexterm>

    <para>INTERNAL: Could not resolve COUNTER for inline count project</para>
  </sect1>

  <sect1 id="_4821">
    <title>4821</title>

    <indexterm>
      <primary>4821</primary>
    </indexterm>

    <para>INTERNAL: Graph context not found</para>
  </sect1>

  <sect1 id="_4822">
    <title>4822</title>

    <indexterm>
      <primary>4822</primary>
    </indexterm>

    <para>INTERNAL: Accessing unserialized stored variable %s in slave
    context</para>
  </sect1>

  <sect1 id="_4823">
    <title>4823</title>

    <indexterm>
      <primary>4823</primary>
    </indexterm>

    <para>INTERNAL: Library '%s' shouldn't access work unit temporary
    '%s'</para>
  </sect1>

  <sect1 id="_4824">
    <title>4824</title>

    <indexterm>
      <primary>4824</primary>
    </indexterm>

    <para>INTERNAL: Library '%s' shouldn't create work unit temporary
    '%s'</para>
  </sect1>

  <sect1 id="_4825">
    <title>4825</title>

    <indexterm>
      <primary>4825</primary>
    </indexterm>

    <para>INTERNAL: Attempting to access graph output directly from a child
    query</para>
  </sect1>

  <sect1 id="_4826">
    <title>4826</title>

    <indexterm>
      <primary>4826</primary>
    </indexterm>

    <para>INTERNAL: Inconsistent activity localisation (child %d:graph
    %d)</para>
  </sect1>

  <sect1 id="_4827">
    <title>4827</title>

    <indexterm>
      <primary>4827</primary>
    </indexterm>

    <para>INTERNAL: No active parent extract - activity has incorrect
    localisation?</para>
  </sect1>

  <sect1 id="_4828">
    <title>4828</title>

    <indexterm>
      <primary>4828</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4829">
    <title>4829</title>

    <indexterm>
      <primary>4829</primary>
    </indexterm>

    <para>INTERNAL: Inputs to nary operation have inconsistent record
    structures</para>
  </sect1>

  <sect1 id="_4830">
    <title>4830</title>

    <indexterm>
      <primary>4830</primary>
    </indexterm>

    <para>INTERNAL: Linked child rows required without legal context
    available</para>
  </sect1>

  <sect1 id="_4833">
    <title>4833</title>

    <indexterm>
      <primary>4833</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="_4834">
    <title>4834</title>

    <indexterm>
      <primary>4834</primary>
    </indexterm>

    <para>INTERNAL: Cannot generated serialized compare function</para>
  </sect1>

  <sect1 id="_4835">
    <title>4835</title>

    <indexterm>
      <primary>4835</primary>
    </indexterm>

    <para>INTERNAL: Attempt to read spill file %s before it is written</para>
  </sect1>

  <sect1 id="_4836">
    <title>4836</title>

    <indexterm>
      <primary>4836</primary>
    </indexterm>

    <para>INTERNAL: Dependency within a graph incorrectly generated for hThor
    (%u)</para>
  </sect1>

  <sect1 id="_4837">
    <title>4837</title>

    <indexterm>
      <primary>4837</primary>
    </indexterm>

    <para>INTERNAL: Unrecognised compound assign %s</para>
  </sect1>
</chapter>
</book>