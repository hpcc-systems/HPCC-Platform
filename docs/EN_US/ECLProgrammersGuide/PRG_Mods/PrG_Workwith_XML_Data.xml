<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<sect1 id="Working_with_XML_Data">
  <!-- DNT-Start --><title>Working with XML Data</title><!-- DNT-End -->

  <para>Data is not always handed to you in nice, easy-to-work-with,
  fixed-length flat files; it comes in many forms. One form growing in usage
  every day is <!-- DNT-Start -->XML<!-- DNT-End -->. <!-- DNT-Start -->ECL<!-- DNT-End --> has a number of ways of handling <!-- DNT-Start -->XML<!-- DNT-End --> dataâsome obvious
  and some not so obvious.</para>

  <para><emphasis role="bold">NOTE:</emphasis> <!-- DNT-Start -->XML<!-- DNT-End --> reading and parsing can
  consume a large amount of memory, depending on the usage. In particular, if
  the specified <!-- DNT-Start -->XPATH<!-- DNT-End --> matches a very large amount of data, then a large data
  structure will be provided to the transform. Therefore, the more you match,
  the more resources you consume per match. For example, if you have a very
  large document and you match an element near the root that virtually
  encompasses the whole thing, then the whole thing will be constructed as a
  referenceable structure that the <!-- DNT-Start -->ECL<!-- DNT-End --> can get at.</para>

  <sect2 id="Simple_XML_Data_Handling">
    <!-- DNT-Start --><title>Simple XML Data Handling</title><!-- DNT-End -->

    <para>The <!-- DNT-Start -->XML<!-- DNT-End --> options on <!-- DNT-Start -->DATASET<!-- DNT-End --> and <!-- DNT-Start -->OUTPUT<!-- DNT-End --> allow you to easily work with
    simple <!-- DNT-Start -->XML<!-- DNT-End --> data. For example, an <!-- DNT-Start -->XML<!-- DNT-End --> file that looks like this (this data
    generated by the code in GenData.<!-- DNT-Start -->ECL<!-- DNT-End -->):</para>

    <!-- DNT-Start --><programlisting>&lt;?xml version=1.0 ...?&gt;
&lt;timezones&gt;
&lt;area&gt;
  &lt;code&gt;
        215
  &lt;/code&gt;
  &lt;state&gt;
        PA
  &lt;/state&gt;
  &lt;description&gt;
        Pennsylvania (Philadelphia area)
  &lt;/description&gt;
  &lt;zone&gt;
        Eastern Time Zone
  &lt;/zone&gt;
&lt;/area&gt;
&lt;area&gt;
  &lt;code&gt;
        216
  &lt;/code&gt;
  &lt;state&gt;
        OH
  &lt;/state&gt;
  &lt;description&gt;
        Ohio (Cleveland area)
  &lt;/description&gt;
  &lt;zone&gt;
        Eastern Time Zone
  &lt;/zone&gt;
&lt;/area&gt;
&lt;/timezones&gt;
</programlisting><!-- DNT-End -->

    <para>This file can be declared for use in your <!-- DNT-Start -->ECL<!-- DNT-End --> code (as this file is
    declared as the TimeZonesXML <!-- DNT-Start -->DATASET<!-- DNT-End --> declared in the DeclareData <!-- DNT-Start -->MODULE<!-- DNT-End -->
    Structure) like this:</para>

    <!-- DNT-Start --><programlisting>EXPORT TimeZonesXML :=
          DATASET('~PROGGUIDE::EXAMPLEDATA::XML_timezones',
                  {STRING code,
                   STRING state,
                   STRING description,
                   STRING timezone{XPATH('zone')}},
                  XML('timezones/area') );
</programlisting><!-- DNT-End -->

    <para>This makes the data contained within each <!-- DNT-Start -->XML<!-- DNT-End --> tag in the file
    available for use in your <!-- DNT-Start -->ECL<!-- DNT-End --> code just like any flat-file dataset. The
    field names in the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure (in this case, in-lined in the <!-- DNT-Start -->DATASET<!-- DNT-End -->
    declaration) duplicate the tag names in the file. The use of the <!-- DNT-Start -->XPATH<!-- DNT-End -->
    modifier on the timezone field allows us to specify that the field comes
    from the &lt;zone&gt; tag. This mechanism allows us to name fields
    differently from their tag names.</para>

    <para>By defining the fields as <!-- DNT-Start -->STRING<!-- DNT-End --> types without specifying their
    length, you can be sure you're getting all the dataâincluding any
    carriage-returns, line feeds, and tabs in the <!-- DNT-Start -->XML<!-- DNT-End --> file that are contained
    within the field tags (as are present in this file). This simple <!-- DNT-Start -->OUTPUT<!-- DNT-End -->
    shows the result (this and all subsequent code examples in this article
    are contained in the XMLcode.<!-- DNT-Start -->ECL<!-- DNT-End --> file).</para>

    <!-- DNT-Start --><programlisting>IMPORT $;

ds := $.DeclareData.timezonesXML;

OUTPUT(ds);</programlisting><!-- DNT-End -->

    <para>Notice that the result displayed in the <!-- DNT-Start -->ECL<!-- DNT-End --> <!-- DNT-Start -->IDE<!-- DNT-End --> program contains
    squares in the dataâthese are the carriage-returns, line feeds, and tabs
    in the data. You can get rid of the extraneous carriage-returns, line
    feeds, and tabs by simply passing the records through a <!-- DNT-Start -->PROJECT<!-- DNT-End --> operation,
    like this:</para>

    <!-- DNT-Start --><programlisting>StripIt(STRING str) := REGEXREPLACE('[\r\n\t]',str,'$1');
RECORDOF(ds) DoStrip(ds L) := TRANSFORM
  SELF.code := StripIt(L.code);
  SELF.state := StripIt(L.state);
  SELF.description := StripIt(L.description);
  SELF.timezone := StripIt(L.timezone);
END;
StrippedRecs := PROJECT(ds,DoStrip(LEFT));
OUTPUT(StrippedRecs);
</programlisting><!-- DNT-End -->

    <para>The use of the <!-- DNT-Start -->REGEXREPLACE<!-- DNT-End --> function makes the process very simple.
    Its first parameter is a standard Perl regular expression representing the
    characters to look for: carriage return (\r), line feed (\n), and tab
    (\t).</para>

    <para>You can now operate on the StrippedRecs recordset (or
    ProgGuide.TimeZonesXML dataset) just as you would with any other. For
    example, you might want to simply filter out unnecessary fields and
    records and write the result to a new <!-- DNT-Start -->XML<!-- DNT-End --> file to pass on, something like
    this:</para>

    <!-- DNT-Start --><programlisting>InterestingRecs := StrippedRecs((INTEGER)code BETWEEN 301 AND 303);
OUTPUT(InterestingRecs,{code,timezone},
       '~PROGGUIDE::EXAMPLEDATA::OUT::timezones300',
       XML('area',HEADING('&lt;?xml version=1.0 ...?&gt;\n&lt;timezones&gt;\n','&lt;/timezones&gt;')),OVERWRITE);
</programlisting><!-- DNT-End -->

    <para>The resulting <!-- DNT-Start -->XML<!-- DNT-End --> file looks like this:</para>

    <!-- DNT-Start --><programlisting>&lt;?xml version=1.0 ...?&gt;
&lt;timezones&gt;
&lt;area&gt;&lt;code&gt;301&lt;/code&gt;&lt;zone&gt;Eastern Time Zone&lt;/zone&gt;&lt;/area&gt;
&lt;area&gt;&lt;code&gt;302&lt;/code&gt;&lt;zone&gt;Eastern Time Zone&lt;/zone&gt;&lt;/area&gt;
&lt;area&gt;&lt;code&gt;303&lt;/code&gt;&lt;zone&gt;Mountain Time Zone&lt;/zone&gt;&lt;/area&gt;
&lt;/timezones&gt;
</programlisting><!-- DNT-End -->
  </sect2>

  <sect2 id="Complex_XML_Data_Handling">
    <!-- DNT-Start --><title>Complex XML Data Handling</title><!-- DNT-End -->

    <para>You can create much more complex <!-- DNT-Start -->XML<!-- DNT-End --> output by using the <!-- DNT-Start -->CSV<!-- DNT-End --> option
    on <!-- DNT-Start -->OUTPUT<!-- DNT-End --> instead of the <!-- DNT-Start -->XML<!-- DNT-End --> option. The <!-- DNT-Start -->XML<!-- DNT-End --> option will only produce the
    straight-forward style of <!-- DNT-Start -->XML<!-- DNT-End --> shown above. However, some applications
    require the use of <!-- DNT-Start -->XML<!-- DNT-End --> attributes inside the tags. This code demonstrates
    how to produce that format:</para>

    <!-- DNT-Start --><programlisting>CRLF := (STRING)x'0D0A';          
OutRec := RECORD
  STRING Line;
END;
OutRec DoComplexXML(InterestingRecs L) := TRANSFORM
SELF.Line := '  &lt;area code="' + L.code + '"&gt;' + CRLF +
             '    &lt;zone&gt;' + L.timezone + '&lt;/zone&gt;' + CRLF +
             '  &lt;/area&gt;';
END;
ComplexXML := PROJECT(InterestingRecs,DoComplexXML(LEFT));
OUTPUT(ComplexXML,,'~PROGGUIDE::EXAMPLEDATA::OUT::Complextimezones301',
       CSV(HEADING('&lt;?xml version=1.0 ...?&gt;'+CRLF+'&lt;timezones&gt;'+CRLF,'&lt;/timezones&gt;')),OVERWRITE);
</programlisting><!-- DNT-End -->

    <para>The <!-- DNT-Start -->RECORD<!-- DNT-End --> structure defines a single output field to contain each
    logical <!-- DNT-Start -->XML<!-- DNT-End --> record that you build with the <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> function. The <!-- DNT-Start -->PROJECT<!-- DNT-End -->
    operation builds all of the individual output records, then the <!-- DNT-Start -->CSV<!-- DNT-End --> option
    on the <!-- DNT-Start -->OUTPUT<!-- DNT-End --> action specifies the file header and footer records (in this
    case, the <!-- DNT-Start -->XML<!-- DNT-End --> file tags) and you get the result shown here:</para>

    <!-- DNT-Start --><programlisting>&lt;?xml version=1.0 ...?&gt;
&lt;timezones&gt;
  &lt;area code="301"&gt;
    &lt;zone&gt;Eastern Time Zone&lt;/zone&gt;
  &lt;/area&gt;
  &lt;area code="302"&gt;
    &lt;zone&gt;Eastern Time Zone&lt;/zone&gt;
  &lt;/area&gt;
  &lt;area code="303"&gt;
    &lt;zone&gt;Mountain Time Zone&lt;/zone&gt;
  &lt;/area&gt;
&lt;/timezones&gt;
</programlisting><!-- DNT-End -->

    <para>So, if using the <!-- DNT-Start -->CSV<!-- DNT-End --> option is the way to <!-- DNT-Start -->OUTPUT<!-- DNT-End --> complex <!-- DNT-Start -->XML<!-- DNT-End --> data
    formats, how can you access existing complex-format <!-- DNT-Start -->XML<!-- DNT-End --> data and use <!-- DNT-Start -->ECL<!-- DNT-End -->
    to work with it?</para>

    <para>The answer lies in using the <!-- DNT-Start -->XPATH<!-- DNT-End --> option on field definitions in
    the input <!-- DNT-Start -->RECORD<!-- DNT-End --> structure, like this:</para>

    <!-- DNT-Start --><programlisting>NewTimeZones := 
 DATASET('~PROGGUIDE::EXAMPLEDATA::OUT::Complextimezones301',
         {STRING area {XPATH('&lt;&gt;')}},
         XML('timezones/area'));
</programlisting><!-- DNT-End -->

    <para>The specified {<!-- DNT-Start -->XPATH<!-- DNT-End -->('&lt;&gt;')} option basically says âgive me
    everything that's in this <!-- DNT-Start -->XML<!-- DNT-End --> tag, including the tags themselvesâ so that
    you can then use <!-- DNT-Start -->ECL<!-- DNT-End --> to parse through the text to do your work. The
    NewTimeZones data records look like this one (since it includes all the
    carriage return/line feeds) when you do a simple <!-- DNT-Start -->OUTPUT<!-- DNT-End --> and copy the
    record to a text editor:</para>

    <!-- DNT-Start --><programlisting>&lt;area code="301"&gt;
  &lt;zone&gt;Eastern Time Zone&lt;/zone&gt;
&lt;/area&gt;</programlisting><!-- DNT-End -->

    <para>You can then use any of the string handling functions in <!-- DNT-Start -->ECL<!-- DNT-End --> or the
    Service Library functions in StringLib or UnicodeLib (see the
    <emphasis>Services Library Reference</emphasis>) to work with the text.
    However, the more powerful <!-- DNT-Start -->ECL<!-- DNT-End --> text parsing tool is the <!-- DNT-Start -->PARSE<!-- DNT-End --> function,
    allowing you to define regular expressions and/or <!-- DNT-Start -->ECL<!-- DNT-End --> <!-- DNT-Start -->PATTERN<!-- DNT-End --> attribute
    definitions to process the data.</para>

    <para>This example uses the <!-- DNT-Start -->TRANSFORM<!-- DNT-End --> version of <!-- DNT-Start -->PARSE<!-- DNT-End --> to get at the <!-- DNT-Start -->XML<!-- DNT-End -->
    data:</para>

    <!-- DNT-Start --><programlisting>{ds.code, ds.timezone} Xform(NewTimeZones L) := TRANSFORM
  SELF.code     := XMLTEXT('@code');
  SELF.timezone := XMLTEXT('zone');
END;
ParsedZones := PARSE(NewTimeZones,area,Xform(LEFT),XML('area'));

OUTPUT(ParsedZones);
</programlisting><!-- DNT-End -->

    <para>In this code we're using the <!-- DNT-Start -->XML<!-- DNT-End --> form of <!-- DNT-Start -->PARSE<!-- DNT-End --> and its associated
    <!-- DNT-Start -->XMLTEXT<!-- DNT-End --> function to parse the data from the complex <!-- DNT-Start -->XML<!-- DNT-End --> structure. The
    parameter to <!-- DNT-Start -->XMLTEXT<!-- DNT-End --> is the <!-- DNT-Start -->XPATH<!-- DNT-End --> to the data we're interested in (the
    major subset of the <!-- DNT-Start -->XPATH<!-- DNT-End --> standard that <!-- DNT-Start -->ECL<!-- DNT-End --> supports is documented in the
    Language Reference in the <!-- DNT-Start -->RECORD<!-- DNT-End --> structure discussion).</para>
  </sect2>

  <sect2 id="Input_with_Complex_XML_Formats">
    <!-- DNT-Start --><title>Input with Complex XML Formats</title><!-- DNT-End -->

    <para><!-- DNT-Start -->XML<!-- DNT-End --> data comes in many possible formats, and some of them make use
    of âchild datasetsâ such that a given tag may contain multiple instances
    of other tags that contain individual field tags themselves.</para>

    <para>Here's an example of such a complex structure using <!-- DNT-Start -->UCC<!-- DNT-End --> data. An
    individual Filing may contain one or more Transactions, which in turn may
    contain multiple Debtor and SecuredParty records:</para>

    <!-- DNT-Start --><programlisting>&lt;UCC&gt;
  &lt;Filing number='5200105'&gt;
    &lt;Transaction ID='5'&gt;
  &lt;StartDate&gt;08/01/2001&lt;/StartDate&gt;
  &lt;LapseDate&gt;08/01/2006&lt;/LapseDate&gt;
  &lt;FormType&gt;UCC 1 FILING STATEMENT&lt;/FormType&gt;
  &lt;AmendType&gt;NONE&lt;/AmendType&gt;
  &lt;AmendAction&gt;NONE&lt;/AmendAction&gt;
  &lt;EnteredDate&gt;08/02/2002&lt;/EnteredDate&gt;
  &lt;ReceivedDate&gt;08/01/2002&lt;/ReceivedDate&gt;
  &lt;ApprovedDate&gt;08/02/2002&lt;/ApprovedDate&gt;
  &lt;Debtor entityId='19'&gt;
    &lt;IsBusiness&gt;true&lt;/IsBusiness&gt;
    &lt;OrgName&gt;&lt;![CDATA[BOGUS LABORATORIES, INC.]]&gt;&lt;/OrgName&gt;
    &lt;Status&gt;ACTIVE&lt;/Status&gt;
    &lt;Address1&gt;&lt;![CDATA[334 SOUTH 900 WEST]]&gt;&lt;/Address1&gt;
    &lt;Address4&gt;&lt;![CDATA[SALT LAKE CITY 45 84104]]&gt;&lt;/Address4&gt;
    &lt;City&gt;&lt;![CDATA[SALT LAKE CITY]]&gt;&lt;/City&gt;
    &lt;State&gt;UTAH&lt;/State&gt;
    &lt;Zip&gt;84104&lt;/Zip&gt;
    &lt;OrgType&gt;CORP&lt;/OrgType&gt;
    &lt;OrgJurisdiction&gt;&lt;![CDATA[SALT LAKE CITY]]&gt;&lt;/OrgJurisdiction&gt;
    &lt;OrgID&gt;654245-0142&lt;/OrgID&gt;
    &lt;EnteredDate&gt;08/02/2002&lt;/EnteredDate&gt;
  &lt;/Debtor&gt;
  &lt;Debtor entityId='7'&gt;
    &lt;IsBusiness&gt;false&lt;/IsBusiness&gt;
    &lt;FirstName&gt;&lt;![CDATA[FRED]]&gt;&lt;/FirstName&gt;
    &lt;LastName&gt;&lt;![CDATA[JONES]]&gt;&lt;/LastName&gt;
    &lt;Status&gt;ACTIVE&lt;/Status&gt;
    &lt;Address1&gt;&lt;![CDATA[1038 E. 900 N.]]&gt;&lt;/Address1&gt;
    &lt;Address4&gt;&lt;![CDATA[OGDEN 45 84404]]&gt;&lt;/Address4&gt;
    &lt;City&gt;&lt;![CDATA[OGDEN]]&gt;&lt;/City&gt;
    &lt;State&gt;UTAH&lt;/State&gt;
    &lt;Zip&gt;84404&lt;/Zip&gt;
    &lt;OrgType&gt;NONE&lt;/OrgType&gt;
    &lt;EnteredDate&gt;08/02/2002&lt;/EnteredDate&gt;
  &lt;/Debtor&gt;
  &lt;SecuredParty entityId='20'&gt;
    &lt;IsBusiness&gt;true&lt;/IsBusiness&gt;
    &lt;OrgName&gt;&lt;![CDATA[WELLS FARGO BANK]]&gt;&lt;/OrgName&gt;
    &lt;Status&gt;ACTIVE&lt;/Status&gt;
    &lt;Address1&gt;&lt;![CDATA[ATTN: LOAN OPERATIONS CENTER]]&gt;&lt;/Address1&gt;
    &lt;Address3&gt;&lt;![CDATA[P.O. BOX 9120]]&gt;&lt;/Address3&gt;
    &lt;Address4&gt;&lt;![CDATA[BOISE 13 83707-2203]]&gt;&lt;/Address4&gt;
    &lt;City&gt;&lt;![CDATA[BOISE]]&gt;&lt;/City&gt;
    &lt;State&gt;IDAHO&lt;/State&gt;
    &lt;Zip&gt;83707-2203&lt;/Zip&gt;
    &lt;Status&gt;ACTIVE&lt;/Status&gt;
    &lt;EnteredDate&gt;08/02/2002&lt;/EnteredDate&gt;
  &lt;/SecuredParty&gt;
  &lt;Collateral&gt;
    &lt;Action&gt;ADD&lt;/Action&gt;
    &lt;Description&gt;&lt;![CDATA[ALL ACCOUNTS]]&gt;&lt;/Description&gt;
    &lt;EffectiveDate&gt;08/01/2002&lt;/EffectiveDate&gt;
  &lt;/Collateral&gt;
    &lt;/Transaction&gt;
    &lt;Transaction ID='375799'&gt;
  &lt;StartDate&gt;08/01/2002&lt;/StartDate&gt;
  &lt;LapseDate&gt;08/01/2006&lt;/LapseDate&gt;
  &lt;FormType&gt;UCC 3 AMENDMENT&lt;/FormType&gt;
  &lt;AmendType&gt;TERMINATION BY DEBTOR&lt;/AmendType&gt;
  &lt;AmendAction&gt;NONE&lt;/AmendAction&gt;
  &lt;EnteredDate&gt;02/23/2004&lt;/EnteredDate&gt;
  &lt;ReceivedDate&gt;02/18/2004&lt;/ReceivedDate&gt;
  &lt;ApprovedDate&gt;02/23/2004&lt;/ApprovedDate&gt;
    &lt;/Transaction&gt;
  &lt;/Filing&gt;
&lt;/UCC&gt;
</programlisting><!-- DNT-End -->

    <para>The key to working with this type of complex <!-- DNT-Start -->XML<!-- DNT-End --> data are the <!-- DNT-Start -->RECORD<!-- DNT-End -->
    structures that define the layout of the <!-- DNT-Start -->XML<!-- DNT-End --> data.</para>

    <!-- DNT-Start --><programlisting>CollateralRec := RECORD
  STRING Action        {XPATH('Action')}; 
  STRING Description   {XPATH('Description')}; 
  STRING EffectiveDate {XPATH('EffectiveDate')}; 
END;


PartyRec := RECORD
  STRING   PartyID         {XPATH('@entityId')}; 
  STRING   IsBusiness      {XPATH('IsBusiness')};
  STRING   OrgName         {XPATH('OrgName')};
  STRING   FirstName       {XPATH('FirstName')};
  STRING   LastName        {XPATH('LastName')};
  STRING   Status          {XPATH('Status[1]')};
  STRING   Address1        {XPATH('Address1')};
  STRING   Address2        {XPATH('Address2')};
  STRING   Address3        {XPATH('Address3')};
  STRING   Address4        {XPATH('Address4')};
  STRING   City            {XPATH('City')};
  STRING   State           {XPATH('State')};
  STRING   Zip             {XPATH('Zip')};
  STRING   OrgType         {XPATH('OrgType')};
  STRING   OrgJurisdiction {XPATH('OrgJurisdiction')};
  STRING   OrgID           {XPATH('OrgID')};
  STRING10 EnteredDate     {XPATH('EnteredDate')};
END;

TransactionRec := RECORD
  STRING            TransactionID  {XPATH('@ID')}; 
  STRING10          StartDate      {XPATH('StartDate')};   
  STRING10          LapseDate      {XPATH('LapseDate')};   
  STRING            FormType       {XPATH('FormType')};        
  STRING            AmendType      {XPATH('AmendType')};   
  STRING            AmendAction    {XPATH('AmendAction')};
  STRING10          EnteredDate    {XPATH('EnteredDate')};
  STRING10          ReceivedDate   {XPATH('ReceivedDate')};
  STRING10          ApprovedDate   {XPATH('ApprovedDate')};
  DATASET(PartyRec) Debtors        {XPATH('Debtor')};
  DATASET(PartyRec) SecuredParties {XPATH('SecuredParty')};
  CollateralRec     Collateral     {XPATH('Collateral')}
END;

UCC_Rec := RECORD 
  STRING                  FilingNumber {XPATH('@number')}; 
  DATASET(TransactionRec) Transactions {XPATH('Transaction')};
END; 
UCC := DATASET('~PROGGUIDE::EXAMPLEDATA::XML_UCC',UCC_Rec,XML('UCC/Filing')); 
</programlisting><!-- DNT-End -->

    <para>Building from the bottom up, these <!-- DNT-Start -->RECORD<!-- DNT-End --> structures combine to
    create the final <!-- DNT-Start -->UCC<!-- DNT-End -->_Rec layout that defines the entire format of this <!-- DNT-Start -->XML<!-- DNT-End -->
    data.</para>

    <para>The <!-- DNT-Start -->XML<!-- DNT-End --> option on the final <!-- DNT-Start -->DATASET<!-- DNT-End --> declaration specifies the <!-- DNT-Start -->XPATH<!-- DNT-End -->
    to the record tag (Filing) then the child <!-- DNT-Start -->DATASET<!-- DNT-End --> âfieldâ definitions in
    the <!-- DNT-Start -->RECORD<!-- DNT-End --> structures handle the multiple instance issues. Because <!-- DNT-Start -->ECL<!-- DNT-End --> is
    case insensitive and <!-- DNT-Start -->XML<!-- DNT-End --> syntax is case sensitive, it is necessary to use
    the <!-- DNT-Start -->XPATH<!-- DNT-End --> to define all the field tags. The PartyRec <!-- DNT-Start -->RECORD<!-- DNT-End --> structure
    works with both the Debtors and SecuredParties child <!-- DNT-Start -->DATASET<!-- DNT-End --> fields
    because both contain the same tags and information.</para>

    <para>Once you've defined the layout, how can you extract the data into a
    normalized relational structure to work with it in the supercomputer?
    <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> is the answer. <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> needs to know how many times to call
    its <!-- DNT-Start -->TRANSFORM<!-- DNT-End -->, so you must use the <!-- DNT-Start -->TABLE<!-- DNT-End --> function to get the counts, like
    this:</para>

    <!-- DNT-Start --><programlisting>XactTbl := TABLE(UCC,{INTEGER XactCount := COUNT(Transactions), UCC});

OUTPUT(XactTbl);</programlisting><!-- DNT-End -->

    <para>This <!-- DNT-Start -->TABLE<!-- DNT-End --> function gets the counts of the multiple Transaction
    records per Filing so that we can use <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> to extract them into a
    table of their own.</para>

    <!-- DNT-Start --><programlisting>Out_Transacts := RECORD
   STRING            FilingNumber;
   STRING            TransactionID; 
   STRING10          StartDate;     
   STRING10          LapseDate;     
   STRING            FormType;         
   STRING            AmendType;     
   STRING            AmendAction;
   STRING10          EnteredDate;
   STRING10          ReceivedDate;
   STRING10          ApprovedDate;
   DATASET(PartyRec) Debtors;
   DATASET(PartyRec) SecuredParties;
   CollateralRec     Collateral;
END;

Out_Transacts Get_Transacts(XactTbl L, INTEGER C) := TRANSFORM
  SELF.FilingNumber := L.FilingNumber;
  SELF              := L.Transactions[C]; 
END;

Transacts := NORMALIZE(XactTbl,LEFT.XactCount,Get_Transacts(LEFT,COUNTER));

OUTPUT(Transacts);
</programlisting><!-- DNT-End -->

    <para>This <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> extracts all the Transactions into a separate
    recordset with just one Transaction per record with the parent information
    (the Filing number) appended. However, each record here still contains
    multiple Debtor and SecuredParty child records.</para>

    <!-- DNT-Start --><programlisting>PartyCounts := TABLE(Transacts,
                     {INTEGER DebtorCount := COUNT(Debtors), 
                      INTEGER PartyCount := COUNT(SecuredParties),
                      Transacts});

OUTPUT(PartyCounts);
</programlisting><!-- DNT-End -->

    <para>This <!-- DNT-Start -->TABLE<!-- DNT-End --> function gets the counts of the multiple Debtor and
    SecuredParty records for each Transaction.</para>

    <!-- DNT-Start --><programlisting>Out_Parties := RECORD
   STRING   FilingNumber;
   STRING   TransactionID;
   PartyRec; 
END;

Out_Parties Get_Debtors(PartyCounts L, INTEGER C) := TRANSFORM
  SELF.FilingNumber  := L.FilingNumber;
  SELF.TransactionID := L.TransactionID; 
  SELF               := L.Debtors[C]; 
END;
TransactDebtors := NORMALIZE( PartyCounts,
                              LEFT.DebtorCount,
                              Get_Debtors(LEFT,COUNTER));

OUTPUT(TransactDebtors);
</programlisting><!-- DNT-End -->

    <para>This <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> extracts all the Debtors into a separate
    recordset.</para>

    <!-- DNT-Start --><programlisting>Out_Parties Get_Parties(PartyCounts L, INTEGER C) := TRANSFORM
  SELF.FilingNumber  := L.FilingNumber;
  SELF.TransactionID := L.TransactionID; 
  SELF               := L.SecuredParties[C]; 
END;

TransactParties := NORMALIZE(PartyCounts,
                             LEFT.PartyCount,
                             Get_Parties(LEFT,COUNTER));

OUTPUT(TransactParties);
</programlisting><!-- DNT-End -->

    <para>This <!-- DNT-Start -->NORMALIZE<!-- DNT-End --> extracts all the SecuredParties into a separate
    recordset. With this, we've now broken out all the child records into
    their own normalized relational structure that we can work with
    easily.</para>
  </sect2>

  <sect2 id="Piping_to_Third-Party_Tools">
    <!-- DNT-Start --><title>Piping to Third-Party Tools</title><!-- DNT-End -->

    <para>One other way to work with <!-- DNT-Start -->XML<!-- DNT-End --> data is to use third-party tools that
    you have adapted for use in the supercomputer so that you have the
    advantage of working with previously proven technology and the benefit of
    running that technology in parallel on all the supercomputer nodes at
    once.</para>

    <para>The technique is simple: just define the input file as a data stream
    and use the <!-- DNT-Start -->PIPE<!-- DNT-End --> option on <!-- DNT-Start -->DATASET<!-- DNT-End --> to process the data in its native form.
    Once the processing is complete, you can <!-- DNT-Start -->OUTPUT<!-- DNT-End --> the result in whatever
    form it comes out of the third-party tool, something like this example
    code (non-functional):</para>

    <!-- DNT-Start --><programlisting>Rec := RECORD
  STRING1  char;
END;

TimeZones := DATASET('timezones.xml',Rec,PIPE('ThirdPartyTool.exe'));

OUTPUT(TimeZones,,'ProcessedTimezones.xml');
</programlisting><!-- DNT-End -->

    <para>The key to this technique is the <!-- DNT-Start -->STRING<!-- DNT-End -->1 field definition. This
    makes the input and output just a 1-byte-at-a-time data stream that flows
    into the third-party tool and back out of your <!-- DNT-Start -->ECL<!-- DNT-End --> code in its native
    format. You don't even need to know what that format is. You could also
    use this technique with the <!-- DNT-Start -->PIPE<!-- DNT-End --> option on <!-- DNT-Start -->OUTPUT<!-- DNT-End -->.</para>
  </sect2>
</sect1>
