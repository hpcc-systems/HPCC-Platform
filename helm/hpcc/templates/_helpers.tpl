{{/*

---  DO NOT EDIT THIS FILE - all configuration of HPCC platform should be done via values.yaml ----
  
##############################################################################

    HPCC SYSTEMS software Copyright (C) 2021 HPCC SystemsÂ®.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    
##############################################################################

*/}}
{{/*
Expand the name of the chart.
Pass in dict with root
*/}}
{{- define "hpcc.name" -}}
{{- default .root.Chart.Name .root.Values.nameOverride | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
Pass in dict with root
*/}}
{{- define "hpcc.fullname" -}}
{{- if .root.Values.fullnameOverride -}}
{{- .root.Values.fullnameOverride | trunc 63 | trimSuffix "-" -}}
{{- else -}}
{{- $name := default .root.Chart.Name .root.Values.nameOverride -}}
{{- if contains $name .root.Release.Name -}}
{{- .root.Release.Name | trunc 63 | trimSuffix "-" -}}
{{- else -}}
{{- printf "%s-%s" .root.Release.Name $name | trunc 63 | trimSuffix "-" -}}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Create chart name and version as used by the chart label.
Pass in dict with root
*/}}
{{- define "hpcc.chart" -}}
{{- printf "%s-%s" .root.Chart.Name .root.Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" -}}
{{- end -}}

{{/*
Translate a port list to a comma-separated list
*/}}
{{- define "hpcc.portListToCommas" -}}
 {{- if hasPrefix "[]" (typeOf .) -}}
  {{- $local := dict "first" true -}}
  {{- range $key, $value := . -}}{{- if not $local.first -}},{{- end -}}{{- $value -}}{{- $_ := set $local "first" false -}}{{- end -}}
 {{- else -}}
  {{- . -}} 
 {{- end -}}
{{- end -}}

{{- define "hpcc.getFirstPlaneForLabel" -}}
{{- $root := .root -}}
{{- $label := .label -}}
{{- $storage := ($root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $firstPlane := dict -}}
{{- range $plane := $planes -}}
{{- if not $firstPlane.plane -}}
{{- $labels := $plane.labels | default (list "data") -}}
{{- if (has $label $labels) -}}
{{- $_ := set $firstPlane "plane" $plane.name -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- if $firstPlane.plane -}}
{{- $firstPlane.plane -}}
{{- end -}}
{{- end -}}

{{- define "hpcc.hasPlaneForLabel" -}}
{{- if (include "hpcc.getFirstPlaneForLabel" .) -}}
true
{{- end -}}
{{- end -}}

{{/*
Get default data plane
*/}}
{{- define "hpcc.getDefaultDataPlane" -}}
{{- $storage := ($.Values.storage | default dict) -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- $firstPlane := (include "hpcc.getFirstPlaneForLabel" (dict "root" $ "label" "data")) -}}
{{- $dataStorage.plane | default $firstPlane | default "hpcc-data-plane" -}}
{{- end -}}

{{/*
Get default dll plane
*/}}
{{- define "hpcc.getDefaultDllPlane" -}}
{{- $storage := ($.Values.storage | default dict) -}}
{{- $dllStorage := ($storage.dllStorage | default dict) -}}
{{- $firstPlane := (include "hpcc.getFirstPlaneForLabel" (dict "root" $ "label" "dll")) -}}
{{- $dllStorage.plane | default $firstPlane | default "hpcc-dll-plane" -}}
{{- end -}}

{{/*
Generate global ConfigMap info
Pass in root as .
*/}}
{{- define "hpcc.generateGlobalConfigMap" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- $spillStorage := ($storage.spillStorage | default dict) -}}
{{- $daliStorage := ($storage.daliStorage | default dict) -}}
{{- $dllStorage := ($storage.dllStorage | default dict) -}}
{{- $certificates := (.Values.certificates | default dict) -}}
{{- $issuers := ($certificates.issuers | default dict) -}}
mtls: {{ and ($certificates.enabled) (hasKey $issuers "local") }}
imageVersion: {{ .Values.global.image.version | default .Chart.Version }}
singleNode: {{ .Values.global.singleNode | default false }}
{{ if .Values.global.defaultEsp -}}
defaultEsp: {{ .Values.global.defaultEsp | quote }}
{{ end -}}
services:
{{ include "hpcc.generateConfigMapServices" . }}
secretTimeout: {{ .Values.secrets.timeout | default 300 }}
storage:
{{- if hasKey $storage "hostGroups" }}
  hostGroups:
{{ toYaml $storage.hostGroups | indent 2 }}
{{- end }}
  dataPlane: {{ include "hpcc.getDefaultDataPlane" . }}
  planes:
{{- /*Generate entries for each data plane (removing the pvc).  Exclude the planes used for dlls and dali.*/ -}}
{{- range $plane := $planes -}}
 {{- if or (not $plane.labels) (or (has "data" $plane.labels) (has "lz" $plane.labels)) }}
  - name: {{ $plane.name | quote }}
  {{- if not $plane.labels }}
    labels:
    - data
  {{- end }}
{{ toYaml (omit $plane "name" "pvc" "storageClass" "storageSize") | indent 4 }}
 {{- end }}
{{- end }}
{{- /* Add implicit planes if data or spill storage plane not specified*/ -}}
{{- if not $dataStorage.plane }}
{{- if not (include "hpcc.hasPlaneForLabel" (dict "root" $ "label" "data")) }}
  - name: hpcc-data-plane
    labels:
    - data
    prefix: {{ .Values.global.defaultDataPath | default "/var/lib/HPCCSystems/hpcc-data" | quote }}
{{- end }}
{{- end }}
{{- if not $spillStorage.plane }}
{{- if not (include "hpcc.hasPlaneForLabel" (dict "root" $ "label" "spill")) }}
  - name: hpcc-spill-plane
    prefix: {{ .Values.global.defaultSpillPath | default "/var/lib/HPCCSystems/hpcc-spill" | quote }}
{{- end }}
{{- end }}
{{- if .Values.global.cost }}
cost:
{{ toYaml .Values.global.cost | indent 2 }}
{{- end }}
{{- end -}}

{{/*
Generate dfuserver queues
Pass in root
*/}}
{{- define "hpcc.generateConfigDfuQueues" -}}
{{- range $queue := .root.Values.dfuserver }}
{{- if not $queue.disabled }}
- name: {{ .name }}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Generate local logging info, merged with global
Pass in dict with root and me
*/}}
{{- define "hpcc.generateLoggingConfig" -}}
{{- $logging := deepCopy (.me.logging | default dict) | mergeOverwrite dict (.root.Values.global.logging | default dict) -}}
{{- if not (empty $logging) }}
logging:
{{ toYaml $logging | indent 2 }}
{{- end -}}
{{- end -}}

{{/*
Generate local metrics configuration, merged with global
Pass in dict with root and me
*/}}
{{- define "hpcc.generateMetricsConfig" -}}
{{- $metrics := deepCopy (.me.metrics | default dict) | mergeOverwrite dict (.root.Values.global.metrics | default dict) -}}
{{- if not (empty $metrics) }}
metrics:
{{ toYaml $metrics | indent 2 }}
{{- end -}}
{{- end -}}

{{/*
Add ConfigMap volume mount for a component
*/}}
{{- define "hpcc.addConfigMapVolumeMount" -}}
- name: {{ .name }}-temp-volume
  mountPath: /tmp
- name: {{ .name }}-hpcctmp-volume
  mountPath: /var/lib/HPCCSystems
- name: {{ .name }}-configmap-volume
  mountPath: /etc/config
{{- end -}}

{{/*
Add ConfigMap volume for a component
*/}}
{{- define "hpcc.addConfigMapVolume" -}}
- name: {{ .name }}-temp-volume
  emptyDir: {}
- name: {{ .name }}-hpcctmp-volume
  emptyDir: {}
- name: {{ .name }}-configmap-volume
  configMap:
    name: {{ .name }}-configmap
{{- end -}}

{{/*
Returns a non empty string if any labels in the list includeLabels is in the plane.labels
Note: the list includeLabels may contain an empty string (""), which matches planes that do not have a label
Pass in plane and includeLabels
Return: If there is any matching labels, there will be a non-empty string returned.  If there is no matching labels,
        an empty string will be returned.
*/}}
{{- define "hpcc.doesStorageLabelsMatch" -}}
{{- $plane := .plane -}}
  {{- range $label := .includeLabels -}}
    {{- if and (eq $label "") (not $plane.labels) -}}
      {{- print "T" -}}
    {{- else if has $label $plane.labels -}}
      {{- print "T" -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

{{/*
Add volume mounts
Pass in root and includeLabels (optional)
Note: if there are multiple planes (other than dll, dali and spill planes), they should be all called with a single call
to addVolumeMounts so that if a plane can be used for multiple purposes then duplicate volume mounts are not created.
*/}}
{{- define "hpcc.addVolumeMounts" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $includeLabels := .includeLabels | default list -}}
{{- range $plane := $planes -}}
 {{- if or ($plane.pvc) (hasKey $plane "storageClass") -}}
  {{- $mountpath := $plane.prefix -}}
  {{- $matchedLabels := include "hpcc.doesStorageLabelsMatch" (dict "plane" $plane "includeLabels" $includeLabels) }}
  {{ if ne $matchedLabels "" }}
   {{- $num := int ( $plane.numDevices | default 1 ) -}}
   {{- if le $num 1 }}
- name: {{ lower $plane.name }}-pv
  mountPath: {{ $mountpath | quote }}
   {{- else }}
    {{- range $elem := untilStep 1 (int (add $num 1)) 1 }}
- name: {{ lower $plane.name }}-pv-many-{{- $elem }}
  mountPath: {{ printf "%s/d%d" $mountpath $elem | quote }}
    {{- end }}
   {{- end }}
  {{- end }}
 {{- end }}
{{- end }}
{{- /*
Create a data volume mount if data plane have not been specified in storage.planes
Note: Some services used addVolumeMounts to add data planes and other types of plane using addVolumeMounts, so this code has
to be located here rather than in addDataVolumeMount.
*/ -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- if and (has "data" $includeLabels) (not $dataStorage.plane) }}
{{- if (not (include "hpcc.hasPlaneForLabel" (dict "root" .root "label" "data"))) }}
- name: datastorage
  mountPath: "/var/lib/HPCCSystems/hpcc-data"
{{- end }}
{{- end }}
{{- end -}}

{{/*
Add data volume mount
Pass in root
*/}}
{{- define "hpcc.addDataVolumeMount" -}}
{{- include "hpcc.addVolumeMounts" (dict "root" .root "includeLabels" (list "data" "" "lz")) -}}
{{- end -}}

{{/*
Add volumes
Pass in root and includeLabels (optional)
*/}}
{{- define "hpcc.addVolumes" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $includeLabels := .includeLabels | default list -}}
{{- $filterName := .name | default "" -}}
{{- range $plane := $planes -}}
 {{- if or ($plane.pvc) (hasKey $plane "storageClass") -}}
  {{- $matchedLabels := include "hpcc.doesStorageLabelsMatch" (dict "plane" $plane "includeLabels" $includeLabels) -}}
  {{- if ne $matchedLabels "" }}
   {{- if or (not $filterName) (eq $filterName $plane.name) }}
    {{- $pvc := hasKey $plane "pvc" | ternary $plane.pvc (printf "%s-%s-pvc" (include "hpcc.fullname" $) $plane.name) -}}
    {{- $num := int ( $plane.numDevices | default 1 ) -}}
    {{- if le $num 1 }}
- name: {{ lower $plane.name }}-pv
  persistentVolumeClaim:
    claimName: {{ $pvc }}
    {{- else }}
     {{- range $elem := until $num }}
- name: {{ lower $plane.name }}-pv-many-{{- add $elem 1 }}
  persistentVolumeClaim:
    claimName: {{ $pvc }}-{{- add $elem 1 }}
     {{- end }}
    {{- end -}}
   {{- end -}}
  {{- end }}
 {{- end }}
{{- end -}}
{{- /*
Create a data volume if data plane have not been specified in storage.planes
Note: Some services used addVolumes to add data planes and other types of plane using addVolumes, so this code has
to be located here rather than in addDataVolumes.
*/ -}}
{{- if and (has "data" $includeLabels) (not $dataStorage.plane) }}
{{- if (not (include "hpcc.hasPlaneForLabel" (dict "root" .root "label" "data"))) }}
- name: datastorage
  persistentVolumeClaim:
    claimName: {{ $dataStorage.existingClaim | default (printf "%s-datastorage" (include "hpcc.fullname" . )) }}
{{- end }}
{{- end }}
{{- end -}}

{{/*
Add data volume
Pass in dict with root
*/}}
{{- define "hpcc.addDataVolume" -}}
{{- include "hpcc.addVolumes" (dict "root" .root "includeLabels" (list "data" "" "lz") ) -}}
{{- end -}}

{{/*
Add a volume mount - if default plane is used, or the storage plane specifies a pvc
Pass in dict with root, me, name, and optional path
*/}}
{{- define "hpcc.getVolumeMountPrefix" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- if .me.plane -}}
{{- $me := .me -}}
 {{- range $plane := $planes -}}
  {{- if and (or ($plane.pvc) (hasKey $plane "storageClass")) (eq $plane.name $me.plane) -}}
{{ $plane.prefix }}
  {{- end -}}
 {{- end -}}
{{- else -}}
{{ printf "/var/lib/HPCCSystems/%s" (.path | default (printf "%sstorage" .name)) | quote }}
{{- end -}}
{{- end -}}

{{/*
Add a volume mount - if default plane is used, or the storage plane specifies a pvc
Pass in dict with root, me, name, and optional path
*/}}
{{- define "hpcc.addVolumeMount" -}}
{{- $mountPath := include "hpcc.getVolumeMountPrefix" . }}
{{- if not $mountPath -}}
{{- $_ := fail (printf "Invalid storage definition for: %s" .name ) -}}
{{- end -}}
- name: {{ .name }}
  mountPath: {{ $mountPath }}
{{- end -}}

{{/*
Add dll volume mount - if default plane is used, or the dll storage plane specifies a pvc
Pass in dict with root
*/}}
{{- define "hpcc.addDllVolumeMount" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $dllStorage := ($storage.dllStorage | default dict) -}}
{{- if not $dllStorage.plane -}}
{{- if (not (include "hpcc.hasPlaneForLabel" (dict "root" .root "label" "dll"))) }}
{{ include "hpcc.addVolumeMount" (dict "root" .root "me" $dllStorage "name" "dllstorage" "path" "queries") }}
{{- end -}}
{{- end -}}
{{- include "hpcc.addVolumeMounts" (dict "root" .root "includeLabels" (list "dll")) -}}
{{- end -}}

{{/*
Add dali volume mount - if default plane is used, or the dali storage plane specifies a pvc
Pass in dict with root
*/}}
{{- define "hpcc.addDaliVolumeMount" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $daliStorage := ($storage.daliStorage | default dict) -}}
{{- if not $daliStorage.plane -}}
{{- if (not (include "hpcc.hasPlaneForLabel" (dict "root" .root "label" "dali"))) }}
{{ include "hpcc.addVolumeMount" (dict "root" .root "me" $daliStorage "name" "dalistorage" "path" "dalistorage") }}
{{- end -}}
{{- end -}}
{{- include "hpcc.addVolumeMounts" (dict "root" .root "includeLabels" (list "dali")) -}}
{{- end -}}

{{/*
Add a volume - if default plane is used, or the storage plane specifies a pvc
Pass in dict with root, me and name
*/}}
{{- define "hpcc.addVolume" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $label := .label -}}
{{- if not .me.plane -}}
{{- if (not (include "hpcc.hasPlaneForLabel" (dict "root" .root "label" $label))) }}
- name: {{ .name }}
  persistentVolumeClaim:
    claimName: {{ .me.existingClaim | default (printf "%s-%s" (include "hpcc.fullname" .) .name) }}
{{- end }}
{{- end -}}
{{- end -}}

{{/*
Add dll volume - if default plane is used, or the dll storage plane specifies a pvc
Pass in dict with root
*/}}
{{- define "hpcc.addDllVolume" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $dllStorage := ($storage.dllStorage | default dict) -}}
{{- include "hpcc.addVolume" (dict "root" .root "name" "dllstorage" "me" $dllStorage "label" "dll") }}
{{- include "hpcc.addVolumes" (dict "root" .root "includeLabels" (list "dll") ) }}
{{- end -}}

{{/*
Add dali volume - if default plane is used, or the dali storage plane specifies a pvc
Pass in dict with root
*/}}
{{- define "hpcc.addDaliVolume" -}}
{{- /*Create local variables which always exist to avoid having to check if intermediate key values exist*/ -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $daliStorage := ($storage.daliStorage | default dict) -}}
{{- include "hpcc.addVolume" (dict "root" .root "name" "dalistorage" "me" $daliStorage "label" "dali") }}
{{- include "hpcc.addVolumes" (dict "root" .root "includeLabels" (list "dali") ) }}
{{- end -}}

{{/*
Add the secret volume mounts for a component
Pass in dict with root and secretsCategories
*/}}
{{- define "hpcc.addSecretVolumeMounts" -}}
{{- $secretsCategories := .secretsCategories -}}
{{- range $category, $key := .root.Values.secrets -}}
 {{- if (has $category $secretsCategories) -}}
{{- range $secretid, $secretname := $key -}}
- name: secret-{{ $secretid }}
  mountPath: /opt/HPCCSystems/secrets/{{ $category }}/{{ $secretid }}
{{ end -}}
 {{- end -}}
{{- end -}}
{{- end -}}

{{/*
Add Secret volume for a component
Pass in dict with root and secretsCategories
*/}}
{{- define "hpcc.addSecretVolumes" -}}
{{- $component := .component -}}
{{- $secretsCategories := .secretsCategories -}}
{{- range $category, $key := .root.Values.secrets -}}
{{- if (has $category $secretsCategories) -}}
{{- range $secretid, $secretname := $key }}
- name: secret-{{ $secretid }}
  secret:
    secretName: {{ $secretname }}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Add sentinel-based probes for a component
*/}}
{{- define "hpcc.addSentinelProbes" -}}
{{- $minStartupTime := .minStartupTime | default 0 }}
{{- $maxStartupTime := .maxStartupTime | default 300 }}
{{- $numAttempts := div (sub $maxStartupTime $minStartupTime) 10 }}
startupProbe:
  exec:
    command:
    - cat
    - "/tmp/{{ .name }}.sentinel"
  failureThreshold: {{ $numAttempts }}
  periodSeconds: 10
  initialDelaySeconds: {{ $minStartupTime }}
readinessProbe:
  exec:
    command:
    - cat
    - "/tmp/{{ .name }}.sentinel"
  periodSeconds: 10
{{ end -}}


{{/*
Generate vault info
*/}}
{{- define "hpcc.generateVaultConfig" -}}
{{- $secretsCategories := .secretsCategories -}}
vaults:
{{- range  $categoryname, $category := .root.Values.vaults -}}
 {{- if (has $categoryname $secretsCategories) }}
  {{ $categoryname }}:
  {{- range $vault := . }}
    - name: {{ $vault.name }}
      kind: {{ $vault.kind }}
      url: {{ $vault.url }}
    {{- if index $vault "client-secret" }}
      client-secret: {{ index $vault "client-secret" }}
    {{- end -}}
  {{- end -}}
 {{- end -}}
{{- end -}}
{{- end -}}

{{/*
Return a value indicating whether a storage plane is defined or not.
*/}}
{{- define "hpcc.isValidStoragePlane" -}}
{{- $search := .search -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- /* If storage.dataStorage.plane is defined, the implicit plane hpcc-dataplane is not defined */ -}}
{{- $done := dict "matched" (and (not $dataStorage.plane) (eq $search "hpcc-dataplane")) -}}
{{- range $plane := $planes -}}
 {{- if eq $search $plane.name -}}
 {{- $_ := set $done "matched" true -}}
 {{- end -}}
{{- end -}}
{{- $done.matched | ternary "true" "false" -}}
{{- end -}}

{{/*
Check that the storage and spill planes for a component exist
*/}}
{{- define "hpcc.checkDefaultStoragePlane" -}}
{{- if (hasKey .me "storagePlane") }}
 {{- $search := .me.storagePlane -}}
 {{- if ne (include "hpcc.isValidStoragePlane" (dict "search" $search "root" .root)) "true" -}}
  {{- $_ := fail (printf "storage data plane %s for %s is not defined" $search .me.name ) }}
 {{- end -}}
{{- end }}
{{- if (hasKey .me "spillPlane") }}
 {{- $search := .me.spillPlane -}}
 {{- if ne (include "hpcc.isValidStoragePlane" (dict "search" $search "root" .root)) "true" -}}
  {{- $_ := fail (printf "storage spill plane %s for %s is not defined" $search .me.name ) }}
 {{- end -}}
{{- end }}
{{- end -}}

{{/*
Add config arg for a component
*/}}
{{- define "hpcc.configArg" -}}
"--config=/etc/config/{{ .name }}.yaml"
{{- end -}}

{{/*
Add dali arg for a component
*/}}
{{- define "hpcc.daliArg" -}}
"--daliServers={{ (index .Values.dali 0).name }}"
{{- end -}}

{{/*
Get image name
*/}}
{{- define "hpcc.imageName" -}}
{{- /* Pass in a dictionary with root and me defined */ -}}
{{- if .me.image -}}
{{ .me.image.root | default .root.Values.global.image.root | default "hpccsystems" }}/{{ .me.image.name | default .root.Values.global.image.name | default "platform-core" }}:{{ .me.image.version | default .root.Values.global.image.version | default .root.Chart.Version }}
{{- else -}}
{{ .root.Values.global.image.root | default "hpccsystems" }}/{{ .root.Values.global.image.name | default "platform-core" }}:{{ .root.Values.global.image.version | default .root.Chart.Version }}
{{- end -}}
{{- end -}}

{{/*
Add image attributes for a component 
Pass in a dictionary with root, me and imagename defined
*/}}
{{- define "hpcc.addImageAttrs" -}}
image: {{ include "hpcc.imageName" . | quote }}
{{ if .me.image -}}
imagePullPolicy: {{ .me.image.pullPolicy | default .root.Values.global.image.pullPolicy | default "IfNotPresent" }}
{{- else -}}
imagePullPolicy: {{ .root.Values.global.image.pullPolicy | default "IfNotPresent" }}
{{- end -}}
{{- end -}}

{{/*
A kludge to ensure mounted storage (e.g. for nfs, minikube or docker for desktop) has correct permissions for PV
*/}}
{{- define "hpcc.changeMountPerms" -}}
# This is a bit of a hack, to ensure that the persistent storage mounted is writable.
# This is only required when mounting a remote filing systems from another container or machine.
# NB: this includes where the filing system is on the containers host machine .
# Examples include, minikube, docker for desktop, or NFS mounted storage.
# NB: uid=10000 and gid=10001 are the uid/gid of the hpcc user, built into platform-core
{{- $permCmd := printf "chown -R 10000:10001 %s" .volumePath }}
- name: volume-mount-hack
  image: busybox
  command: [
             "sh",
             "-c",
             "{{ $permCmd }}"
           ]
  volumeMounts:
    - name: {{ .volumeName | quote}}
      mountPath: {{ .volumePath | quote }}
{{- end }}

{{/*
A kludge to ensure mounted storage (e.g. for nfs, minikube or docker for desktop) has correct permissions for PV
*/}}
{{- define "hpcc.changePlaneMountPerms" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $planes := ($storage.planes | default list) -}}
  {{- $includeLabels := .includeLabels | default list -}}
{{- range $plane := $planes -}}
 {{- if and ($plane.forcePermissions) (or ($plane.pvc) (hasKey $plane "storageClass")) -}}
  {{- $mountpath := $plane.prefix -}}
  {{- $matchedLabels := include "hpcc.doesStorageLabelsMatch" (dict "plane" $plane "includeLabels" $includeLabels) }}
  {{- if ne $matchedLabels "" }}
{{- $volumeName := (printf "%s-pv" $plane.name) -}}
{{ include "hpcc.changeMountPerms" (dict "root" .root "volumeName" $volumeName "volumePath" $plane.prefix) }}
{{- end }}
{{- end }}
{{- end }}
{{- end }}


{{/*
Container to watch for a file on a shared mount and execute a command
Pass in dict with me and command
NB: an alternative to sleep loop would be to install and make use of inotifywait
*/}}
{{- define "hpcc.addWaitAndRunContainer" -}}
- name: wait-and-run
  image: busybox
  command:
    - sh
    - "-c"
    - |
      /bin/sh <<'EOSCRIPT'
      set -e
      while true; do
        if [ -f /wait-and-run/{{ .me.name }}.jobdone ]; then break; fi
        echo waiting for /wait-and-run/{{ .me.name }}.jobdone
        sleep 5
      done
      echo "Running: {{ .command }}"
      if {{ .command }}; then
        echo "Command succeeded"
      fi
      EOSCRIPT
  volumeMounts:
  - name: wait-and-run
    mountPath: "/wait-and-run"
{{- end }}

{{/*
Add wait-and-run shared inter container mount
*/}}
{{- define "hpcc.addWaitAndRunVolumeMount" -}}
- name: wait-and-run
  mountPath: "/wait-and-run"
{{- end }}

{{/*
Add wait-and-run shared inter container volume
*/}}
{{- define "hpcc.addWaitAndRunVolume" -}}
- name: wait-and-run
  emptyDir: {}
{{- end }}

{{/*
Check dll mount point, using hpcc.changeMountPerms
*/}}
{{- define "hpcc.checkDllMount" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $dllStorage := ($storage.dllStorage | default dict) -}}
{{- if $dllStorage.forcePermissions | default false }}
{{- $volumeName := ($dllStorage.plane | ternary (printf "%s-pv" $dllStorage.plane) "dll") -}}
{{- $volumePath :=  include "hpcc.getVolumeMountPrefix" (dict "root" .root "me" $dllStorage "name" "dll" "path" "queries") }}
{{ include "hpcc.changeMountPerms" (dict "root" .root "volumeName" $volumeName "volumePath" $volumePath) }}
{{- end }}
{{ include "hpcc.changePlaneMountPerms" (dict "root" .root "includeLabels" (list "dll")) }}
{{- end }}

{{/*
Check datastorage mount point, using hpcc.changeMountPerms
Pass in a dictionary with root
*/}}
{{- define "hpcc.checkDataMount" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $dataStorage := ($storage.dataStorage | default dict) -}}
{{- if $dataStorage.forcePermissions | default false }}
{{- $volumeName := printf "%s-pv" $dataStorage.plane -}}
{{- $volumePath :=  include "hpcc.getVolumeMountPrefix" (dict "root" .root "me" $dataStorage "name" "data" "path" "hpcc-data") }}
{{ include "hpcc.changeMountPerms" (dict "root" .root "volumeName" $volumeName "volumePath" $volumePath) }}
{{- end }}
{{ include "hpcc.changePlaneMountPerms" (dict "root" .root "includeLabels" (list "" "data" "lz")) }}
{{- end }}

{{/*
Check dalistorage mount point, using hpcc.changeMountPerms
*/}}
{{- define "hpcc.checkDaliMount" -}}
{{- $storage := (.root.Values.storage | default dict) -}}
{{- $daliStorage := ($storage.daliStorage | default dict) -}}
{{- if $daliStorage.forcePermissions | default false }}
{{- $volumeName := ($daliStorage.plane | default "dalistorage") -}}
{{- $volumePath :=  include "hpcc.getVolumeMountPrefix" (dict "root" .root "me" $daliStorage "name" "dali" "path" "dalistorage") }}
{{ include "hpcc.changeMountPerms" (dict "root" .root "volumeName" $volumeName "volumePath" $volumePath) }}
{{- end }}
{{ include "hpcc.changePlaneMountPerms" (dict "root" .root "includeLabels" (list "dali")) }}
{{- end }}

{{/*
Check sashastorage mount point, using hpcc.changeMountPerms
Pass in sashaName
*/}}
{{- define "hpcc.checkSashaMount" -}}
{{- if .me.storage.forcePermissions | default false }}
{{- $volumeName := (.me.storage.plane | default "sashastorage") -}}
{{- $volumePath :=  include "hpcc.getVolumeMountPrefix" (dict "root" .root "me" .me.storage "name" "sasha" "path" "sasha") }}
{{ include "hpcc.changeMountPerms" (dict "root" .root "volumeName" $volumeName "volumePath" $volumePath) }}
{{- end }}
{{- end }}

{{/*
Add any bundles
*/}}
{{- define "hpcc.addBundles" -}}
{{- $in := . -}}
{{- range .root.Values.bundles }}
- name: add-bundle-{{ .name | lower }}
{{ include "hpcc.addImageAttrs" $in | indent 2 }}
  command: [
           "ecl-bundle",
           "install",
           "--remote",
           "{{ .name }}"
           ]
  volumeMounts:
  - name: "hpccbundles"
    mountPath: "/home/hpcc/.HPCCSystems"
{{- end }}
{{- end }}


{{/*
Add security context
Pass in a dictionary with root and me defined
*/}}
{{- define "hpcc.addSecurityContext" }}
securityContext:
{{- if .root.Values.global.privileged }}
  privileged: true
  capabilities:
    add:
    - SYS_PTRACE
  readOnlyRootFilesystem: false
{{- else }}
  capabilities:
    drop:
    - ALL
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
{{- end }}
  runAsNonRoot: true
  runAsUser: 10000
  runAsGroup: 10001
{{ end -}}

{{/*
Generate instance queue names
*/}}
{{- define "hpcc.generateConfigMapQueues" -}}
{{- range $.Values.eclagent -}}
 {{- if not .disabled -}}
- name: {{ .name }}
  type: {{ .type | default "hthor" }}
  prefix: {{ .prefix | default "null" }}
 {{- end }}
{{ end -}}
{{- range $.Values.roxie -}}
 {{- if not .disabled -}}
- name: {{ .name }}
  type: roxie 
  prefix: {{ .prefix | default "null" }}
  queriesOnly: true
  storagePlane: {{ .storagePlane | default (include "hpcc.getDefaultDataPlane" $) }}
 {{- end }}
{{ end -}}
{{- range $.Values.thor -}}
 {{- if not .disabled -}}
- name: {{ .name }}
  type: thor
  prefix: {{ .prefix | default "null" }}
  width: {{ mul (.numWorkers | default 1) ( .channelsPerWorker | default 1) }}
 {{- end }}
{{ end -}}
{{- end -}}

{{/*
Generate list of available services
*/}}
{{- define "hpcc.generateConfigMapServices" -}}
{{- range $roxie := $.Values.roxie -}}
 {{- if not $roxie.disabled -}}
  {{- range $service := $roxie.services -}}
   {{- if ne (int $service.servicePort) 0 -}}
- name: {{ $service.name }}
  class: roxie
  type: roxie
  port: {{ $service.servicePort }}
  target: {{ $roxie.name }}
  public: {{ (ne ( include "hpcc.isVisibilityPublic" (dict "root" $ "visibility" $service.visibility)) "") | ternary "true" "false" }}
   {{- end -}}
  {{- end }}
{{ end -}}
{{- end -}}
{{- range $esp := $.Values.esp -}}
- name: {{ $esp.name }}
  class: esp
  type: {{ $esp.application }}
  port: {{ $esp.service.servicePort }}
  {{- if hasKey $esp "tls" }}
  tls: {{ $esp.tls }}
  {{- else }}
  tls: {{ ($.Values.certificates | default dict).enabled }}
  {{- end }}
  public: {{ (ne ( include "hpcc.isVisibilityPublic" (dict "root" $ "visibility" $esp.service.visibility))  "") | ternary "true" "false" }}
{{ end -}}
{{- range $dali := $.Values.dali -}}
{{- $sashaServices := $dali.services | default dict -}}
{{- if not $sashaServices.disabled -}}
{{- range $sashaName, $_sasha := $sashaServices -}}
{{- $sasha := ($_sasha | default dict) -}}
{{- if hasKey $sasha "service" -}}
{{- if and (not $sasha.disabled) ($sasha.service.servicePort) -}}
- name: {{ printf "sasha-%s" $sashaName }}
  class: sasha
  type: {{ $sashaName }}
  port: {{ $sasha.service.servicePort }}
{{ end -}}
{{ end -}}
{{ end -}}
{{ end -}}
{{ end -}}
{{- $sashaServices := $.Values.sasha | default dict -}}
{{- if not $sashaServices.disabled -}}
{{- range $sashaName, $_sasha := $sashaServices -}}
{{- $sasha := ($_sasha | default dict) -}}
{{- if and (not $sasha.disabled) (hasKey $sasha "service") -}}
{{- if $sasha.service.servicePort -}}
- name: {{ printf "sasha-%s" $sashaName }}
  class: sasha
  type: {{ $sashaName }}
  port: {{ $sasha.service.servicePort }}
{{ end -}}
{{ end -}}
{{ end -}}
{{- end -}}
{{- end -}}

{{/*
Add resource object
Pass in a dictionary with me defined
*/}}
{{- define "hpcc.addResources" }}
{{- if .me  }}
resources:
  limits:
{{ toYaml .me | indent 4 }}
{{- end }}
{{- end -}}

{{/*
Add resources object for stub pods
*/}}
{{- define "hpcc.addStubResources" }}
resources:
  limits:
    cpu: "50m"
    memory: "100M"
{{- end -}}

{{/*
Generate vault info
*/}}
{{- define "hpcc.generateEclccSecurity" -}}
{{- with .Values.security -}}
{{- if not (empty .eclSecurity) -}}
{{- toYaml (deepCopy .) }}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Sasha configmap
Pass in dict with root, me and secretsCategories
*/}}
{{- define "hpcc.sashaConfigMap" -}}
{{- $configMapName := printf "sasha-%s" .me.name -}}
apiVersion: v1
metadata:
  name: {{ printf "%s-configmap" $configMapName }}
data:
  {{ $configMapName }}.yaml:
    version: 1.0
    sasha:
{{ toYaml (omit .me "logging") | indent 6 }}
{{- include "hpcc.generateLoggingConfig" . | indent 6 }}
{{ include "hpcc.generateVaultConfig" . | indent 6 }}
{{- if .me.storage }}
      storagePath: {{ include "hpcc.getVolumeMountPrefix" (dict "root" .root "me" .me.storage "name" (printf "sasha-%s" .me.name) ) }}
{{- end }}
    global:
{{ include "hpcc.generateGlobalConfigMap" .root | indent 6 }}
{{- end -}}

{{/*
A template to generate Sasha service containers
Pass in dict with root, me and dali if container in dali pod
*/}}
{{- define "hpcc.addSashaContainer" }}
{{- $serviceName := printf "sasha-%s" .me.name }}
- name: {{ $serviceName | quote }}
  workingDir: /var/lib/HPCCSystems
  command: [ saserver ] 
  args: [
{{- with (dict "name" $serviceName) }}
          {{ include "hpcc.configArg" . }},
{{- end }}
          "--service={{ .me.name }}",
{{ include "hpcc.daliArg" .root | indent 10 }}
        ]
{{- include "hpcc.addResources" (dict "me" .me.resources) | indent 2 }}
{{- include "hpcc.addSecurityContext" . | indent 2 }}
  env:
  - name: "SENTINEL"
    value: "/tmp/{{ $serviceName }}.sentinel"
{{- with (dict "name" $serviceName) }}
{{ include "hpcc.addSentinelProbes" . | indent 2 }}
{{- end }}
{{ include "hpcc.addImageAttrs" (dict "root" .root "me" (.dali | default .me)) | indent 2 }}
{{- end -}}

{{/*
A template to generate Sasha service
Pass in dict with root and me
*/}}
{{- define "hpcc.addSashaVolumeMounts" }}
{{- $serviceName := printf "sasha-%s" .me.name -}}
{{- if .me.storage }}
{{- $volumeName := (hasKey .me.storage "plane") | ternary (printf "%s-pv" .me.storage.plane) $serviceName }}
{{ include "hpcc.addVolumeMount" (dict "root" .root "me" .me.storage "name" $volumeName) -}}
{{- end }}
{{ with (dict "name" $serviceName ) -}}
{{ include "hpcc.addConfigMapVolumeMount" . }}
{{- end }}
{{- if has "dalidata" .me.access }}
{{ include "hpcc.addDaliVolumeMount" . -}}
{{- end }}
{{- if has "data" .me.access }}
{{ include "hpcc.addDataVolumeMount" . }}
{{- end }}
{{- if has "dll" .me.access }}
{{ include "hpcc.addDllVolumeMount" . -}}
{{- end -}}
{{- end }}


{{/*
A template to generate Sasha service
Pass in dict with root and me
*/}}
{{- define "hpcc.addSashaVolumes" }}
{{- $serviceName := printf "sasha-%s" .me.name -}}
{{- if .me.storage }}
{{ include "hpcc.addVolume" (dict "root" .root "name" $serviceName "me" .me.storage "label" "sasha") -}}
{{ include "hpcc.addVolumes" (dict "root" .root "includeLabels" (list "sasha") "name" .me.storage.plane ) }}
{{- end }}
{{ with (dict "name" $serviceName) -}}
{{ include "hpcc.addConfigMapVolume" . }}
{{- end }}
{{- if has "dalidata" .me.access }}
{{ include "hpcc.addDaliVolume" . -}}
{{- end }}
{{- if has "data" .me.access }}
{{ include "hpcc.addDataVolume" . }}
{{- end }}
{{- if has "dll" .me.access }}
{{ include "hpcc.addDllVolume" . -}}
{{- end }}
{{- end -}}

{{/*
A template to generate the type of a service based on the visibility setting
Pass in dict with .root, .visibility defined
*/}}
{{- define "hpcc.isVisibilityPublic" }}
{{- if and (hasKey . "visibility") .visibility -}}
 {{- if hasKey .root.Values.global "visibilities" -}}
  {{- if hasKey .root.Values.global.visibilities .visibility -}}
   {{- $globalServiceInfo := get .root.Values.global.visibilities .visibility -}}
   {{- if (not (eq $globalServiceInfo.type "ClusterIP")) -}}
   true
   {{- end -}}
  {{- else -}}
   {{- required (printf "Specified service visibility %s not found in global visibilities section" .visibility) nil -}}
  {{- end -}}
 {{- else -}}
  {{- required "global visibilities section not found" nil -}}
 {{- end -}}
{{- end -}}
{{- end -}}

{{/*
A template to generate a service
Pass in dict with .root, .name, .service, .defaultPort, .selector defined
*/}}
{{- define "hpcc.addService" }}
{{- $lvars := dict "type" "ClusterIP" "labels" dict "annotations" dict -}}
{{- if hasKey . "service" -}}
 {{- if hasKey .service "labels" -}}{{- $_ := set $lvars "labels" (merge $lvars.labels .service.labels) -}}{{- end -}}
 {{- if hasKey .service "annotations" -}}{{- $_ := set $lvars "annotations" (merge $lvars.annotations .service.annotations) -}}{{- end -}}
 {{- if hasKey .service "visibility" -}}
  {{- if hasKey .root.Values.global "visibilities" -}}
   {{- if hasKey .root.Values.global.visibilities .service.visibility -}}
    {{- $globalServiceInfo := get .root.Values.global.visibilities .service.visibility -}}
    {{- if hasKey $globalServiceInfo "labels" -}}{{- $_ := set $lvars "labels" (merge $lvars.labels $globalServiceInfo.labels) -}}{{- end -}}
    {{- if hasKey $globalServiceInfo "annotations" -}}{{- $_ := set $lvars "annotations" (merge $lvars.annotations $globalServiceInfo.annotations) -}}{{- end -}}
    {{- $_ := set $lvars "type" $globalServiceInfo.type -}}
   {{- else -}}
    {{- required (printf "Specified service visibility %s not found in global visibilities section" .service.visibility) nil -}}
   {{- end -}}
  {{- else -}}
   {{- required "global visibilities section not found" nil -}}
  {{- end -}}
 {{- end -}}
{{- end -}}
apiVersion: v1
kind: Service
metadata:
  name: {{ .name | quote }}
  labels:
    helmVersion: 8.4.0-closedown0
{{- if $lvars.labels }}
{{ toYaml $lvars.labels | indent 4 }}
{{- end }}
{{- if $lvars.annotations }}
  annotations:
{{ toYaml $lvars.annotations | indent 4 }}
{{- end }}
spec:
  ports:
  - port: {{ required "servicePort must be specified" .service.servicePort }}
    protocol: TCP
    targetPort: {{ .service.port | default .defaultPort }}
  selector:
    server: {{ .selector | quote }}
  type: {{ $lvars.type }}
{{- end -}}


{{/*
Return access permssions for a given service
*/}}
{{- define "hpcc.getSashaServiceAccess" }}
{{- if (eq "coalescer" .name) -}}
dalidata
{{- else if (eq "wu-archiver" .name) -}}
dali data dll
{{- else if (eq "dfuwu-archiver" .name) -}}
dali
{{- else if (eq "dfurecovery-archiver" .name) -}}
dali
{{- else if (eq "file-expiry" .name) -}}
dali data
{{- else -}}
{{- $_ := fail (printf "Unknown sasha service:" .name ) -}}
{{- end -}}
{{- end -}}

{{/*
A template to generate a PVC
Pass in dict with root, me, name, and optional path
*/}}
{{- define "hpcc.addPVC" }}
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ printf "%s-%s" (include "hpcc.fullname" .) .name }}
  labels:
    app.kubernetes.io/name: {{ printf "%s-%s" (include "hpcc.fullname" .) .name }}
    app.kubernetes.io/instance: {{ .root.Release.Name }}
    app.kubernetes.io/managed-by: {{ .root.Release.Service }}
    helm.sh/chart: {{ include "hpcc.chart" . }}
spec:
  accessModes:
    - {{ .mode | default "ReadWriteMany" }}
  resources:
    requests:
      storage: {{ .me.storageSize }}
{{- if .me.storageClass }}
{{- if (eq "-" .me.storageClass) }}
  storageClassName: ""
{{- else }}
  storageClassName: "{{ .me.storageClass }}"
{{- end }}
{{- end }}
---
{{- end -}}

{{/*
A template to generate PVCs for each storage plane that has storageSize defined and has the appropriate label
Pass in dict with root, label.  optional name to restrict it to a single name.
*/}}
{{- define "hpcc.addPVCsFromPlanes" }}
{{- $storage := (.Values.storage | default dict) }}
{{- $planes := ($storage.planes | default list) -}}
{{- range $plane := $planes -}}
{{- if (hasKey $plane "storageClass") }}
{{- $pvcname := (printf "%s-pvc" $plane.name) -}}
{{- include "hpcc.addPVC" (dict "root" $ "name" $pvcname "me" $plane) }}
{{- end }}
{{- end }}
{{- end -}}

{{/*
Create placement related settings
Pass in dict with placement
*/}}
{{- define "hpcc.doPlacement" -}}
{{- if .me.placement }}
{{ toYaml .me.placement }}
{{- end -}}
{{- end -}}

{{/*
Check if there is any placement configuration
Pass in dict with root, job, target and type
*/}}
{{- define "hpcc.placementsByJobTargetType" -}}
{{- if .root.Values.placements }}
{{- $job := .job -}}
{{- $target := (printf "target:%s" .target | default "") -}}
{{- $type := printf "type:%s" .type -}}
{{- range $placement := .root.Values.placements -}}
{{- if or (has $target $placement.pods) (has $type $placement.pods) -}}
{{ include "hpcc.doPlacement" (dict "me" $placement) -}}
{{- else -}}
{{- range $jobPattern := $placement.pods -}}
{{- if mustRegexMatch $jobPattern $job -}}
{{ include "hpcc.doPlacement" (dict "me" $placement) -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Check if there is any placement configuration
Pass in dict with root, pod, target and type
*/}}
{{- define "hpcc.placementsByPodTargetType" -}}
{{- if .root.Values.placements }}
{{- $pod := .pod -}}
{{- $target := (printf "target:%s" .target | default "") -}}
{{- $type := printf "type:%s" .type -}}
{{- range $placement := .root.Values.placements -}}
{{- if or (has $pod $placement.pods) (has $target $placement.pods) (has $type $placement.pods) -}}
{{ include "hpcc.doPlacement" (dict "me" $placement) -}}
{{- end -}}
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Generate lifecycle, command and args
Pass in root, me and command
*/}}
{{- define "hpcc.addCommandAndLifecycle" -}}
{{- $misc := .root.Values.global.misc | default dict }}
{{- $postJobCommand := $misc.postJobCommand | default "" }}
{{- if and (not $misc.postJobCommandViaSidecar) $postJobCommand }}
lifecycle:
  preStop:
    exec:
      command:
      - >-
          {{ $postJobCommand }}
{{- end }}
command: ["/bin/bash"]
args:
- -c
- >-
    {{ .command }}
{{- if $misc.postJobCommandViaSidecar -}} ;
    touch /wait-and-run/{{ .me.name }}.jobdone
{{- else if $postJobCommand -}} ;
    {{ $postJobCommand }}
{{- end }}
{{- end -}}

{{/*
Use cert-manager to create a public certificate and private key for use with TLS
There are separate certificate issuers for local and public certificates
by default public certificates are self-signed and local certificates are signed
by our own certificate authority.  A CA certificate is also provided to the pod
so that we can recognize the signature of our own CA.
*/}}
{{- define "hpcc.addCertificate" }}
{{- if (.root.Values.certificates | default dict).enabled -}}
{{- $externalCert := or (and (hasKey . "external") .external) (ne (include "hpcc.isVisibilityPublic" .) "") -}}
{{- $issuer := ternary .root.Values.certificates.issuers.public .root.Values.certificates.issuers.local $externalCert -}}
{{- if $issuer -}}
{{- $namespace := .root.Release.Namespace -}}
{{- $service := (.service | default dict) -}}
{{- $domain := ( $service.domain | default $issuer.domain | default $namespace | default "default" ) -}}
{{- $exposure := ternary "public" "local" $externalCert -}}
{{- $name := .name }}

apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: {{ .component }}-{{ $exposure }}-{{ $name }}-cert
  namespace: {{ $namespace }}
spec:
  # Secret names are always required.
  secretName: {{ .component }}-{{ $exposure }}-{{ $name }}-tls
  duration: 2160h # 90d
  renewBefore: 360h # 15d
  subject:
    organizations:
    - HPCC Systems
  commonName: {{ $name }}.{{ $domain }}
  isCA: false
  privateKey:
    algorithm: RSA
    encoding: PKCS1
    size: 2048
  usages:
    - server auth
    - client auth
  dnsNames:
 {{- /* if servicename is passed we simply create a service entry of that name */ -}}
 {{- if .servicename }}
  - {{ .servicename }}.{{ $domain }}
 {{- /* if service parameter is passed in we are using the component config as a service config entry */ -}}
 {{- else if .service -}}
   {{- $public := and (hasKey .service "visibility") (not (eq .service.visibility "cluster")) -}}
   {{- if eq $public $externalCert }}
  - {{ .service.name }}.{{ $domain }}
   {{- end }}
 {{- /* if services parameter is passed the component has an array of services to configure */ -}}
 {{- else if .services -}}
  {{- range $service := .services }}
   {{- $external := and (hasKey $service "external") $service.external -}}
   {{- if eq $external $externalCert }}
  - {{ $service.name }}.{{ $domain }}
   {{- end }}
  {{- end }}
 {{- else if not $externalCert }}
  - "{{ $name }}.{{ $domain }}"
 {{- end }}
  uris:
  - spiffe://hpcc.{{ $domain }}/{{ .component }}/{{ $name }}
  # Issuer references are always required.
  issuerRef:
    name: {{ $issuer.name }}
    # We can reference ClusterIssuers by changing the kind here.
    kind: {{ $issuer.kind }}
    group: cert-manager.io
---
{{- end }}
{{- end }}
{{- end }}

{{/*
Experimental: Use certmanager to generate a key for roxie udp encryption.
A public certificate and private key are generated under /opt/HPCCSystems/secrets/certificates/udp.
Current udp encryption design would only use the private key.
Key is in pem format and the private key would need to be extracted.
*/}}
{{- define "hpcc.addUDPCertificate" }}
{{- if (.root.Values.certificates | default dict).enabled -}}
{{- $issuer := .root.Values.certificates.issuers.local -}}
{{- $namespace := .root.Release.Namespace -}}
{{- $name := .name -}}
{{- if $issuer }}
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: {{ .component }}-udp-{{ $name }}-cert
  namespace: {{ $namespace }}
spec:
  # Secret names are always required.
  secretName: {{ .component }}-udp-{{ $name }}-dtls
  duration: 2160h # 90d
  renewBefore: 360h # 15d
  subject:
    organizations:
    - HPCC Systems
  commonName: {{ $name }}.{{ $namespace }}
  isCA: false
  privateKey:
    algorithm: ECDSA
    encoding: PKCS1
    size: 256
  usages:
    - server auth
    - client auth
  # At least one of a DNS Name, URI, or IP address is required.
  uris:
  - spiffe://hpcc.{{ $namespace }}/{{ .component }}/{{ $name }}
  # Issuer references are always required.
  issuerRef:
    name: {{ $issuer.name }}
    # We can reference ClusterIssuers by changing the kind here.
    # The default value is Issuer (i.e. a locally namespaced Issuer)
    kind: {{ $issuer.kind }}
    group: cert-manager.io
---
{{- end }}
{{- end }}
{{- end }}

{{/*
Add a certficate volume mount for a component
*/}}
{{- define "hpcc.addCertificateVolumeMount" -}}
{{- $externalCert := or (and (hasKey . "external") .external) (ne (include "hpcc.isVisibilityPublic" .) "") -}}
{{- $exposure := ternary "public" "local" $externalCert }}
{{- /*
    A .certificate parameter means the user explictly configured a certificate to use
    otherwise check if certificate generation is enabled
*/ -}}
{{- if .certificate -}}
- name: certificate-{{ .component }}-{{ $exposure }}-{{ .name }}
  mountPath: /opt/HPCCSystems/secrets/certificates/{{ $exposure }}
{{- else if (.root.Values.certificates | default dict).enabled -}}
{{- $issuer := ternary .root.Values.certificates.issuers.public .root.Values.certificates.issuers.local $externalCert -}}
{{- if $issuer -}}
- name: certificate-{{ .component }}-{{ $exposure }}-{{ .name }}
  mountPath: /opt/HPCCSystems/secrets/certificates/{{ $exposure }}
{{- end }}
{{- end -}}
{{- end -}}

{{/*
Add a secret volume for a certificate
*/}}
{{- define "hpcc.addCertificateVolume" -}}
{{- $externalCert := or (and (hasKey . "external") .external) (ne (include "hpcc.isVisibilityPublic" .) "") -}}
{{- $exposure := ternary "public" "local" $externalCert -}}
{{- /*
    A .certificate parameter means the user explictly configured a certificate to use
    otherwise check if certificate generation is enabled
*/ -}}
{{- if .certificate -}}
- name: certificate-{{ .component }}-{{ $exposure }}-{{ .name }}
  secret:
    secretName: {{ .certificate }}
{{- else if (.root.Values.certificates | default dict).enabled -}}
{{- $issuer := ternary .root.Values.certificates.issuers.public .root.Values.certificates.issuers.local $externalCert -}}
{{- if $issuer -}}
- name: certificate-{{ .component }}-{{ $exposure }}-{{ .name }}
  secret:
    secretName: {{ .component }}-{{ $exposure }}-{{ .name }}-tls
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Add the certficate volume mount for a roxie udp key
*/}}
{{- define "hpcc.addUDPCertificateVolumeMount" }}
{{- if (.root.Values.certificates | default dict).enabled -}}
{{- if .root.Values.certificates.issuers.local -}}
- name: certificate-{{ .component }}-udp-{{ .name }}
  mountPath: /opt/HPCCSystems/secrets/certificates/udp
{{- end -}}
{{- end -}}
{{- end -}}

{{/*
Add a secret volume for a roxie udp key
*/}}
{{- define "hpcc.addUDPCertificateVolume" }}
{{- if (.root.Values.certificates | default dict).enabled -}}
{{- if .root.Values.certificates.issuers.local -}}
- name: certificate-{{ .component }}-udp-{{ .name }}
  secret:
    secretName: {{ .component }}-udp-{{ .name }}-dtls
{{ end -}}
{{- end -}}
{{- end -}}

{{/*
A template to filter out a set of keys from a generated config yaml.
Used to regenerate a configmap without the exclusions, so that it can be
used to form an SHA as an annotation in a pod.
This means pods only auto-restart if the non-excluded parts change.

Pass in root, me, configMapHelper, component, excludeSectionRegexList and excludeKeyList
excludeSectionRegexList is a list of regexp's that filter out top-level sections, e.g. [".*spec.yaml$" ]
excludeKeyList is a list of key values to exclude from each section, e.g. [ "global", "esp.services" "esp.queues"]

The configMap data section is reconstructed based on filtering out matches.

Used to exclude parts of the config which are always allowed to change without causing a pod restart.
e.g. a cache of secrets, with an auto reload/refresh mechanism, or 'replicas'.
*/}}
{{- define "hpcc.filterConfig" }}
{{- $config := fromYaml (include .configMapHelper .) -}}
{{- $configCtx := dict -}}
{{- $excludeSectionRegexList := .excludeSectionRegexList -}}
{{- $excludeKeyList := .excludeKeyList -}}
{{- range $configElementName, $configElementDict := $config.data -}}
  {{- $_ := set $configCtx "excludeSection" false -}}
  {{- range $regex := $excludeSectionRegexList -}}
    {{- if (regexMatch $regex $configElementName) -}}
      {{- $_ := set $configCtx "excludeSection" true -}}
    {{- end -}}
  {{- end -}}
  {{- if not $configCtx.excludeSection -}}
    {{- $configDictCtx := dict -}}
    {{- range $key := $excludeKeyList -}}
      {{- $_ := set $configDictCtx "keyDictStr" (regexReplaceAll "(.*)\\..*$" $key "${1}") -}}
      {{- if eq $configDictCtx.keyDictStr $key -}}{{/* single component key, e.g. "global"*/}}
        {{- $configElementDict := (unset $configElementDict $key) -}}
      {{- else -}}{{/* scopes component key, e.g. "eclccserver.queue"*/}}
        {{- $_ := set $configDictCtx "keyKeyStr" (regexReplaceAll ".*\\.(.*)$" $key "${1}") -}}
        {{- $subDict := get $configElementDict $configDictCtx.keyDictStr -}}
        {{- if $subDict -}}
          {{- $_ := set $configElementDict $configDictCtx.keyDictStr (unset $subDict $configDictCtx.keyKeyStr) -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}{{/*range $key*/}}
    {{- $configYaml := toYaml $configElementDict -}}
    {{- $_ := set $config.data $configElementName $configYaml -}}
  {{- else -}}
    {{- $configData := (unset $config.data $configElementName) -}}
    {{- $_ := set $config "data" $configData -}}
  {{- end -}}
{{- end -}}{{/*range $configElementName*/}}
{{ toYaml $config }}
{{- end -}}

{{/*
A template to generate a component config
Pass in root, me, configMapHelper
*/}}
{{- define "hpcc.generateConfig" }}
{{- $config := fromYaml (include .configMapHelper .) -}}
{{- range $configElementName, $configElementDict := $config.data -}}
  {{- $configYaml := toYaml $configElementDict -}}
  {{- $_ := set $config.data $configElementName $configYaml -}}
{{- end }}
{{ toYaml $config }}
{{- end -}}

{{/*
A template to generate an SHA from a component config, to be used to annotate a Deployment,
such that it will auto restart if the SHA changes.
Uses filterConfig helper to select pertinent parts of the config to be part of the SHA.
Pass in root, me, configMapHelper, component and excludeKeys
excludeKeys is a comma separated list of key values to exclude from each section, e.g. "global,esp.services,esp.queues"

globalExcludeSectionRegexList below is hard-coded list of section regexp's to exclude.
globalExcludeList below is a hard-coded list of global keys to exclude.

*/}}
{{- define "hpcc.getConfigSHA" }}
{{- $globalExcludeList := list (printf "%s.replicas" .component) -}}
{{- $globalExcludeSectionRegexList := list ".*spec.yaml$" -}}
{{- $combinedExcludeKeyList := concat (splitList "," (.excludeKeys | default "")) $globalExcludeList -}}
{{- $ctx := merge (omit . "excludeKeys") (dict "excludeSectionRegexList" $globalExcludeSectionRegexList "excludeKeyList" $combinedExcludeKeyList) -}}
{{- include "hpcc.filterConfig" $ctx | sha256sum }}
{{- end -}}

{{/*
A template to ensure that the flag specifying whether kubernetes resource validation is allowed exists.  When running helm
in template mode access to functions like "lookup" that need to access the kubernetes API are diabled.  We use that function
to validate things like the existance of secrets we have dependencies on.  We also check the Capabilities.APIVersions for the
existence of custom CRDS which are not updated when kubernetes API access is not allowed.

By default the behavior should now be correct for both install and template.

Setting the default requires an extra call to lookup.  To avoid a call to "lookup" every time we cache the value in
global.noResourceValidation flag.  This behavior can be overriden by the caller using "--set global.noResourceValidation=true"
*/}}
{{- define "hpcc.ensureNoResourceValidationFlag" }}
  {{- if not (hasKey .root.Values.global "noResourceValidation" )}}
    {{- $_ := set .root.Values.global "noResourceValidation" (not (lookup "v1" "Namespace" "" "")) -}}
  {{- end }}
{{- end -}}

{{/*
A template to output a merged environment. Pass in a list with global then local environments. Only the last specified value for each named environment variable will be output
*/}}
{{- define "hpcc.mergeEnvironments" -}}
{{- $result := dict -}}
{{- range . -}}
{{- $_ := set $result .name .value -}}
{{- end -}}
{{- range $key,$value := $result -}}
- name: {{ $key }}
  value: {{ $value }}
{{ end -}}
{{- end -}}
